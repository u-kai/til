Organizing Different Types of Code Different projects in an infrastructure codebase define different types of elements of your system, such as applications, infrastructure stacks, server configuration modules, and libraries. And these projects may include different types of code, including declarations, imperative code, configuration values, tests, and utility scripts. Having a strategy for organizing these things helps to keep your codebase maintainable. Project Support Files Generally speaking, any supporting code for a specific project should live with that project’s code. A typical project layout for a stack might look like Example 18-1. Example 18-1. Example folder layout for a project
├── build.sh
   ├── src/
   ├── test/
   ├── environments/
   └── pipeline/ This project’s folder structure includes: src/ The infrastructure stack code, which is the heart of the project. test/ Test code. This folder can be divided into subfolders for tests that run at different phases, such as offline and online tests. Tests that use different tools, like static analysis, performance tests, and functional tests, probably have dedicated subfolders as well. environments/ Configuration. This folder includes a separate file with configuration values for each stack instance. pipeline/ Delivery configuration. The folder contains configuration files to create delivery stages in a delivery pipeline tool (see “Delivery Pipeline Software and Services”). build.sh/ Script to implement build activities. See “Using Scripts to Wrap Infrastructure Tools” for a discussion of scripts like this one. Of course, this is only an example. People organize their projects differently and include many other things than what’s shown here. The key takeaway is the recommendation that files specific to a project live with the project. This ensures that when someone checks out a version of the project, they know that the infrastructure code, tests, and delivery are all the same version, and so should work together. If the tests are stored in a separate
project it would be easy to mismatch them, running the wrong version of the tests for the code you’re testing. However, some tests, configuration, or other files might not be specific to a single project. How should you handle these?

