# マクロについて

-   macro_rules!は Rust でマクロ定義する主要な方法
-   !はマクロを呼び出す時にだけ付けるもので定義の際にはつけない

```rust
macro_rules! assert_eq {
        ($left:expr, $right:expr)=> ({
            match(&$left, &$right) {
                (left_val, right_val)=>{
                    if !(*left_val == *right_val) {
                        panic!("assertion failed: `(left == right)` \
                                (left:`{:?}`, right: `{:?}`)",
                                left_val,right_val)
                        ")
                    }
                }
            }
        })
}
```

-   macro_rules!で定義されたマクロはパターンマッチのみで動作する

```
 (パターン 1)=>(テンプレート 1);
 (パターン 2)=>(テンプレート 2);
```

## マクロ展開の基礎

-   マクロ展開はコンパイルの初期のステージで行われる

    -   コンパイラはソースコードを最初から最後まで読み込むが，この際にマクロの定義と展開を行う
    -   マクロが定義される前に呼び出すことはできない
        -   コンパイラはプログラムの残りの部分を見る前にマクロを展開するので
        -   関数は呼び出しは定義の前でもコンパイル後に行われるから問題ないが，マクロの場合は定義と呼び出しの順序を気にする必要があるということ

-   正規表現と同様にパターンには特定のマッチ動作を引き起こす特殊文字もあるが，それら以外の文字は全てカンマも含めその文字のままマッチする
    -   もしマッチしなければパターンマッチ全体が失敗する

## 繰り返し

```rust
macro_rule! vec {
    // vec![0;1000]のような式にマッチする
    ($elem:expr ; $n:expr) => {
        ::std::vec::from_elem($elem, $n)
    };
    // vec![1,2,3]のような式にマッチする
    // $( $x:expr ),*は繰り返し機能を有している
    // このパターンはカンマで区切られた0個以上の式にマッチする
    // 一般に$(PATTERN ),*は任意のカンマで区切られたリストで，リストの各要素がPATTERNにマッチするものにマッチする
    ($( $x:expr ),* ) => {
        <[_]>::into_vec(Box::new([ $( $x ),* ]))
    };
    // けつカンマバージョン
    ($( $x:expr ),+ , ) => {
        vec![ $($x),* ]
    };
}
```

| パターン  | 意味                                           |
| --------- | ---------------------------------------------- |
| $(...)\*  | 0 個以上にマッチ.セパレータなし                |
| $(...),\* | 0 個以上にマッチ.セパレータはカンマ            |
| $(...),+  | 1 個以上にマッチ.セパレータはカンマ            |
| $(...),?  | 0 個または 1 個以上にマッチ.セパレータはカンマ |

## 参考資料

https://qiita.com/k5n/items/758111b12740600cc58f
