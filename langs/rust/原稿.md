1. それでは Rust 言語の紹介をさせていただきます

- まず発表の前に注意事項ですが，本発表は私の組織とは関係がなく，私個人の意見です．
- また，少し Rust にバイアスのかかった話になるかもしません.
- 他の言語を否定するつもりもありませんし，そのような発言はするつもりはありませんが，もしそのように聞こえてしまったら申し訳ないです.
- また，私も全ての言語を知っているわけではないので，そんなこと Python でもできる！みたいなことはあるかもしれませんがご容赦ください
- それではよろしくお願いします.

1. 今回はこちらの流れでやらせていただきます
1. まず本日の狙いですが,こちらは単純に，一人でも多くの方に Rust に興味を持ってもらうことです.

- 5 分だけですので，全ての魅力を丁寧に説明することは今回諦めました．
- なんだかよくわからんけど，面白そう！とか,やってみようかな〜と思っていただければ私の今回の目標はクリアかな，と思っています
- また，あわよくば Rust の輪を広げていけたら嬉しいなと思っております

1. では Rust とはどんなものかの概要をお話しさせていただきます
1. ネットとかで

- 比較的若い言語だとか，愛されている言語ランキングが 7 年連続の 1 位とか，実行スピードがめっちゃ速いけど，安全とか，名だたる企業がどんどん注目しているとか言われています
- これだけでもなんだかすごそうだし，やってみたくなりますよね！
- ただ，それとともに学習コストが高いとも言われています

1. そうなると，もしかしたらこのような意見が出てくるかもしれません

- C 言語並みのミッションクリティカルなスピードって求められるのか？とかむずかしそうだな．．とかですね
- 実際これは嘘ではなく，ほとんどのシステムには C 言語並みのスピードを必要せずとも十分価値は出せています.

- ですが，私から言わせると，Rust はスピードだけじゃないです！
- 仕様や標準パッケージなどが私の中では最高です
- 他の言語を悪くいうつもりはないですが，ここは Rust だったら簡単に書けたのにな〜みたいなことは多々あります
- ですので，仕様にさえ慣れてしまえば一気に好きな言語になること間違いなしです！

1. ここに僕が好きな使用や機能一覧を乗っけています

- たくさんありますよね！
- これは無理やり乗っけているわけではなく，本当にすごい！描くのが楽しい！と思えるような機能ばかりです!
- 今回はこの中の一部についてお話しさせていただきます

1. まずは堅牢でスマートな型システムです

- Rust は静的型付け言語の中でも強い型整合を必要とします
- これはどういうことかというと，コンパイルさえ通ってしまえばコードが動くと自信が持てるということです
- また下の例のように，型が多くを語ってくれるため可読性が高いコードができます
- この例だと 引数の型がわかることはもちろん，処理が失敗するかもしれないことが Result という型レベルで表現されています.
- また，賢い型推論機能があるので，型を記述するのは，関数などの定義時のみでよく，いちいち型を記述する必要がないことも推しポイントかと思います

1. 前のページでも少し触れましたが，失敗を表せる Result 型や存在しない可能性を表せる Option 型など便利な型が標準で組み込まれています

- しかもそれらの型にはよくデザインされたメソッドがたくさん備えられており，その振る舞いが doctest という方法で示されています
- この図のように 拡張機能をインストールした VSCode で作業すると，型から多くのメソッドがサジェストされますし，そのメソッドの使い方も，マウスをフォーカスするだけで見ることができます

1. ただ，型の整合性があまりにも強いと，柔軟性が下がるのではないかという意見もあるかと思います

- 下の例がまさにそれでして，my_print は文字列型を受け取って，標準出力するだけの関数なのですが，文字列型以外の整数型ですとか，文字列を表現するものでも str 型と String 型は Rust では異なるためこのコードですら動きません

1. 柔軟にする方法としてはいくつかありますが，ここでは私が好きな，Generic と trait を使ったものを紹介します

- trait とは他言語で言うところの interface とか protocol にあたるものです
- trait の私的なすごいと思うところは，定義とは別に実装できることです
- 時間もないので詳細は割愛しますが，3rd パーティや標準の型に自分の trait を後から実装できたり，逆に 3rd パーティの trait が勝手に自分の型に実装されている，といったことが可能になります
<!-- - これは非常に強力であると思っています.継承みたいに感じてしまうかもしれませんが，継承見たく，親子関係はなく，また，型の定義とは別のところで trait を実装することになりますので，型自体は trait のことを気にしなくていいです．つまり依存関係はほとんどないです -->
- このコードを見ながら説明します． まず my_print_use_generic は Printable trait を実装していればどんなものでも引数に代入でき ru ことをこの P というジェネリック引数を使って表しています
- また先ほども述べたように Printable trait は型に対して後から実装できます
- そのため，自分で定義した Printable trait は文字列などの標準型や他ライブラリーの型にも実装することができ，結果的にいろんな型を my_print_use_generic 関数の引数として利用することができます
- もちろん最後の例のように Printable trait を実装していない型に対しては実行できません
- このように Rust では堅牢ではあるが，柔軟にもできる型システムが私はとても好きです
- もちろん動的型付けと比べて考えることは格段に増えはしますが，しっかりとした型の設計ができれば，利はしっかり出てきます
- 開発の初期より後の方でコードの解読やリファクタリングが型のおかげで捗るのは間違いないと思います

1. 次は test に対する機能についてです

- なんと rust は言語仕様に test が組み込まれています
- ほとんどの言語は test を行うのにまずライブラリのインストールから始まると思いますが，簡単なテストであれば rust はライブラリのインストールは不要です
- また rust でテストを記述する場合，実装ファイルと同じ箇所にテストを書くことができます
- これは一見，よくないように見えるかもしれませんが，同じファイルに書けることで，テストを書く気持ち的ハードルは下がりましたし，他の人のコードの挙動を見る時も同じファイルのテストを見ればすぐに確認できるので私は仕様がとても気に入っています
- tdd とも相性がいいと感じています

1. これらの特性を踏まえて僕なりの本番プロジェクトで Rust を採用する旨みを考察しました

- まずは堅牢な型システムがあるので高速なフィードバックが得られたり，品質の高いシステムが作りやすいと思います
- またテストが書きやすさや型システムのおかげで可読性や保守性の高いコードが比較的書きやすいのかなと思います

- あとは単純に実行が早かったり，メモリ消費量が少ないことで，消費リソースを抑えることができますので，クラウド利用のコスト削減などにも寄与できます
- 最後のコンテンツはあまり今回紹介しませんでしたが，関数型の思想をふんだんに取り入れているため，宣言的な API が多く，少ない記述で可読性と品質の高いコードが書きやすいと思っています

1. 他にたくさんの魅力がありますが今日はここで機能自体の紹介は終了します

- 正直僕の説明が拙くわかりにくかったかもしれないですが，凄さを雰囲気でもわかってもらえれば幸いです

1. このページでは Rust を学ぶ上でのおすすめコンテンツの紹介です

- rust the book はわかりやすく，無料ですのでおすすめです
- また rust playground は Rust を Web 環境で実行できて環境構築いらずです
- さらにすごいのが公開されているライブラリを rust playground 上で試せることです
- 最後にプログラミング Rust は僕が一番愛用しているオライリー本です．
- 本格的に始められる型には辞書的にも有用かと思います

1. 本日はありがとうございました．

- Rust の凄さはまだまだこれだけではないです！
- もしご興味あれば可能な範囲でご相談にも乗らせていただきますのでお話しください
- 私も初心者ですので一緒に勉強できれば嬉しいです!

---

1. 次はマクロという機能についてです

- マクロというのは Excel についているものではないです．詳しくはないですが C++などにも存在するものらしいです
- このマクロは！マークがある関数みたいなものですが，関数よりも表現力が高く，実態も違います
- 実態としては，コンパイル前にマクロの部分が展開されてコードが生成されるイメージです

1. 実際の例を見ながら説明させていただきます

- 自作でマクロを作成するときは基本的にはこのように定義します
- ここがマクロの名前で，この部分が引数の定義です
- ここが実際に展開されるコードです
- ここではタイマーをセット，ここでは，このこーどに到達するまでにかかった時間を出力しています
- ここについては後ほど説明します
- 今回のマクロで利用する引数の秒数分スリープする関数です
- 実際にマクロを利用しています.上の関数名を第一引数に入れて，1 という数字を第 2 引数に入れています
- そうすると実行結果としてこのような文字列が出力されます
- 秒数については小数点以下はブレる可能性があります

1. では先ほどのコードがどのように展開されているのかを説明し，マクロの凄さをお伝えします

- こちらがマクロを実行する際のコードで，したがマクロの定義の再掲です
- まず，このドラーの fn は今回の実行例ですと，heavy_calc になります，そしてドラーの args は 1 になります．
- そして先ほど説明を省略したこの部分でそのコードが展開されます
- わかりやすくするようにコンパイル前のコード展開のイメージをここに載せます
- 1 行目，三行目はマクロ定義のままですが，二行目は引数に入れたものが展開されています
- このようにマクロではコードの間に任意のコードを差し込むなど，関数では到達困難な表現力を持っています
- rust のルール上普通に書くのが難しいものなどはマクロで用意されていたりします
- 実際の本番プロジェクトなどでマクロを多用することは非推奨です
- なぜなら，コードの可視性が低いからです
- ですが，遊ぶ分には大変面白いと私は思っており，今回紹介させていただきました
