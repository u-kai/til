# chan

- チャネルを正しいコンテキストに入れるため初めにすべきことは，チャネルの所有権を割り振ること

  - 所有権を持っているのはチャネルを初期化し，書き込み，閉じるゴルーチン
  - GC がない言語でのメモリのように，プログラムで論理的に判断していくには，どのゴルーチンがチャネルを所有しているのかをはっきりとさせることが重要
  - 単方向チャネルを宣言することはチャネルを所有しているかをはっきりさせることが重要
  - 単方向チャネルを宣言することはチャネルを所有するゴルーチンとチャネルを利用するだけのゴルーチンを区別できるようにするための道具

- チャネルの所有者の責務
  - チャネルを初期化する
  - 書き込みを行うか，他のゴルーチンに所有権を渡す
  - チャネルを閉じる
  - 上の 3 つの手順をカプセル化して読み込みチャネルを経由して公開する
- 上記責務を所有者に与えることで以下のことが起きる

  - チャネルを初期化するゴルーチンなので，nil チャネルに書き込んでデッドロックしてしまう危険性がなくなる
  - チャネルを初期化するゴルーチンなので，nil チャネルを閉じることによって起こる panic の危険性がなくなる
  - チャネルを閉じるタイミングを決めるゴルーチンなので閉じたチャネルに書き込んで panic になる危険性がなくなる
  - チャネルを閉じるタイミングを決めるゴルーチンなのでチャネルを二度閉じてしまうことによって panic になる危険性がなくなる
  - コンパイル時に型チェックを行って，チャネルに対する不適切な書き込みを防ぐ

- 読み込みの際に起こりうるブロックする操作について，チャネルの消費者として 2 つ注意する
  - チャネルがいつ閉じられたのかを把握する
    - 対 s つなことは読み込みはブロックしうるという事実を扱うべきであるということ
  - いかなる理由でもブロックする操作は責任を持ってする

```go
package main

import (
	"fmt"
)

func main() {
	resultStream := chanOwner()
    // 利用側はそこまで気にしなくていい
    // 利用者にはchanの読み込み権限しかない
	for result := range resultStream {
		fmt.Printf("Received: %d\n", result)
	}
	println("Done")
}
// チャネルの所有者であるため，chanの生成と，close,を確実にしている
func chanOwner() <-chan int {
	resultStream := make(chan int, 5)
	go func() {
		defer close(resultStream)
		for i := 0; i <= 5; i++ {
			resultStream <- i
		}
	}()
	return resultStream
}
```
