---
marp: true
---

# プロセス管理

---

- システムには複数のプロセスが存在しているのが普通
- ps aux コマンドを実行すればシステムに存在する全プロセスを列挙できる

---

# プロセスの生成

- 新しくプロセスを生成する目的は次の 2 つ
  - a.同じプログラムの処理を複数のプロセスに分けて処理する（例：Web サーバによる複数リクエストの受付）
  - b.別のプログラムを生成する（例：bash から各種プログラムの新規生成）
- これらを実現するために、Linux では fork()関数と execve()関数を使う
  - 内部的にはそれぞれ clone()、execve()というシステムコールを呼び出す
  - 上記の a.の場合は fork()関数のみ、b.の場合は fork()関数と execve()関数の両方を使う。

---

# 同じプロセスを 2 つに分裂させる fork()関数

- fork()関数を発行すると、発行したプロセスのコピーを作った上で、どちらも fork()関数から復帰させる
- 生成元のプロセスを「親プロセス」、生成されたプロセスを「子プロセス」と呼ぶ
- 流れ
  1. 親プロセスが fork()関数を呼ぶ。
  1. 子プロセス用メモリ領域を確保して、そこに親プロセスのメモリをコピーする
  1. 親プロセスと子プロセスは両方とも fork()関数から復帰する。親プロセスと子プロセスは後述のように fork()関数の戻り値が異なるため、処理を分岐させることができる（後述）。

---

# 図のセル

---

# fork を確かめるサンプルプログラム

```python
import os,sys

# forkは親プロセスには子プロセスのpidを、子プロセスには0を返す
ret = os.fork()
# case child process
if ret == 0 :
    print("子プロセス:pid={},親プロセスのpid={}".format(os.getpid(),os.getppid()))
    exit()

# case parent process
elif ret > 0:
    print("親プロセス:pid={},子プロセスのpid={}".format(os.getpid(),ret))
    exit()
sys.exit(1)
```

---

# 別のプログラムを起動する execve()関数

- fork()関数によってプロセスのコピーを作った後は、子プロセス上で execve()関数を発行する
- これによって子プロセスは、別のプログラムに置き換えられる
- このときの処理の流れは次のとおり
  1. execve()関数を呼び出す
  1. execve()関数の引数で指定した実行ファイルからプログラムを読み出して、メモリ上に配置するために必要な情報を読み出す。
  1. 現在のプロセスのメモリを新しいプロセスのデータで上書きする。
  1. 新しいプロセスの最初に実行すべき命令から実行開始する。
- つまり、fork()関数ではプロセス数が増えるのに対して、まったく別のプログラムを生成する場合は、プロセス数が増えるのではなく、あるプロセスを別物で置き換えるという形になる

---

# 図を載せる

---

# 実行ファイル

- execve()関数の実現のために，実行ファイルはプログラムのコードやデータに加えてプログラムの起動に必要なデータを保持している

  - コード領域のファイル上オフセット，サイズ，およびメモリマップ開始アドレス
  - データ領域についての上記と同じ情報
  - 最初に実行する命令のメモリアドレス(エントリポイント)

---

# ELF

- Linux では、実行ファイルのフォーマットとして ELF（Executable and Linkable Format）を採用している
- 実行ファイルは複数の領域に分けられており，それぞれをセクションと呼ぶ
- セクションの情報は二行を一組として表示される
- 数値は全て 16 進数
- セクションの主な情報は次の通り
  - セクション名
  - メモリマップ開始アドレス
  - ファイル内のオフセット
  - サイズ
- セクション名が.text であるものがコードセクション，.data であるものがデータセクション

---

# プロセスの親子関係

- プロセスを新規生成するにはおやプロセスがこプロセスを生成する
- つまり親の最終視点が気になる
- コンピューターの電源を入れると次のような順序でシステムが初期化される

1. コンピューターの電源を入れる
1. BIOS や UEFI などのファームウェアが起動してハードウェアを初期化する
1. ファームウェアが GRUB などのブートローダーを起動する
1. ブートローダーがカーネルを起動する
1. カーネルが init プロセスを起動する
1. init プロセスがシステムの各種サービスを起動する

---

# プロセスの状態

- Linux のシステムには常に大量のプロセスが存在する
  - これらのプロセスは常に CPU を使っているわけではない
- プロセスは CPU を使わずになんらかのイベントが発生するのをまつスリープ状態になっている
- 一方，プロセスが CPU を使いたいという時は実行可能状態という
- プロセスが CPU を使っている時は実行状態という
- プロセスが終了するとゾンビ状態になる

---

# プロセスの終了

- プロセスを終了させるには exit_group()というシステムコールを呼ぶ
- exit_group()関数の中で，カーネルはメモリなどのプロセスのリソースを回収する
- プロセスが終了した後は親プロセスが wait()や waitpid()といったシステムコールを呼び出すことによって次のような情報を取得できる
  - プロセスの戻り値
  - シグナルによって終了したか否か
  - 終了までにどれだけ CPU 時間を使ったか

---

# ゾンビプロセスと孤児プロセス

- おやプロセスが子プロセスの状態を wait()系システムコールによって得られるということは,裏を返せば子プロセスが終了してからおやプロセスがこれらのシステムコールを呼ぶまで終了した子プロセスはシステム上で存在していることになる
- この状態をゾンビプロセスと呼ぶ
- プロセスの親が wait 系システムコールの実行前に終了した場合，当該プロセスは孤児プロセスとなる
- カーネルは init を孤児プロセスの新しい親プロセスにする
- init は賢く，定期的に wait()系システムコールの実行を発行してシステムのリソースを回収している

---

# シグナル

- シグナルとは、あるプロセスが他のプロセスに何かを通知して、外部から実行の流れを強制的に変えるための仕組み
- シグナルには複数の種類があるが，SIGINT が有名どころ
  - このシグナルは bash などのシェルにおいて Ctrl+c と打つと送られるものでプロセスを終了させる
- プロセスは各シグナルについて、シグナルハンドラという処理をあらかじめ登録可能
  - プロセスの実行中に当該シグナルを受信すると、実行中の処理をいったん中断してシグナルハンドラを動作させ、それが終わったら元の場所に戻ってきて動作を再開させる
  - あるいはシグナルを無視するという設定も可能

---

# デーモン

- 簡単に言うと、デーモンは常駐プロセスのこと
- 普通のプロセスはユーザが立ち上げてから何らかの一連の処理をしてから終了するが，デーモンはそうではなく、場合によってはシステムの開始から終了まで存在し続ける
- デーモンには次のような特徴がある

  - 端末から入出力する必要がないので、端末が割り当てられていない。
  - あらゆるログインセッションが終了しても影響を受けないように、独自のセッションを持つ。
  - デーモンを生成したプロセスがデーモンの終了を気にしなくていいように、init が親になっている。

- 上記の特徴を有してなくとも便宜上デーモンと呼ぶプロセスもある
