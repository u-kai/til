---
marp: true
---

# 記憶階層

---

# 記憶装置の階層構造

- 図を載せる

- コンピューターには様々な記憶階層があり，上の層程アクセスが高速な反面サイズは小さく，バイトあたりの価格が高価であることを図は示している

---

# キャッシュメモリ

- CPU の動きを単純化すると次のような動作を繰り返している

1. 命令を読み出して，命令の内容を元にメモリからレジスタにデータを読み出す
1. レジスタ上のデータを元に計算する
1. 計算結果をメモリに書き戻す

- レジスタへのアクセスは大体 1ns 未満だが，メモリアクセスは数十 ns かかる
- そのため処理 1，3 がボトルネックにならないように CPU の中にはキャッシュメモリという高速な記憶装置がある
- メモリからレジスタにデータを読み出す際はまずキャッシュメモリにキャッシュラインという単位でデータを読み出した上でそのデータをレジスタに読み出す
- キャッシュラインのサイズは CPU 依存で，この処理はカーネルは関与しない

---

# 参照の局所性

- 多くのプログラムには参照の局所性がある

  - 時間的局所性
    - ある時点でアクセスしたメモリは近い将来に再びアクセスする可能性が高い
      - ループ処理ないのコードなど
  - 空間的局所性
    - ある時点でアクセスしたメモリは近い将来に近い場所のデータにアクセスする可能性が高い
      - 配列要素への全査走時における配列データ

- つまり，メモリへのアクセスのほとんどがキャッシュメモリに対するアクセスになることは珍しくない

---

# Simultaneous Multi Threading(SMT)概要

- CPU の計算処理の時間に比べてメモリアクセスやキャッシュメモリアクセスの方が時間がかかる
- このため処理によってはメモリなどへのデータ転送を行っているだけで CPU の計算リソースは空いている状態ということもある
- また，CPU は整数演算をするユニットと浮動小数点演算をするユニットが存在するが，整数演算をしている間は浮動小数点演算ユニットは空いていることになる
- このような空きリソースをハードウェアの SMT という機能によって有効活用できる
  - Threading はプロセスに対する言葉のスレッドとは関係なし

---

# Simultaneous Multi Threading(SMT)機能

- SMT は CPU コアの中のレジスタなどの一部の資源を複数作ってそれぞれをスレッドとする
- Linux カーネルは各スレッドを論理 CPU として認識する
- 1 つの CPU 上に t0,t1 という 2 つのスレッドが存在していて，かつ t0 の上ではプロセス p0 が，t1 の上ではプロセス p1 が動作しているとする
- t0 上で p0 が動作している時に CPU の何らかのリソースが空いていれば t1 上の p1 はそのリソースを使って処理を先に進められる
- つまり，p0 と p1 との間で使用リソースが重ならないような場合は SMT の効果が大きい
- しかし，p0 と p1 の処理が重なることが大きい場合は SMT を使う方が処理として重くなるらしい

---

# Translation Lookaside Buffer(TLB)

- プロセスが所定の仮想アドレスのデータにアクセスするには次のような手順を踏む必要がある

1. 物理メモリ上に存在するページテーブルの参照によって仮想アドレスを物理アドレスに変換
1. 1 で求めた物理アドレスへのアクセス

- 2 に関しては前ページのようにキャッシュメモリで高速化している
- 1 に関しては TLB という CPU の領域が仮想アドレスから物理アドレスへの変換票を保存しているため高速化できる

- 疑問
  - TLB で仮想テーブル全てを補うことは無理なのか？
  - 上の説明だけだと，物理メモリにページテーブルの参照をもつ意義がわからない

---

# ページキャッシュ

- カーネルの仕組み
- ストレージデバイスへのアクセスはメモリに比べて 1000 倍以上遅いため，ストレージデバイスへのアクセスを減らすためにカーネルはページキャッシュという仕組みを持っている
- この仕組みはファイルのデータをメモリにキャッシュするもの
- プロセスがファイルのデータを読み出すと，カーネルはプロセスのメモリにファイルのデータを直接コピーするのではなく，一旦カーネルのメモリ上にあるページキャッシュという領域にコピーしてからそのデータをプロセスのメモリにコピーする
- カーネルは自身のメモリ内にページキャッシュにキャッシュした領域についての情報の管理領域を持っている

---

# バッファキャッシュ

- ディスクのデータのうちファイルデータ以外のものをキャッシュするもの
- 以下のような用途がある
  - ファイルシステムを使わずにデバイスファイルを用いてストレージデバイスに直接アクセスする時
  - ファイルのサイズやパーミッションなどのメタデータにアクセスする時

---

# directI/O

- 一度しか読み書きしないデータの場合はキャッシュする必要はない
- またプロセス自身でページキャッシュ相当の仕事をしたい場合はキャッシュが必要なくなる
- このような場合に directI/O を使うとページキャッシュを使わないようにできる
  - directI/O を使うにはファイルの open()時に O_DIRECT フラグを指定する

---

# スワップ

- ストレージデバイスの一部を一時的にメモリの代わりとして使う仕組み
- 具体的にはシステムの物理メモリが枯渇した状態でさらにメモリを獲得しようとすると，使用中の物理メモリの一部をストレージデバイスに退避して空きメモリを作る
- この領域をスワップ領域という
- ページアウト

  - 物理メモリの中でしばらく使わないとカーネルが判断したメモリをスワップ領域に退避すること

- ページイン

  - ページアウトしたページにアクセすると対応するデータを再びメモリに読み出すこと
  - ちなみにページアウトしたデータはカーネルが管理しており，ページインなどを可能にしている

- これにより OOM を避けられるが，大きな性能ダウンになる(ストレージへのアクセスは遅い！)
