---
marp: true
---

# デバイスアクセス

---

- プロセスはデバイスに直接アクセスできない
- 理由

  - 複数のプログラムが同時にデバイスを操作すると、予期せぬ動作を引き起こしてしまう
  - 本来アクセスしてはいけないデータを破壊したり盗み見したりできてしまう

---

- プロセスがデバイスに直接アクセスできない代わりにカーネルにデバイスへのアクセスを代行してもらう
- 具体的には以下のようなインターフェイスを使う
  - デバイスファイルという特殊なファイルを操作する
  - ブロックデバイスのデバイス上に構築したファイルシステムを操作する
  - ネットワークインターフェイスカード(NIC)は速度などの問題でデバイスファイルを使わずにソケットという仕組みを使う

---

# デバイスファイル

- デバイスファイルはデバイスごとに存在する
- 例えばストレージデバイスであれば/dev/sda や/dev/sdb などがデバイスファイル
- Linux ではプロセスがデバイスファイルを操作するとカーネルの中のデバイスドライバというソフトウェアがユーザーの代わりにデバイスにアクセスする
- プロセスは通常のファイルと同じよう open,write などデバイスファイルを操作できる
- デバイス固有の複雑な操作には ioctl()というシステムコールを使う
- デバイスファイルにアクセスできるのは通常 root だけ

---

- デバイスファイルには次のような情報が保存されている
- ファイルの種類
  - キャラクタデバイスまたはブロックデバイス
- デバイスのメジャー番号、マイナー番号

  - メジャー番号とマイナー番号の組み合わせが同じであれば同じデバイスに対応しており、そうでなければ別のデバイスに対応している

- デバイスファイルは通常/dev/ディレクトリに存在している

---

# キャラクタデバイス

- 読み出しと書き込みはできるが、デバイス内でアクセスする場所を変更するシーク操作はできない
- 代表的なものは以下

  - 端末
  - キーボード
  - マウス

- 例えば端末のデバイスファイルは次のように操作する
  - write()システムコール->端末にデータを出力
  - read()システムコール->端末からデータを入力

---

# ブロックデバイス

- ブロックデバイスはファイルの読み書き以外にシークができる
- 代表的なブロックデバイスは HDD や SSD などのストレージデバイス

---

# デバイスドライバ

- デバイスを直接操作するためには各デバイスに内臓されているレジスタという領域を読み書きする

  - CPU のレジスタとは異なる

---

- プロセスから見るとデバイス操作は次のようになる

1. プロセスがデバイスファイルを介してデバイスドライバに対してデバイスを操作してほしいという依頼をする
1. CPU がカーネルモードに切り替わり、デバイスドライバがレジスタを介してデバイスに要求を伝える
1. デバイスが要求に応じた処理をする
1. デバイスドライバがデバイスの処理完了を検出して結果を受け取る
1. CPU がユーザーモードに切り替わり、プロセスがデバイスドライバの処理完了を検出して結果を受け取る

---

# メモリマップト I/O(MMIO)

- 現代的なデバイスはメモリマップト I/O という仕組みによってデバイスのレジスタにアクセスする
- x86_64 アーキテクチャにおいては Linux カーネル自身の仮想アドレス空間に物理メモリをすべてマップしている
- MMIO によってデバイスを操作する場合、アドレス空間上にメモリだけではなくレジスタもマップする
