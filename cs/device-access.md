---
marp: true
---

# デバイスアクセス

---

- プロセスはデバイスに直接アクセスできない
- 理由

  - 複数のプログラムが同時にデバイスを操作すると、予期せぬ動作を引き起こしてしまう
  - 本来アクセスしてはいけないデータを破壊したり盗み見したりできてしまう

---

- プロセスがデバイスに直接アクセスできない代わりにカーネルにデバイスへのアクセスを代行してもらう
- 具体的には以下のようなインターフェイスを使う
  - デバイスファイルという特殊なファイルを操作する
  - ブロックデバイスのデバイス上に構築したファイルシステムを操作する
  - ネットワークインターフェイスカード(NIC)は速度などの問題でデバイスファイルを使わずにソケットという仕組みを使う

---

# デバイスファイル

- デバイスファイルはデバイスごとに存在する
- 例えばストレージデバイスであれば/dev/sda や/dev/sdb などがデバイスファイル
- Linux ではプロセスがデバイスファイルを操作するとカーネルの中のデバイスドライバというソフトウェアがユーザーの代わりにデバイスにアクセスする
- プロセスは通常のファイルと同じよう open,write などデバイスファイルを操作できる
- デバイス固有の複雑な操作には ioctl()というシステムコールを使う
- デバイスファイルにアクセスできるのは通常 root だけ

---

- デバイスファイルには次のような情報が保存されている
- ファイルの種類
  - キャラクタデバイスまたはブロックデバイス
- デバイスのメジャー番号、マイナー番号

  - メジャー番号とマイナー番号の組み合わせが同じであれば同じデバイスに対応しており、そうでなければ別のデバイスに対応している

- デバイスファイルは通常/dev/ディレクトリに存在している

---

# キャラクタデバイス

- 読み出しと書き込みはできるが、デバイス内でアクセスする場所を変更するシーク操作はできない
- 代表的なものは以下

  - 端末
  - キーボード
  - マウス

- 例えば端末のデバイスファイルは次のように操作する
  - write()システムコール->端末にデータを出力
  - read()システムコール->端末からデータを入力

---

# ブロックデバイス

- ブロックデバイスはファイルの読み書き以外にシークができる
- 代表的なブロックデバイスは HDD や SSD などのストレージデバイス

---

# デバイスドライバ

- デバイスを直接操作するためには各デバイスに内臓されているレジスタという領域を読み書きする

  - CPU のレジスタとは異なる

---

- プロセスから見るとデバイス操作は次のようになる

1. プロセスがデバイスファイルを介してデバイスドライバに対してデバイスを操作してほしいという依頼をする
1. CPU がカーネルモードに切り替わり、デバイスドライバがレジスタを介してデバイスに要求を伝える
1. デバイスが要求に応じた処理をする
1. デバイスドライバがデバイスの処理完了を検出して結果を受け取る
1. CPU がユーザーモードに切り替わり、プロセスがデバイスドライバの処理完了を検出して結果を受け取る

---

# メモリマップト I/O(MMIO)

- 現代的なデバイスはメモリマップト I/O という仕組みによってデバイスのレジスタにアクセスする
- x86_64 アーキテクチャにおいては Linux カーネル自身の仮想アドレス空間に物理メモリをすべてマップしている
- MMIO によってデバイスを操作する場合、アドレス空間上にメモリだけではなくレジスタもマップする

---

# ポーリング

- ポーリングはデバイスドライバが能動的にデバイスの処理が完了したかどうかを確認 する
- デバイスはデバイスドライバから依頼された処理が完了すると，自身の処理管理通知用レジスタの値を変化させる
- デバイスドライバはその値を定期的に読み出すことによって処理の完了を検出する
- 最も単純なポーリングの場合，デバイスドライバはデバイスに処理を依頼してから処理が完了するまで，レジスタを読み出し続ける
- ただしこのやり方だと，CPU がデバイスの処理完了を待つ間(ポーリングの間)，他の処理を行うことができない
- この問題を避けるためにポーリングはひたすらデバイスの処理完了を待ち続けるのではなく，所定の間隔でレジスタの値を確認するという方法もある

---

# 割り込み

- 割り込みは次のような流れでデバイスの完了を検出する

1. デバイスドライバがデバイスに処理を依頼する

- この後 CPU は別の処理を動かせる

1. デバイスが処理を完了すると，割り込みという仕組みによって CPU に通知を行う
1. CPU はあらかじめデバイスドライバが割り込みコントローラというハードウェアに登録しておいた割り込みハンドラという処理を呼び出す
1. 割り込みハンドラがデバイスの処理結果を受け取る

- デバイス処理の完了を検出するためにはポーリングよりも割り込みを使うことが多い

---

# あえてポーリングを使う場合

- デバイスの処理が高速でかつ処理が高頻度な場合は例外的にポーリングを使うことがある
- 割り込みハンドラの呼び出しにも一定のオーバーヘッドがかかり，処理が高速な場合はハンドラを呼び出している最中に次の割り込みが発生して，処理が追いつかなかくなることがあるため
- 他にも割り込み頻度が多くなるとポーリングに切り替わるデバイスドライバもある
