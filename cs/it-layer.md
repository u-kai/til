# IT 技術における層の考え方について

---

# コンピュータの実際(電気信号による物理機器同士の連携)

- IC などの物理的な機器が電気信号を送り合っている
- つまりコンピュータとは実際には機器と電気信号(OnOff の連続)しかない
- 電気の OnOff を 1,0 に紐づけることでデータや命令,計算を表現している

---

# 0,1 による電気信号の抽象化

- 計算には 0,1 の集合を使った論理演算や四則演算を行っているが，実際の物理構成は上でも述べたとおり，電気信号が飛び交っているだけ
- もちろん計算の結果のとおりに電気信号が飛び交うのだけれども，0，1 の計算とコンピュータの物理的な挙動は別の概念
- 0,1 の計算は実際に物理で起きていることの仮想的で抽象的な概念
- 抽象化によって人間が解釈できる層が一つ増えたことになる
- 正直 0,1 はわかりにくいが，そうがひとつ増えたことにより，電気信号のやり取りから 0,1 を用いた計算，といったように人間が若干理解しやすくなった
- 抽象化して層を増やすことは問題をわかりやすくするために IT 技術がよくやること
- ただし，これだけだとまだまだわかりにくいと思うのでさらに見ていく

---

# アセンブリ言語による 0,1 命令の抽象化

- アセンブリ言語は CPU が実行できる命令と 1 対 1 に紐づく人間がわかりやすい言語

```asm
; movはmoveの意味でCPUが実行できる最小単位の命令の一つ.
; ここではCPUのeaxレジスタに0xa(10進数だと10)というデータを格納している物
mov eax 0xa

```

- これにより，0,1 だけで命令を書く必要がなくなり，より人間が理解しやすい言葉で CPU に命令を出せるようになった
- これも 0,1 の組み合わせで形づけられていた命令を人間がわかりやすいインターフェイスに抽象化して,つまり層を増やして 0,1 がわかりにくいという問題を解決している

---

# プログラミング言語によるアセンブリ言語や OS,CPU の抽象化

- アセンブリ言語の特徴として，CPU が実行できる命令と 1 対 1 に紐づいていることがある
- つまり，CPU が変われば命令の仕方も変わるため，アセンブリ言語も CPU の種類(アーキテクチャ)ごとに存在しなければいけない
- また，実際のプログラムでは繰り返しや，条件分岐，入出力などの多くの共通した処理があるが，それらを CPU の命令可能な単位(つまりアセンブリ言語の一行)でいちいち書いていると相当な数の CPU の命令の組み合わせになってしまい，たくさんのアセンブリ言語を書かなくてはいけない
- そこでプログラミング言語が誕生した
- プログラミング言語は CPU が実行できる命令とプログラミングの記述が必ずしも 1 対 1 で紐づいているわけではなく，より直感的(そして抽象的に)記述することができるようになった
- 以下はアセンブリと Python での記述の違いで，どちらも Hello, World! を出力するだけのもの
  - どちらもほとんど同じような機械語に最終的には変換され，実行される

```asm
section .data
    hello_message db 'Hello, World!', 0
    hello_len equ $ - hello_message

section .text
    global _start

_start:
    ; writeシステムコールを使用してメッセージを出力
    ; int write(int fd, const void *buf, size_t count);
    mov eax, 4        ; writeのシステムコール番号
    mov ebx, 1        ; fd (stdout)
    mov ecx, hello_message ; buf (メッセージのアドレス)
    mov edx, hello_len ; count (メッセージの長さ)
    int 0x80          ; システムコールを実行

    ; exitシステムコールでプログラムを終了
    ; void _exit(int status);
    mov eax, 1        ; exitのシステムコール番号
    xor ebx, ebx      ; status (0)
    int 0x80          ; システムコールを実行

```

```python
print("Hello, World!")
```

- アセンブラの方が冗長で，意味も分かりにくい
- Python の方は簡潔で直感的にも分かりやすい

- また，CPU と一対一で紐づいているわけではないので，異なる CPU や OS に対して，同じプログラムの記述でほとんどの処理を実行することができる

  - これはプログラミング言語を機械語に翻訳するコンパイラが対象の CPU や OS の機械語へ翻訳をしてくれるからで，プログラミング言語によっては，特定の CPU や OS へのコンパイルが実行できないケースもある
  - つまりプログラミング言語の下にはコンパイラの層があると考えることもできる

-

まとめると，プログラミング言語による抽象化によって，

1. 分かりやすさの向上(複雑性の緩和)
1. 人間の作業量減少(作業量の削減)
1. CPU や OS などの違いを吸収(環境差の吸収)

を行ってくれている

また，抽象化の考え方としてコンパイラをプログラミング言語の下の層として捉えるとコンパイラによる，プログラミング → 機械語への変換を抽象化することによって

1. 責務の分解
   - プログラミング言語は人間に分かりやすいインターフェイスを提供する責務
   - コンパイラは，一つのプログラミング言語を機械語に変換する責務

を行ってくれている

責務の分解をすることで，機能変更などをする際の影響範囲を狭めることができる

- 例えば，新しい種類の CPU が登場した際，アセンブリ言語だと，アセンブリ言語から機械語への変換を責務とする層がないため，アセンブリ言語ごと最初から開発し直す必要がある
- しかし，プログラミング言語の場合は，プログラムの記述と，それを変換する責務が分離して，独立しているので，新しい種類の CPU が登場しても変更するべきなのは，コンパイラだけでよくなる
- このように責務を分離して層として追加することで，変更に強くなる

- これらは多くの抽象化の目的の一つ
- 最後に，この説明の流れだと，アセンブリ言語の層の上にプログラミング言語あるように感じるが，概念としてはあっているが，実際に挙動としては，プログラミング言語がコンパイルされてアセンブリ言語が出力されることは絶対ではなく，実際はプログラミング言語がコンパイルされると，アセンブリ言語を経由せずに直接機械語に変換されることがほとんど
- 現代でアセンブリ言語をプロダクトに積極的に組み込むことはほとんどなく，ほとんど全ての新規プロダクトはプログラミング言語で書かれている
- アセンブリ言語の利点は CPU の命令と直接一対一で紐づいているため，プログラムの最適化はプログラミング言語よりも理論的には狙える
  - ただしそれは，世界のすごい人たちが開発したプログラミング言語のコンパイラよりもうまくプログラムを最適化できればの話で，そうそう無理
- もう一つの利点は CPU と一対一で紐づいているため，CPU がどのように命令を実行するのかの勉強になる

---

# OS による基本的な操作抽象化

- プログラミング言語の上の層に乗るような抽象概念ではないが，OS も様々な抽象化を行っている
- OS がない場合は，複数のプロセスを実行するためのメモリ管理や，どのプロセスを CPU に実行させるかのスケジューリング，様々なハードウェアへのアクセスなど，様々なことを利用者が行わなければいけなくなる
- さらにそのほとんどが誰もが必要とするような共通化された処理となっており，繰り返しが生じる
- また，正確に制御を行わないと，セキュリティ的リスクも生じる
- ここで OS がそれらの操作を抽象化して，理解しやすいインターフェイスを提供してくれている
- そのおかげで，利用者上記のようなことが実際に起きているにも関わらず，それを気にせずに，OS の機能の呼び出し方さえ知っていればそれを利用することができる
- このようにやるべきことを OS が隠蔽してくれているのである
- 隠蔽も抽象化の一つの目的であり，強力な概念
- ソフトウェアは抽象化をして詳細ごとを隠蔽して，利用側に気にせずとも良いようにするもの
  - というかそうなっていないソフトウェアはよくない

---

# アプリケーションによるプログラム，OS の抽象化

- ここでいうアプリケーションとは Excel や Teams，LINE や Instagram などのユーザーが直接利用する俗に言うアプリを指す
- アプリケーションを利用する利用者はプログラムの詳細や，OS が行っている仕事を知っていなくても利用できる
  - 特に OS の仕事であるプロセスの起動やプロセスのスケジュールは気にしなくても恩恵を受けている
    - アイコンを押すだけでプロセスが起動できるのは，アイコンを押されたら起動するようプログラムされていることや，OS のプロセス生成の処理を呼び出して利用しているから
    - CPU のコア数以上のプロセスをあたかも同時に利用できているのは OS のおかげ
- 全てのアプリケーションは元を辿ればプログラミング言語やアセンブリ言語の集合であり，それがコンパイルされて実行可能な実行ファイルになっている
- ただし，どの言語でどのような記述で書かれているかと言う詳細ごとを一切わからずともアプリケーションを利用できるのはアプリケーションがプログラムや OS の処理を抽象化して隠蔽しているから
- このようにアプリケーションという層を作ることでアプリケーションを実際に利用する人からはプログラムや OS，さらに言えば機械語，ハードウェアまでの詳細ごとを隠蔽することができる
- また，アプリケーションの開発者からすると，プログラムや OS という機械語やハードウェアといった分かりにくい層を気にすることなくアプリケーションを開発できるため，この場合はプログラムや OS の抽象化の恩恵を受けていることになる

---

# IT 技術は多くのところで抽象化，層の追加を行い様々な問題を解決している

- 上記以外にも多くのところで抽象化，層の追加を行い，様々問題を解決している
