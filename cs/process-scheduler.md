---
marp: true
---

# プロセススケジューラ

---

- システムに存在するプロセスはほとんどスリープ状態
  - ではシステムに複数の実行可能プロセスが存在する場合，カーネルはどのように各プロセスを CPU 上で実行させるのか？

---

# 前提知識: 経過時間と使用時間

- 経過時間

  - プロセスが開始してから終了するまでの経過時間

- 使用時間
  - プロセスが 実際に論理 CPU を使用していた時間

```python
for _ in range(100000000):
    pass
```

```shell
time python load.py
# 3.43s user 0.03s system 91% cpu 3.782 total
time sleep 3
# 0.00s user 0.00s system 0% cpu 3.011 total
```

---

# 1 つの CPU で動かせるのは？

- 1 つの CPU で動かせるプロセスは 1 つというが本当かどうか？
- load.py を 1 つの CPU で複数実行すると,プロセス数だけ時間がかかる
- 逆に load.py を複数の CPU で実行すると,プロセス数が CPU の数と同じであれば,1 つのプロセスの実行時間と同じ時間で終わる

- 上記から 1 つの CPU では 1 つのプロセスしか実行できない
  - 逐次的にプロセスを切り替えて CPU で実行している

---

# タイムスライス

- 1 つの論理 CPU 上で複数の処理が動作している場合はそれぞれの処理が数ミリ単位のタイムスライスで CPU を交互に使う
- タイムスライスはプロセス数に応じて可変になっており，プロセス数が増えてもプロセスを待たせることを回避している

---

# コンテキストスイッチ

- 論理 CPU 上で動作するプロセスが切り替わることをコンテキストスイッチという
- コンテキストスイッチはプロセスがいかなるコードを実行中であろうとも，タイムスライスが切れると容赦無く発生する

---

# プログラムの並列実行の重要性

- プログラムの並列実行の重要性は年々高まっている

  - CPU の性能向上のアプローチが変わってきているから

- 昔は論理 CPU ごとの性能(シングルスレッド性能)の劇的な向上が期待できたため，並列実行をせずとも勝手に高速化されていた
- しかし，シングルスレッド性能の向上が難しくなってきており，その代わりに CPU コアの数の増加によって性能を向上させてきた
- そのため，並列実行を行わないと CPU の性能を引き出せない
