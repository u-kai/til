# TCP

## シーケンス番号

- コネクションが確立された後，両端はシーケンス番号，確認応答番号(相手のシーケンス番号)を保持している
- パケットを送信する時，自分が保持しているシーケンス番号，確認応答番号をヘッダに格納する
- その後，送信側は自分が保持しているシーケンス番号にデータのバイト数を加算する
- なお，コネクション確立フェーズの SYN フラグ，コネクション切断フェーズの FIN フラグも 1 バイト分のデータとみなしてシーケンス番号に加算される
  - シーケンス番号，確認応答番号ともに 32 ビットちが巡回的に使用される

## 確認応答番号

- 次に受信すべきシーケンス番号
- 送信側は返された確認応答番号と次に送るシーケンス番号が同じであることを確認すれば正常に通信が行われているのかが確認できる

## データオフセット

- TCP セグメント内のデータ開始位置
- 事実上ヘッダ長と同じ意味で，オプションがない場合，TCP ヘッダは 20 バイトなので 0x05 が格納される

## 予約

- 将来のために予約されており，0 が格納される

## コントロールビット

- 以下三つのフラグは IP ネットワークで明示的輻輳制御(ECN:Explicit Congestion Notification)を実装する目的で追加された
  - NS(Nonce Sum)
  - CWR(Congestion Window Reduced)
  - ECE(ECN-Echo)

## ウィンドウプローブ

- ウィンドウ更新パケットが消失するリスクに備えて送信側ホストは定期的にウィンドウプローブと呼ばれる 1 バイトのデータを格納したパケットを送信して確認応答パケットの返信を促す
- その確認応答パケットのウィンドウサイズが 0 より大きな値に更新されていれば送信を再開する

## TIC のシーケンス

- 送信されたらまずは送信データの長さが 0 の ACK を送るっぽい
- その後にデータを返す模様
- FIN／ACK に対してもまずは ACK を返してた
  - その後すかさず FIN/ACK をこっちも返していた
  - 最後にその応答として ACK を返して終わり

## TCP のソケットについて

- 宛先の IP,Port,自分の IP，Port で一意に決まるっぽい
- これがコネクションをはるってことかな？
