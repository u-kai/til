## Pod のネットワーク

- 1 つの Pod 内には複数のコンテナを内包できるが，同じ Pod 内であればすべてのコンテナは同じ IP アドレスが割り当てられる
- そのため同一の Pod のコンテナへ通信を行う場合には localhost 宛に通信を行い，ある Pod のコンテナから別の Pod のコンテナへ通信を行う場合は Pod の IP アドレス宛に通信を行う

## K8s クラスタ内部のネットワーク

- K8s クラスタはクラスタを構築すると，ノードに Pod のための内部ネットワークを自動的に構成する
- 内部ネットワークの構成は使用する CNI の実装によるが，基本的にはノードごとに異なるネットワークセグメントを構成し，さらに，ノード間のトラフィックは VXLAN や L2 Routing などの技術を利用して転送することによって互いに通信できるように構成する
- ノードごとのネットワークセグメントは k8s クラスタ全体に割り当てられたネットワークセグメントを自動的に分割して割り当てるため利用者が特別に意識する必要ない
- このように内部ネットワークが自動構成されているため，Pod は Service を利用せずとも Pod 間通信を行うことが可能
- しかし Service を利用することによって大きなメリットがある
- Pod 宛トラフィックのロードバランシング
  - service の targetPort の指定には Pod のポート定義に名前を付与しておくと名前を用いた参照が可能

## サービスディスカバリとクラスタ内 DNS

- k8s では，サービスディスカバリの機能を Service が提供している
- サービスディスカバリとは特定の条件の対象となるメンバを列挙したり，名前からエンドポイントを判別する機能
- k8s の文脈では Service に属する Pod を列挙したり，Service の名前からエンドポイントの情報を返すことを指している
- サービスディスカバリの方法は主に 3 種類で，DNS を利用したサービスディスカバリでは，クラスタに内蔵している DNS サーバへ自動的に登録される Service エンドポイント情報を利用している
  - 環境変数を利用したサービスディスカバリ
  - DNS A レコードを利用したサービスディスカバリ
  - DNS SRV レコードを利用したサービスディスカバリ

## DNS A レコードを利用したサービスディスカバリ

- 実際に登録されている正式な FQDN は Service 名.Namespace 名.svc.cluster.local
- この FQDN には Service が衝突しないように，Namespace などが含まれているが，コンテナ内の/etc/reslov.conf に記述があるため sample-clusterip.default や sample-clusterip だけで名前解決できるようになっている
- 同一 Namespace である場合には sample-clusterip のように Service 名だけで名前解決できるが異なる Namespace の場合には sample-clusterip.default のように Namespace 名をつけて名前解決を行う必要がある

## DNS SRV レコードを利用したサービスディスカバリ

- SRV レコードを使って Service のエンドポイントも確認できる
- SRV レコードは Port 名と Protocol を利用することでサービスを提供している Port 番号を含めたエンドポイントを DNS で解決する仕組み
- \_Service の Port 名.\_Protocol.Service 名.Namespace 名.svc.cluster.loca
