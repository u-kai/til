# プロセスの生成

- 新しくプロセスを生成する目的は次の２つ

  - 同じプログラムの処理を複数のプロセスに分けて処理する
    - Web サーバによる複数のリクエストの受付け
    - fork 関数のみ
  - 別のプログラムを生成する
    - bash から各種プログラムの新規作成
    - fork 関数と execve 関数を利用する

- これらを実現するために Linux では fork()関数と execve()関数を使う
- 内部的にはそれぞれ clone(),execve()というシステムコールを呼び出す

## fork 関数手順

- 親プロセスが fork()を呼ぶ
- 子プロセス用メモリ領域を確保してそこに親プロセスのメモリをコピーする
- 親プロセスと子プロセスは両方とも fork()関数から復帰する:

  - 親プロセスと子プロセス t は fork 関数の戻り値が異なるため処理を分岐できる

- 実際には CopyOnWrite で子メモリを生成しているため fork は安価

## 別のプログラムを起動する execve()関数

- fork 関数によってプロセスのコピーを作ったあとは子プロセス上で execve()関数を発行する
- これによって子プロセスは別のプログラムに置き換えられる

## execve()の流れ

- execve()関数を呼び出す
- execve()関数の引数で指定した実行ファイルからプログラムを読みだして、メモリ上に配置する(メモリマップ)ために必要な情報を読みだす
- 現状のプロセスのメモリを新しいプロセスのデータで上書きする
- プロセスを新しいプロセスの最初に実行すべき命令から実行開始する

- つまりプロセスをまったく別のプロセスに置き換えている
- execve()関数の実現のために実行ファイルはプログラムのコードやデータに加えて次のようなプログラムの起動に必要なデータを保持している

  - コード領域のファイル上オフセット、サイズ、およびメモリマップ開始アドレス
  - データ利用域についての上記と同じ情報
  - 最初に実行する命令のメモリアドレス(エントリポイント)

- Linux の実行ファイルは通常 ELF(Executable and Linking Format)というフォーマットになっている
- ELF の各種情報は readelf というコマンドによって得られる

```
readelf -h pause
```

- Entry point address という行の値がこのプログラムのエントリポイント
- コードとデータのファイル内のオフセット、サイズ、開始アドレスは readlef -S コマンドによって得られる
- 実行ファイルは複数の領域に分けられており、それぞれをセクションと呼ぶ
