# SSL(Secure Sockets Layer)/TLS(Transport Layer Security)

- ssl はトランスポート層で TCP を用いるアプリケーション通信のセキュリティを確保するプロトコル
- TLS が提供するセキュリティ機能は以下
  - 主体認証
    - 通常は電子署名を用いる
  - メッセージ認証
    - パケットごとにそのペイロードのメッセージダイジェストを付与する
    - これを MAC(Message Authentication Code)という
  - 暗号化
    - パケットごとにそのペイロードと MAC の両者を暗号化する
- メッセージ認証と暗号化に利用される鍵はセッションごとに生成される共通鍵

- サーバ証明書のサブジェクト欄の FQDN とアクセスしている FQDN が一致していない場合，警告が出る
  - 悪意のあるサーバが，他の正規のサーバ証明書を送りつけてきたときに検知できるようになる
  - 電子証明書は公開されており，誰もが入手できる

## TLS 通信の種類と手順

- TLS の仕様は 4 種類の通信を規定している

  - それらはプロトコルと呼ばれている

- アプリケーションデータプロトコル
- ハンドシェークプロトコル
  - TLS セッションを確立するための通信
  - アプリケーションデータプロトコルの通信に先立って実施され，通信相手の主体認証と共通鍵の交換が行われる
  - ここで得られた共通鍵をアプリケーション通信の暗号化に用いている
- Change Cipher Spec プロトコル
  - TLS1.2 まで使用されており，TLS1.3 では後方互換性のために残されている
  - これ以降のパケットは共通鍵によって暗号化されていることを通知する役割を担っている
  - クライアント，サーバがそれぞれこのメッセージを通知することが規定されている
- アラートプロトコル

  - 警告やエラーを相手に伝えるための通信

- 大まかな流れは以下
  - セッションの確立(ハンドシェークプロトコル)
  - アプリケーション層の暗号化通信(アプリケーションデータプロトコル)

## TLS1.2 のシーケンス

- TLS の仕様上複数のハンドシェークプロトコルのメッセージを 1 個のプロトコルに格納して送信することができる
- 最初にクライアントとサーバの双方はセッション確立時とデータ通信時に用いる暗号化スイートを決定する
- 暗号化スイートの内訳は以下の 4 種類

  - 鍵交換
    - 共通鍵の交換に使われる
    - ハンドシェークプロトコルを使う
    - RSA,DHE,ECDHE がある
  - 署名
    - 主体認証
    - ハンドシェーク
    - RSA ,ECDHE
  - 暗号化
    - ペイロードの暗号化
    - アプリケーションデータ
    - AES_256_CBC,RC4_128
  - ハッシュ関数
    - ペイロードのメッセージ認証，鍵生成のための疑似乱数関数の元となるハッシュアルゴリズム
    - アプリケーションデータ
    - SHA_256

- 暗号化スイートを決定するために ClientHello によって通知する
  - ClientHello では暗号スイートの候補，クライアント側の乱数などを提供
- ServerHello では暗号スイートの選定(一組),サーバ側の乱数などを提供

- サーバ証明書の認証では，クライアントは以下を検証する
  - サーバ証明書が信頼できる CA から発行されていること
  - サーバ証明書が発行元 CA により署名されていること
  - サーバ証明書を送信したサーバが,電子証明書が格納されている公開鍵の所有者であること
    - (ブラウザの場合，アクセス先サーバの FQDN が電子証明書のサブジェクトと一致していることを確認する)
- 認証に成功したら，証明書からサーバ公開鍵を取得する
- その後クライアントは以下を送信する

  - サーバの公開鍵で暗号化されたプリマスターシックレット

- クライアント証明書のサブジェクトは通常，利用者の ID や名称などが記載されている
- サーバはまずクライアント証明書が信頼できる CA から発行されていること，クライアント証明書が発行元 CA により署名されていることを検証する
- 次に証明書に記載されたクライアントの公開鍵を使ってクライアント署名を検証する
- なお，クライアント証明書を発行した CA がプライベート CA である場合，プライベート CA のルート証明書をサーバにインストールしておき，プライベート CA が信頼に値する元のしておく
- クライアントとサーバは互いに Finished メッセージを交換しており，これを交換することで一連のハンドシェークプロトコルのやり取りが攻撃者によって改竄されてイアにか互いに確認することができる

## TLS1.3 のシーケンス

- 1.2 からの変更点は以下

  - ハンドシェークプロトコル

    - TLS1.3 では ServerHello メッセージの直後から共通鍵による暗号化が開始される
    - セッション再開のシーケンスを簡素化している
      - セッション再開に備えてサーバが動的に生成した PSK(Pre-Shared Ke)を暗号化してクライアントに送信し，両者で共有しておく
      - PSK の中にはセッション再開に必要な情報が格納されているのですぐに暗号化通信を再開できる

  - AEAD(Authenticated Encryption with Associated Data)暗号利用モードの必須化
    - RC4,AEC-CVC などが廃止された
  - Forward Security の確保
    - 1.2 では静的な RSA 鍵交換方式,(クライアントがプリマスターシークレットを生成し，電子証明書のサーバー公開鍵でこれを暗号化してサーバに送信する方法)を採用していた
    - 1.3 では RSA 鍵交換方式が廃止された

1. Client Hello

   - 暗号スイートを送ると同時に，候補に挙げた鍵交換アルゴリズムから一つ選び，当該鍵交換アルゴリズムにより，公開鍵と秘密鍵のペアを生成した上でその公開鍵をサーバに伝える
     - サーバーがそのアルゴリズムに合意するかわからないが，合意した場合，ハンドシェークプロトコルのやりとりを減らすことができる
   - 鍵交換，署名，暗号化，ハッシュ関数の候補，鍵交換の公開鍵，クライアント側の乱数など

1. Server Hello
   - Client Hello を受けてサーバは鍵交換，署名，暗号化，ハッシュ関数を一つ選定してクライアントに通知する
   - クライアントが選んだ鍵交換アルゴリズムにサーバが合意した場合，当該鍵交換方法の公開鍵／秘密鍵ペアを生成した上でその公開鍵をクライアントに伝える
   - 鍵交換，署名，暗号化，ハッシュ関数の候補，鍵交換の公開鍵，サーバ側の乱数など
   - サーバは Server Hello メッセージが終わった時点で，暗号化のアルゴリズムも選定しており，暗号鍵の元となる情報を全て手元に持っている
   - そのため，サーバはこれ以降の通信もすべて暗号化する
   - サーバ送信するパケットには暗号化されていない ServerHello メッセージと暗号化された後続のメッセージが一緒に格納されている
1. Encrypted Extensions

   - 他に決定したいパラメータをここで送信する
   - このデータは暗号化されている

1. Certificate Request
1. Certificate
   - サーバ証明書を送信する
1. Certificate Verify
   - サーバの秘密鍵で作成した署名を送信する
1. Finished
   - これまでにやり取りされたハンドシェークメッセージが改竄されていないことの確認
1. Certificate
   - クライアント証明書の送信
1. Certificate Verify
   - クライアント署名の送信
1. Finished
   - これまでにやり取りされたハンドシェークメッセージが改竄されていないことの確認

- 暗号スイートは暗号化とハッシュ関数の 2 種類のみ

  - 鍵交換と署名のアルゴリズムは TLS1.3 の暗号スイートに含まれなくなったが別の方法で決定される

- Finished メッセージにはメッセージ認証コードが格納されている
  - これまでにやり取りしたメッセージのデータ，マスターシークレット，などを組み合わせた文字列をハッシュ化したもの
  - 攻撃者はクライアントとサーバの間に割り込んで改竄しても，その改ざんに合わせてメッセージ認証コードを生成することはできない
  - なぜならプリマスターシークレットはサーバの公開鍵で暗号化されているため，攻撃者はプリマスターシークレットを知ることができないため
  - クライアントとサーバはメッセージ認証コードを交換することで，これまでの一連のやり取りが攻撃者によって改竄されていないかを確認することができる
