# 混乱した代理問題

- SSO ゲートウェイのようなものを使い，システム全体で認証させた後に，追加の操作を行う時，ユーザまたは上流のシステムが下流のシステムを騙して本来実行すべきではないことを実行させると発生する
- 要は，認証を代理して一括でやり，かつその認証によって行われた認可が過剰になっていると，意図しない脆弱性が生まれる

## 一元的な上流での認可

- 混乱した代理問題を回避する一つの選択肢
- システムでリクエストを受理したらすぐに必要なすべての認可を行うこと
- この形式の上流での認可は事実上ある種の暗黙の信頼を受け入れていることを意味する
  - ゼロトラストとは対照的
- また上流のサービス(SSO ゲートウェイなど)が下流マイクロサービスの機能，その機能へのアクセスを制御する方法を知っている必要がある
- これは独立してデプロイ可能に反する
- そのため呼び出しを認可するかどうかの判断はリクエストされた機能を持つマイクロサービスに任せるべき
  - これによりマイクロサービスはより自己完結型になり，必要に応じてゼロトラストを実装する選択肢も得られる

## 認可の分散化

- マイクロサービス環境における一元的な認可の課題を考えると，このロジックを下流マイクロサービスに任せたいと考える
- ただし，各サービスが認可するべきか判断できる情報を持っている必要がある
  - どのようにしてその情報を渡すのかが問題になる
  - ユーザー名などをヘッダに入れる方法があるが，悪意あるものが他の値を挿入する可能性もある
  - 理想的にはリクエストが本当に認証されたユーザのために行われるようにしてそのユーザに関する追加情報を伝えられるようにする方法が必要
  - 以前は SAML によりこれを達成していたが，現在はより安易な JWT が使われている

## JWT

- JWT を使用すると個人に関する複数のクレームを文字列に格納して渡すことができる
- トークンの構造が操作されていないことを保証するためにトークンに署名することができる
- JWT はデータが改竄されていないことを補償することが重要な一般的な情報交換にも使用できる
- JWT は認可を支援するための情報を送信するために最も一般的に利用される
- JWT は一度署名されると，様々なプロトコルで簡単に渡すことができる
- またトークンはオプションで一定期間がすぎたら有効期限切れになるように構成できる

## マイクロサービスアーキテクチャで JWT トークンを使う一般的な方法

- ユーザがログインし，認証されると，ログインセッションを表すなんらかのトークン(OAuth トークンなど)が作成され，それがクライアントデバイスに保存される
- そのクライアントデバイスからのその後のリクエストはゲートウェイに送られ，そのリクエストの間だけ有効な JWT トークンが生成される
- 下流マイクロサービスにはこの JWT トークンが渡される
- 下流マイクロサービスはどのような種類の認可が適切かを判断するために，トークンを検証し，ペイロードからクレームを抽出することができる
- 上のアプローチの応用として，ユーザが最初にシステムで自身を認証した時に JWT トークンを生成し，その JWT トークンをクライアントデバイスに保存する方法がある
- ただし，このようなトークンはログインセッションの間では有効でなければならいことを考慮する
  - セキュリティ的には最小限にしたいところ
- そのため，リクエストごとに JWT トークンを生成するのが最も一般的な解決方法
- またゲートウェイでなんらかのトークン交換を行うと，クライアントデバイスとの通信を含む認証フローを全く変更なしに JWT トークンの使用をより簡単に採用することができる

## JWT トークンの課題

- 第一にキーの問題がある
- 署名された JWT トークンの場合，署名を検証するために JWT トークンの受信者は別途通信する必要のある情報を必要とする
- だいたいが公開鍵だが，マイクロサービスがどのように公開鍵を取得するのかが問題,また，公開鍵を変更する場合どうすればいいのか
- Vault はここら辺の問題も解決している

  - 公開鍵をハードコーディングすることもできるが，公開鍵が変更された時に問題になるためできるだけしない方がいい

- 第二に処理時間が長い場合，トークンの有効期限を正しく扱うことが困難になる問題がある
- 最後にトークンに入れるべき情報が多くなり，トークンのサイズ自体が問題になることがある
