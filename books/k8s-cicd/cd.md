# CD/GitOps

- CIOps のデメリット
  - CI ツールにデプロイまでの権限を付与する必要がある
  - デプロイまでの道が一つなので、デプロイ戦略やロールバックが難しい
    - デプロイでミスったら CI まで戻る必要がある
    - さまざまな環境へのデプロイや BlueGreen などを CI と一緒にやることは難しい
- CD は CD で CI とは全く違う関心ごとがあるはず
- GitOps の前提条件

  - デプロイメント対象となるマニフェストを全てマニフェストリポジトリ上で管理する
  - マニフェストの変更は Merge Request を通じてレビューを行う
  - マニフェストリポジトリへの変更が行われた場合は動的にクラスタに反映する
  - マニフェストリポジトリの内容とクラスタとの違いがある場合は、動的にクラスタをリポジトリの状態と一致させる

- ArgoCD の Application はアプリケーションライフサイクルが異なるサービスごとに設定することがおすすめ
  - DDD のサブドメインとか

## Kustomize の概要

- チームや企業全体で GitOps を取り入れる際はデプロイメントの環境差異を補うツールを慎重に選択しないといけない

  - なぜなら環境差異を補うツールの洗濯はマニフェスト定義やそれを格納するディレクトリ構成そのものに影響を及ぼすため
  - 例えば Helm を利用した場合は環境差異を考慮した Helm Chart を用意するところから始まる
  - デプロイ用のマニフェスト展開方法がチームごとに異なるとその方法やツールの学習コストも高くなる
  - こうした状況を避けるためにもなるべくデプロイメントツールは統一することがおすすめ

- ArgoCD は kubectl や Kustomize,Helm などを内部利用してデプロイ可能でどのツールを利用するかは Application ごとに指定できる
- Kustomize の思想は Base から上書き
- Helm の思想は Template

  - Helm Chart は自由度が高い反面、テンプレートの記述が複雑化し、俗人化することがある
  - 特定のベンダーやプロジェクトがプロダクトをパッケージ化し、継続的に配布すると言った用途には適しているが、個別のアプリケーションに利用するとパッケージそのものの構成が属人化しがち

- kustomization.yaml に環境ごとに異なる値を入れていく

### patchesStrategicMerge フィールド

- バッチ用のマニフェストをベット用意してリソースを上書きする仕組み
- kustomization.yaml に定義してきた設定では補えない環境差分について利用する
- Kustomize ではコンテナイメージ名やレプリカ数、名前などよく利用される環境差分の定義オプションが用意されているが、K8s のリソース全てのフィールドは対応できない
- patchesStrategicMerge は変更後に期待するパッチ用のマニフェストをあらかじめ用意しておき、それらと元のマニフェストとの差分を上書き、または追加する機能
- パッチ用のマニフェストは差分箇所だけを指定する
  - その際はオブジェクトの名前やコンテナ名など、変更対象が特定できる値を定義しておくと対応する箇所のみを上書きしてくれる

## 機密情報の取り扱い

### GitOps 管理外の Secret

- コマンドなど、手動で設定する
- 複数アプリケーションの Secret を複数のデプロイメント環境で管理するのは容易ではない
- 権限管理が複雑になってしまうので実用的でない

### 外部 Secret 同期システム

- あらかじめ機密情報をおいた外部ストレージシステムから動的に Secret を生成する
- この方法ではコンテナの起動時に k8s の機能を利用して環境変数や Secret ボリュームのマウントを行うのではなく、外部のストレージに上がっている機密情報をコンテナ実行時に API を介して動的に取得する
- この方法を利用することで、アプリケーションごとに Secret を管理しなければいけない開発者の役割と k8s クラスタ全体で機密情報を運用管理しなければいけない運用者の役割が分離され、より安全な運用プロセスを築き上げることができる
- 注意点は、外部のストレージシステムに機密情報の保管と取得を委任するため、k8s の Secrets を直接使用しない場合もある
  - そうなるとプロダクトによってはこれまで Secret を使って行っていた環境変数設定やボリュームないのファイルとしてマウントすると言った k8s 固有の機能が利用できなくなる可能性もある

### External Secrets の概要

- External Secrets は外部のストレージシステム上に保存された情報を取得し、動的に k8s の Secrets を生成するツール
- 外部ストレージシステムとして多くのクラウドベンダーの Secret サービスに対応しているので、さまざまな環境に対して共通の運用で機密情報が管理できることが特徴

## マニフェストのデプロイ

### 継続的デリバリと継続的デプロイメント

- アプリケーション開発者とそのアプリケーションリリースを行う運用者が異なることが多い
- リリースゲートは承認プロセス
- 継続的デリバリはリリースゲートがあるもので、継続的デプロイメントは全てを自動化してリリースゲートすら設けない
- リリースゲートを儲けるということはリリースやデプロイメントにおける更新権限をかえることとも言える

### 継続的デリバリにおける更新権限

- 継続的デリバリを主体とした GitOps のあり方とは、マニフェストリポジトリのコミット作業を人手を介して行う作業のこと
- 開発者がアプリケーションコードを編集し、アプリケーションリポジトリのを更新
- それをトリガーに CI が回って、マニフェストリポジトリの main ブランチが更新される
- マニフェストリポジトリの main ブランチを使って検証環境ににデプロイ
- リリースレビュー
- 運用が stg ブランチにマージしてステージ環境にリリース
- リリースレビュー
- 運用が prod ブランチにマージして本番環境にリリース

- アプリケーションソースコードリポジトリの更新は開発者が topic ブランチに
- アプリケーションコードレビューアが main ブランチへの更新権限を
- マニフェストの main ブランチは Tekton Pipelines に
- マニフェストの main から stg,prod ブランチへはリリースレビューあが更新権限を持つ
- 疑問
  - 開発者がデプロイしたいリソースが充足している状態であれば、これでも成り立つと思うが、新たに作成したいリソースが出てきて、マニフェストに対して追加をしなくてはいけない場合はどうすれば良いのか？
  - マニフェストの開発？は誰がやるのか？

#継続的デリバリのリリース

## リリースの自動化

- コンテナを利用していない環境においても個別の作業を自動化することは可能だったが k8s 環境では各ツールの連携によってリリース影響そのものを動的に判断できる範囲が格段に上がっている
- これまで人が目視確認し、作業ごとに判断していたリリース作業の多くはツールの判断に任せることができる
- リリース作業で重要なことは、新しいアプリケーションのバージョンに切り替えるタイミングで、利用者が期待するサービスレベルの範囲に基づいて変更作業を行うこと
- Argo Rollout は Deployment よりもできること多そうだけど、Argo Rollout も ReplicaSet を管理するので Deployment と同時に使うと変なことになる可能性がある
  - Argo Rollouts Controller によって管理されている
  - Argo Rollout だけを使うって相当ロックインでは？
  - 事前にデプロイメント戦略を決めてどちらで実装するのかを統一した方が良い
- AnalisysTemplate を使ってどのような分析を行うのかを定義できる

  - どのくらいリクエストが成功すれば OK なのかなど
  - めっちゃ宣言的に書けている印象
  - いろんな分析メトリクスが用意されており、その結果は宣言的に参照できる感じの印象
  - Prometheus Metrics を利用すれば PromQL で分析できる
    - Event 駆動とかのテストにいい気がする
  - Job を利用した分析もできるっぽい(コンテナを使えるんで相当柔軟性も高いよねってことかな)

- Argo Rollouts は Argo CD との依存関係はない
- Argo Rollout を利用して Rollout するには Promote コマンドを別途利用する必要がありそう
- また ArgoCD の Web 画面からは Rollout される対象の Deployment は出力されない？
  - Deployment Ref を使うのではなく、全て Rollout として定義したものを ArgoCD に管理させればできるかも
  - ちゃんと出力された
  - Deployment Ref を使っても問題ない
  - application の設定で指定するディレクトリを rollout にすれば良いが、それだと kustomize に変更があった時に deployment が更新された後に rollout が変更されて webui に反映されるのかがわからない
