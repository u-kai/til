- 大抵の言語はメッセージパッシング形式よりもメモリを共有し，同期する方を好んでいる
- Go は CSP の原理を言語の中核として具現化し，この形式の並行プログラミングを広めたもの
- 並行処理の問題を解決するものを設計する際には，言語の一連の抽象化が OS スレッドとメモリアクセス同期の水準にとどまってしまうのが一般的
- Go では異なる手法を採用し，代わりにゴルーチンとチャネルという概念を用意した

  - ゴルーチンとスレッド，チャネルとミューテックスが比較することができる

- Web サーバーを作る例でスレッドを使う場合に考えることは

  - 言語がスレッドをサポートしているのか？ライブラリを使わないといけないのか？
  - スレッド拘束の境界はどこか？
  - OS でのスレッドの操作はどのくらい重いか？
  - プログラムが実行されうる OS によってスレッドがどのように異なった扱われかたをするのか？
  - スレッドを作って保存しておくためのワーカープールを作るべきだろうか？その場合最適なスレッド数は幾つなのか？

- 上記を簡単に考えると，User ごとにセッションを作成し，レスポンスするというもの
- Go では，各接続に対してゴルーチンを作成し，格ゴルーチンでリクエストを捌いてゴルーチンの関数からレスポンスを返す
- ゴルーチンは軽量でゴルーチンの作成にかかるコストを機にする必要は無い
- Go のランタイムはゴルーチンを OS スレッドへ自動的に多重化し，そのスケジューリングもしてくれる

  - 設計変更なしに，ランタイムを最適化することができる
  - Go のランタイムはゴルーチンのすけージューリングを管理してくれてて，IO を待ちをしていることがわかれば IO 町をしていない OS スレッドをそのゴルーチンに際割り当てしてくれる

- go では
  - メモリを共有することで通信してはいけない，代わりに通信をすることでメモリを共有する
    - やり取りをメモリ共有で達成するんじゃなくて，やり取りをしてメモリ共有(と同じようなこと？)を達成するってことかな？
    - Mutex よりも chanel って感じかな？

## ロック機構を使うのかチャネルを使うのか

- データの所有権を移動しようとしているか？

  - 並行プログラムを安全にする方法の 1 つとして一度に 1 つの並行処理のコンテキストのみがデータの所有権を持つようにする
  - チャネルを使うとこの意図をチャネルの方の形で表現することで，並行プログラムを安全にするという構想を伝えることができる
  - この大きな利点は Producer と Consumer を切り離すことができること
  - 他の大きな利点はチャネルを使うことで暗黙的に並行処理のコードを他の並行処理コードと構成可能にすること

- 構造体の内部の状態を保護しようとしているか

  - これはメモリアクセス動機を使うかどうかの分岐点で，チャネルを使うべきでないもの
  - メモリアクセス動機を使う事でクリティカルセクションをロックする実装の複雑な詳細を呼び出し元から隠せる
  - ロックによりアトミックな処理を提供することができる

- 複数のロジックを強調させようとしているか？

  - チャネルはメモリアクセス同期よりも構成可能で，あらゆるとこお r で使われることを想定している

- パフォーマンスクリティカルセクションかどうか？
