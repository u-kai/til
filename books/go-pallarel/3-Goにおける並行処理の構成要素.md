# 3

- ゴルーチンはお互いに同じアドレス空間を操作していて，単純に関数をホストしているためグローちんを使うことは並行でないコードを書くことの自然な延長になっている
- Go のコンパイラはうまい具合に変数をメモリに割り当ててくれて，ゴルーチンが解放されたメモリに間違ってアクセスしてしまわないようにしている
- これによって開発者がメモリ管理ではなく，問題空間に集中できる
- しかし，複数のゴルーチンが同じアドレス空間に対して操作をするため，依然として同期に関しては気にかけないといけない
- ゴルーチンはめちゃくちゃ軽い

  - 新しく生成されたゴルーチンには数 KB のメモリが与えられる
  - もしメモリが足りない場合は，ランタイムがメモリを自動的に増加させてスタックを保持できるようにし，多くのゴルーチンが適切な量のメモリの中で生存できるようにする

- ゴルーチンのコンテキストスイッチも早い

## WaitGroup

- ひとまとまりの並行処理があった時，その結果を気にしない，もしくは他に結果を収集する手段があるときにそれらの処理の終了を待つ手段として有効
- どちらの前提も当てはまらない場合は，select 文を使うのがおすすめ

## Mutex と RWMutex

- Mutex は相互排他を表す mutual exclusion の略でプログラム内のクリティカルセクションを保護する方法の 1 つ
- クリティカルセクションはプログラムが共有リソースに対する排他的アクセスを提供している
- RWMutex は Mutex よりも早くするためのもので，多数の読み込みを許容するもの

## Cond

- イベントの発生を知らせるもの
- イベントは 2 つ以上のゴルーチン間でそれが発生したということ以外の情報がない任意のシグナルを指す
- ゴルーチン上で処理を続ける前にこうした信号を受け取りたいということが非常によくある
- こうした要望を Cond 型を使わずに実現する方法として，無限ループを使う方法がある
- しかし，CPU コアを占有してしまう

- cond を使った wait はスリープよりも効率的
  - ただブロックするだけでなく，現在のゴルーチンを一時停止する
- 何かのお知らせを cond.Wait()でお知らせが来るまで町，その度に条件を確認しにいく

  - コードのポイントは条件部分はロックによって守られたクリティカルセクションでないと確認できないという点
    - 例えば複数のスレッドが同じ変数を参照していて，クリティカルセクションによって，条件確認を保護しないといけないって感じかな？

- cond.Wait()は内部的には以下のコードと同等らしい

```go
  cond.L.Unlock()
  // お知らせを待つ
  cond.L.Lock()
```

- お知らせを待つという部分は Go ランタイムが実装していくれている部分で，何回でも再利用できるし，具体的にどのような実装になっているのかを知る必要ない
- なので，sync.Cond のどの例も以下のように,ロックをとって，ループに入って，ループを抜けた後にロックを解放して，，，という処理をしている

```go
cond.L.Lock()
// 条件はクリティカルセクションで守ってあげる必要がある
for !条件 {
   cond.Wait()
}
cond.L.UnLock()
```
