Providing and Using a Server Image Across Teams In many organizations, a central team builds server images and makes them available for other teams to use. This situation adds a few wrinkles to managing server image updates. The team using the image needs to be sure that it is ready to use new versions of an image. For example, an internal application team may install bug tracking software onto the base Linux image provided by the compute team. The compute team may produce a new version of the base Linux image with updates that have an incompatibility with the bug tracking software. Ideally, server images feed into each team’s infrastructure pipeline. When the team owning the image releases a new version through its pipeline, each team’s infrastructure pipeline pulls that version and updates its server instances. The internal team’s pipeline should automatically test that the bug tracking software works with the new image version before rebuilding servers that its users depend on. Some teams may take a more conservative approach, pinning the image version number they use. The internal application team could pin their infrastructure to use version 1 of the basic Linux image. When the compute team releases version 2 of the image, the internal application team continues to use version 1 until they are ready to test and roll out version 2. Many teams use the pinning approach when their automation for testing and delivering changes to server infrastructure isn’t as mature. These teams need to do more manual work to be sure of image changes.
Even with mature automation, some teams pin images (and other dependencies) whose changes are riskier. The dependencies may be more fragile because the software the team deploys onto images is more sensitive to changes in the operating system. Or the team providing the image — perhaps an external group — has a track record of releasing versions with problems, so trust is low. Handling Major Changes to an Image Some changes to server images are more significant, and so more likely to need manual effort to test and modify downstream dependencies. For example, a new version of the application server image may include a major version upgrade for the application server software. Rather than treating this as a minor update to the server image, you may either use semantic versioning to indicate it is a more significant change, or even build a different server image entirely. When you use semantic versioning, most changes increment the lowest digit of the version, for example, 1.2.5 to 1.2.6. You indicate a major change by incrementing the second or first digit. For a minor application server software update that shouldn’t create compatibility issues for applications, you might increment version 1.2.6 of the server image to 1.3.0. For a major change that may break applications, you increment the highest digit, so 1.3.0 would be replaced by 2.0.0. In some cases, especially where you expect the older image version to be used by teams for some time, you may create a new image entirely. For example, if your basic Linux image uses Centos 9.x, but you want to start testing and rolling out Centos 10.x, rather than incrementing the version number of the image, you could create a new image, basic-linux10-1.0.0. This makes migration to the new OS version a more explicit undertaking than a routine image update.
チーム間でサーバーイメージを提供および使用する 多くの組織では、中央のチームがサーバーイメージを作成し、他のチームが使用できるようにしています。この状況は、サーバーイメージの更新を管理する際にいくつかの問題を引き起こします。イメージを使用するチームは、新しいバージョンのイメージを使用する準備が整っていることを確認する必要があります。たとえば、内部のアプリケーションチームは、コンピューティングチームが提供する基本Linuxイメージにバグトラッキングソフトウェアをインストールする場合があります。コンピューティングチームは、バグトラッキングソフトウェアと互換性のない更新が含まれた新しいバージョンの基本Linuxイメージを作成するかもしれません。理想的には、サーバーイメージは各チームのインフラストラクチャーパイプラインに組み込まれるべきです。イメージの所有チームがパイプラインを介して新しいバージョンをリリースすると、各チームのインフラストラクチャーパイプラインはそのバージョンを取得し、サーバーインスタンスを更新します。内部のチームのパイプラインは、ユーザーが依存するサーバーを再構築する前に、バグトラッキングソフトウェアが新しいイメージのバージョンと互換性があることを自動的にテストする必要があります。一部のチームでは、使用するイメージのバージョン番号を固定する保守的なアプローチを取る場合があります。内部のアプリケーションチームは、基本Linuxイメージのバージョン1を使用するように固定することができます。コンピューティングチームがイメージのバージョン2をリリースした場合、内部のアプリケーションチームはバージョン2のテストと展開の準備ができるまでバージョン1を使用し続けます。多くのチームは、サーバーインフラストラクチャーへの変更のテストとデリバリーの自動化が十分に成熟していない場合に、この固定アプローチを採用しています。これらのチームは、イメージの変更を確実にするためにより多くの手作業が必要です。
自動化が十分に成熟していても、一部のチームは（および他の依存関係も含めて）よりリスクのある変更のイメージを固定することがあります。依存関係はより壊れやすいかもしれません。なぜなら、チームがイメージに展開するソフトウェアがオペレーティングシステムの変更により影響を受けやすいためです。または、イメージを提供しているチーム（たとえば外部のグループ）が問題を抱えたバージョンをリリースしているため、信頼性が低い場合もあります。 イメージへの重要な変更の扱い サーバーイメージへの一部の変更はより重要であり、そのためには手動でテストや変更が必要なことがあります。たとえば、アプリケーションサーバーイメージの新しいバージョンには、アプリケーションサーバーソフトウェアのメジャーバージョンのアップグレードが含まれている場合です。サーバーイメージのマイナーアップデートとして扱うのではなく、セマンティックバージョニングを使用して、より重要な変更であることを示すこともできます。または、完全に別のサーバーイメージを作成することもできます。セマンティックバージョニングを使用する場合、ほとんどの変更はバージョンの最下位の桁を増やします。たとえば、1.2.5から1.2.6にするといった具合です。メジャーな変更を示すには、2番目または1番目の桁を増やします。アプリケーションサーバーソフトウェアのマイナーアップデートでは、アプリケーションに互換性の問題を引き起こさないために、サーバーイメージのバージョン1.2.6を1.3.0に増やすこともできます。アプリケーションに影響を与える可能性のある重大な変更では、最上位の桁を増やします。つまり、1.3.0は2.0.0に置き換えられます。場合によっては、古いイメージバージョンが一定の期間チームによって使用されることが予想されるため、新しいイメージを作成することもあります。たとえば、基本的なLinuxイメージがCentos9.xを使用している場合にCentos10.xのテストと展開を開始したい場合、イメージのバージョン番号を増やす代わりに、新しいイメージbasic-linux10-1.0.0を作成することができます。これにより、新しいOSバージョンへの移行がルーティンのイメージの更新よりも明示的な作業となります。