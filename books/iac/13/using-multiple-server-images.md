Using Multiple Server Images Some teams only maintain a single server image. These teams create the different types of servers they need by applying server configuration roles (see “Server Roles”) when creating server instances. Other teams, however, find it useful or necessary to maintain multiple server images. You need multiple images to support multiple infrastructure platforms, multiple server hardware architectures, or multiple server hardware architectures. And multiple images can be useful to optimize server creation time, following the strategy of baking over frying (“Baking Server Images”). Let’s examine each of these scenarios — supporting multiple platforms, and baking roles into server images — and then discuss strategies for maintaining multiple server images. Server Images for Different Infrastructure Platforms Your organization may use more than one infrastructure platform as part of a multicloud, poly-cloud, or hybrid cloud strategy. You need to build and maintain separate server images for each of these platforms. Often, you can use the same server configuration code, perhaps with some variations that you manage using parameters, across platforms. You might start with different source images on each platform, although in some cases, you can use images from your OS vendor or a trusted third party that builds them consistently for each. Each infrastructure platform should have a separate pipeline to build, test, and deliver new versions of the image. These pipelines may take server configuration code as input material. For example, if you update the server configuration for your application servers, you would push the change into each of the platform pipelines, building and testing a new server image for each. Server Images for Different Operating Systems If you support multiple operating systems or distributions, such as Windows, Red Hat Linux, and Ubuntu Linux, you’ll need to maintain separate images for each OS. Also, you probably need a separate image for each major version of a given OS that your organization uses. You need a separate source image to build each of these OS images. You might be able to reuse server configuration code across some of these OS images. But in many cases, writing server configuration code to handle different operating systems adds complexity, which requires more complex testing. The testing pipeline needs to use server (or container) instances for each variation. For some configurations, it can be simpler to write a separate configuration code module for each OS or distribution. Server Images for Different Hardware Architectures Some organizations run server instances on different CPU architectures, such as x86 and ARM. Most often, you can build nearly identical server images for each architecture, using the same code. Some applications exploit specific hardware features or are more sensitive to their differences. In these cases, your pipelines should test images more thoroughly across the different architectures to detect issues.
Server Images for Different Roles Many teams use a general-purpose server image and apply role configuration (see “Server Roles”) when creating server instances. However, when configuring a server for a role involves installing too much software, such as an application server, it can be better to bake the role configuration into a dedicated image. The example earlier in this chapter (“Versioning a Server Image”) used custom images for application servers and container host nodes, and a general-purpose Linux image. This example shows that you don’t necessarily need to have a separate image for each server role you use. To decide whether it’s worth maintaining a separate image for a particular role, consider the time and cost of having pipelines, tests, and storage space, and weigh these against the drawbacks of configuring server instances when you create them — speed, efficiency, and dependencies — as explained in “Frying a Server Instance”. Layering Server Images Teams that have a large number of role-based server images may consider building them up in layers. For example, create a base OS image with the default packages and configurations that you want to install on all servers. Then use this image as the source image to build more specific role-based images for application servers, container nodes, and others, as shown in Figure 13-9. In this example, the ShopSpinner team uses a base Linux image as the source image for building an application server image and a container host node image. The application server image has Java and Tomcat preinstalled. The team uses this image, in turn, as the source image for building images with specific applications preinstalled.
複数のサーバーイメージを使用するいくつかのチームは、単一のサーバーイメージを保持しています。これらのチームは、サーバーインスタンスの作成時にサーバー構成の役割（「サーバーの役割」を参照）を適用することで、必要なさまざまなタイプのサーバーを作成します。ただし、他のチームでは、複数のサーバーイメージを保持することが便利または必要とされます。複数のイメージが必要な状況としては、複数のインフラストラクチャプラットフォームのサポート、複数のサーバーハードウェアアーキテクチャのサポート、および複数のサーバーハードウェアアーキテクチャの最適化が挙げられます。また、複数のイメージは、サーバーの作成時間を最適化するために役立つ場合があります（「サーバーイメージの作成」）。では、これらのシナリオそれぞれ、複数のプラットフォームのサポートとサーバーイメージへのロールの組み込みについて調べ、その後、複数のサーバーイメージを維持するための戦略について議論しましょう。

異なるインフラストラクチャプラットフォームのためのサーバーイメージ
マルチクラウド、ポリクラウド、またはハイブリッドクラウド戦略の一環として、組織内で複数のインフラストラクチャプラットフォームを使用することがあります。これらのプラットフォームのそれぞれに対して別々のサーバーイメージを構築および維持する必要があります。通常、プラットフォーム間で同じサーバー構成コードを使用できますが、パラメータを使用して管理するいくつかの変更があるかもしれません。各インフラストラクチャプラットフォームごとに、イメージの新バージョンをビルド、テスト、および配信するための別個のパイプラインが必要です。これらのパイプラインは、サーバー構成コードを入力材料として受け取る場合があります。たとえば、アプリケーションサーバーのサーバー構成を更新する場合、変更を各プラットフォームのパイプラインに反映し、それぞれのために新しいサーバーイメージをビルドおよびテストします。

異なるオペレーティングシステム用のサーバーイメージ
Windows、Red Hat Linux、Ubuntu Linuxなど、複数のオペレーティングシステムまたはディストリビューションをサポートする場合、それぞれのOSに対して別々のイメージを維持する必要があります。また、組織が使用する特定のOSの各メジャーバージョンについても、別々のイメージが必要です。これらのOSイメージをビルドするために別々のソースイメージが必要です。いくつかのOSイメージでサーバー構成コードを再利用できる場合もありますが、さまざまなオペレーティングシステムに対応するためのサーバー構成コードの作成は複雑さを増し、より複雑なテストが必要となります。テストパイプラインは、各バリエーションのためにサーバー（またはコンテナ）インスタンスを使用する必要があります。一部の構成では、各OSまたはディストリビューションごとに別個の構成コードモジュールを作成する方がシンプルになる場合もあります。

異なるハードウェアアーキテクチャ用のサーバーイメージ
一部の組織は、x86およびARMなどの異なるCPUアーキテクチャでサーバーインスタンスを実行しています。ほとんどの場合、同じコードを使用してほぼ同じサーバーイメージを各アーキテクチャに対してビルドすることができます。一部のアプリケーションでは、特定のハードウェア機能を利用するか、その差異により影響を受けることがあります。これらの場合、パイプラインはさまざまなアーキテクチャにわたってイメージをより詳細にテストして、問題を検出する必要があります。

異なる役割のためのサーバーイメージ
多くのチームは、一般的なサーバーイメージを使用し、サーバーインスタンスの作成時に役割の構成（「サーバーの役割」を参照）を適用します。ただし、サーバーを役割に応じて設定する場合、アプリケーションサーバーなどの多くのソフトウェアをインストールする必要がある場合、専用のイメージに役割の構成を組み込む方が良い場合もあります。 この章の前の例（「サーバーイメージのバージョン管理」）では、アプリケーションサーバーとコンテナホストノードにカスタムイメージを使用し、汎用Linuxイメージを使用しました。この例では、使用する各サーバーの役割ごとに別個のイメージが必要ではないことが示されています。特定の役割ごとに別個のイメージを維持する価値があるかどうかを決定するには、パイプライン、テスト、およびストレージスペースの時間とコストを考慮し、これらを作成時にサーバーインスタンスを設定する場合の欠点（速度、効率、および依存関係）を「サーバーインスタンスのフライ」として説明されているものと比較してください。

サーバーイメージのレイヤリング
ロールベースのサーバーイメージが多数あるチームでは、レイヤー別に構築することを検討する場合があります。たとえば、すべてのサーバーにインストールしたいデフォルトのパッケージと設定を持つ基本OSイメージを作成します。次に、このイメージをソースイメージとして、アプリケーションサーバーやコンテナノードなどのより具体的なロールベースのイメージを構築します（図13-9参照）。この例では、ShopSpinnerチームは、基本Linuxイメージをソースイメージとして、アプリケーションサーバーイメージとコンテナホストノードイメージを構築しています。アプリケーションサーバーイメージにはJavaとTomcatがプリインストールされています。チームは、このイメージをソースイメージとして、特定のアプリケーションがプリインストールされたイメージを構築するために使用します。