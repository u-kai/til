Changing a Server Image Server images become stale over time as updated packages and configurations are released. Although you can apply patches and updates every time you create a new server, this process takes longer as time goes by, reducing the benefit of using a server image. Regularly refreshing your images keeps everything running smoothly.
In addition to keeping images up-to-date with the latest patches, you often need to improve the base configurations, add and remove standard packages, and make other routine changes to your server images. The more you bake into your custom server images rather than frying into server instances as you create them, the more often you need to update your images with changes. The next section explains how to use a pipeline to make, test, and deliver changes to your server images. There are a few prerequisites to cover before getting into pipelines, however. One is how to make updates — whether to use the existing server image as the base for your change or rebuild the image from first principles. Another prerequisite is versioning your server images. Reheating or Baking a Fresh Image When you want to build a new version of a server image — for example, to update it with the latest operating system patches — you can use the same tools and processes that you used to build the first version of the image. You could use the previous version of the image as the origin source image — reheating the image. This ensures that the new version is consistent with the previous version, because the only changes are the ones you explicitly make when you apply server configuration to the new image. The alternative is to bake a fresh image, building the new version of the image from the original sources. So, if you built the first image version from scratch, you build each new version from scratch as well. While reheating images may limit the changes from one version to the next, baking a fresh image for the new version should give the same results, given that you are using the same sources. Fresh builds are arguably cleaner and more reliably reproducible because they don’t include anything that may have been left over by previous builds. For example, your server configuration may install a package that you later decide to remove. That package is still found on newer server images if you reheat from the older images. You need to add code to explicitly remove the package, which leaves you with superfluous code to maintain and clean out later. If instead, you bake fresh images each time, the package will simply not exist on newer server images, so there’s no need to write any code to remove it. Versioning a Server Image It’s essential that everyone who uses server images, and servers created from them, can track the versions. They should be able to understand what version was used to create any given server instance, which version is the latest for a given image, and what source content and configuration code were used to create the image. It’s also helpful to be able to list which server image versions were used to create instances currently in use — for example, so you can identify instances that need to be updated when you discover a security vulnerability. Many teams use different server images. For example, you may build separate images for application servers, container host nodes, and a general-purpose Linux OS image. In this case, you would manage each of these images as a separate component, each with its separate version history, as illustrated in Figure 13-4.
In this example, the team updated the application server image to upgrade the version of Tomcat installed on it, bumping that image to version 2, while the others remained at version 1. The team then updated all of the images with Linux OS updates. This bumped the application server image to version 3, and the other images to version 2. Finally, the team upgraded the container software version on the host node image, bumping it to version 3. Most infrastructure platforms don’t directly support version numbering for server images. In many cases, you can embed version numbers in the name of the server image. For the examples in Figure 13-4, you might have images named appserver-3, basic-linux-2, and container-node-3.
Another option is to put version numbers and image names in tags if your platform supports it. An image could have a tag named Name=appserver and another named Version=3. Use whatever mechanism makes it easiest to search, discover, and report on image names and versions. Most of the teams I’ve worked with use both of those methods, since tags are easy to search, and names are easy for humans to see. You can use different version numbering schemes. Semantic versioning is a popular approach, using different fields of a three-part version number (such as 1.0.4) to indicate how significant the changes are from one version to the next. I like to add a date and time stamp into the version (for example, 1.0.4-20200229_0420, to make it easy to see when a particular version was built. In addition to putting the version number on the server image itself, you can tag or label server instances with the server image name and version used to create it. You can then map each instance back to the image used to create it. This ability is useful for rolling out new image versions. Updating Server Instances When an Image Changes When you build a new version of a server image, you may replace all of the server instances based on that image, or wait for them to be replaced naturally over time. A policy of rebuilding existing servers to replace old image versions can be disruptive and time-consuming. But it also ensures the consistency of servers and continuously exercises your system’s resilience (see also “Continuous Disaster Recovery”). A good pipeline makes it easier to manage this process, and zero-downtime changes (see “Zero Downtime Changes”) make it less disruptive. So this policy is favored by many teams with mature and pervasive automation. It’s easier to wait to replace servers with the new image version when they are rebuilt for other reasons. This might be the case if you deploy software updates or other changes by rebuilding server instances (see “Pattern: Immutable Server”). The drawback of waiting to update servers with new image versions is that this may take a while, and leave your estate with servers built from a wide variety of image versions. This situation creates inconsistency. For example, you may have application servers with different versions of OS package updates and configuration, leading to mysteriously inconsistent behavior. In some cases, the older image versions, and the servers built from them, may have security vulnerabilities or other issues. There are a few strategies you can use to mitigate these issues. One is to track running instances against the image versions used to create them. This could be a dashboard or report, similar to Table 13-1. Table 13-1. Example report of instances and their image versions Image Version Instance count basic-linux 1 4 basic-linux 2 8
appserver 1 2 appserver 2 11 appserver 3 8 container-node 1 2 container-node 2 15 container-node 3 5 If you have this information readily available, and you can drill into the list of specific servers, then you can identify server instances that urgently need rebuilding. For example, you learn about a security vulnerability that was fixed in the latest update to your Linux distribution. You included the patch in basic-linux-2, appserver-3, and container-node-2. The report shows you that you need to rebuild 19 of your server instances (4 basic Linux servers at version 1, 13 application servers at versions 1 and 2, and 2 container nodes at version 1). You may also have age limits. For example, you could have a policy to replace any running server instances built from a server image older than three months. Your report or dashboard should then show the number of instances that are past this date.
サーバーイメージの変更
サーバーイメージは、更新されたパッケージや設定がリリースされるにつれて徐々に古くなります。新しいサーバーを作成するたびにパッチやアップデートを適用することは可能ですが、時間が経つにつれてこのプロセスは長くなり、サーバーイメージを使用する利点が減少します。定期的にイメージを更新することで、すべてがスムーズに動作するように保ちます。

最新のパッチでイメージを最新の状態に保つだけでなく、ベースの設定を改善したり、標準のパッケージを追加したり削除したり、他の定期的な変更をサーバーイメージに加える必要があります。サーバーインスタンスを作成する際に、焼き込む（bake）代わりにカスタムサーバーイメージに組み込むほど、変更をイメージに反映するためにイメージをより頻繁に更新する必要があります。次のセクションでは、パイプラインを使用してサーバーイメージに変更を加え、テストしてデリバリーする方法について説明します。ただし、パイプラインに入る前にいくつかの前提条件をカバーする必要があります。まずは、更新方法についてです。変更のベースとして既存のサーバーイメージを使用するか、最初の原則からイメージを再構築するかを選択する必要があります。もう一つの前提条件は、サーバーイメージにバージョンを付けることです。

新しいバージョンのサーバーイメージを作成するために、例えば最新のオペレーティングシステムパッチでイメージを更新する場合、最初のイメージのビルド時に使用したツールとプロセスを使用することができます。既存のイメージを元のソースイメージとして使用することができます（イメージをリヒートする）。これにより、新しいバージョンが前のバージョンと一貫性があることが保証されます。なぜなら、新しいイメージにサーバーの設定を適用する際に行った変更のみが変更となるからです。もう一つの選択肢は、元のソースから新しいバージョンのイメージをビルドすることです。したがって、最初のイメージバージョンをスクラッチからビルドした場合、新しいバージョンも同じソースからスクラッチからビルドします。イメージのリヒートによって1つのバージョンから次のバージョンへの変更が制限されるかもしれませんが、新しいバージョンのイメージを新たに作成すれば、同じ結果が得られるはずです。新しいビルドは、以前のビルドに残っている可能性のあるものを含まず、きれいで再現性のある結果となります。たとえば、サーバーの設定で後で削除することにしたパッケージがインストールされる可能性があります。前のイメージからリヒートすると、新しいサーバーイメージにもそのパッケージが残ります。パッケージを削除するためのコードを明示的に追加する必要があり、後でメンテナンスとクリーニングを行うために不要なコードが残ります。代わりに、毎回新しいイメージを作成すれば、そのパッケージが新しいサーバーイメージに含まれないため、削除するためのコードは必要ありません。

サーバーイメージのバージョン管理
サーバーイメージやそれから作成されたサーバーを使用するすべての人がバージョンを追跡できることは非常に重要です。どのバージョンが特定のサーバーインスタンスを作成するために使用されたのか、特定のイメージの最新バージョンは何か、どのソースコンテンツと設定コードがイメージ作成に使用されたのかを理解できる必要があります。また、現在使用中のインスタンスを作成するために使用されたサーバーイメージのバージョンもリストアップすることは役に立ちます。たとえば、セキュリティの脆弱性が発見された際に更新が必要なインスタンスを特定するためです。多くのチームは異なるサーバーイメージを使用しています。例えば、アプリケーションサーバー、コンテナホストノード、一般的なLinux OSイメージなどの別々のイメージを作成することがあります。この場合、それぞれのイメージを個別のコンポーネントとして管理し、独自のバージョン履歴を持つ必要があります（図13-4をご覧ください）。

この例では、チームはTomcatのバージョンをアップグレードするためにアプリケーションサーバーイメージを更新し、そのイメージをバージョン2にしましたが、他のイメージはバージョン1のままでした。その後、チームはすべてのイメージにLinux OSのアップデートを適用しました。これにより、アプリケーションサーバーイメージはバージョン3に、他のイメージはバージョン2になりました。最後に、チームはホストノードイメージのコンテナソフトウェアのバージョンをアップグレードし、バージョン3にしました。ほとんどのインフラストラクチャプラットフォームは、サーバーイメージのバージョン管理を直接サポートしていません。多くの場合、サーバーイメージの名前にバージョン番号を埋め込むことができます。図13-4の例では、appserver-3、basic-linux-2、container-node-3などの名前を持つイメージがあります。

また、プラットフォームがサポートしている場合は、タグにバージョン番号とイメージ名を付けることもできます。イメージにはName=appserverというタグとVersion=3というタグが付けられるかもしれません。イメージの名前とバージョンを検索、発見、報告するために、最も簡単なメカニズムを使用してください。私が取り組んできたチームのほとんどは、タグは検索しやすいため、名前は人間が見やすいため、それらの方法の両方を使用しています。さまざまなバージョンナンバリングスキームを使用することができます。セマンティックバージョニングは一般的な方法であり、3つのパートのバージョン番号（たとえば1.0.4など）の異なるフィールドを使用して、バージョンごとの変更の重要性を示します。私はバージョンに日付と時刻のタイムスタンプを追加するのが好きです（例：1.0.4-20200229_0420）。特定のバージョンが構築された日時を簡単に確認できるようになります。サーバーイメージ自体にバージョン番号を付けるだけでなく、サーバーインスタンスにもサーバーイメージの名前とバージョンをタグ付けするかラベル付けすることもできます。その後、各インスタンスを作成したイメージにマップすることができます。この機能は新しいイメージバージョンの導入に便利です。

サーバーインスタンスの更新
新しいバージョンのサーバーイメージをビルドすると、そのイメージを基にしたすべてのサーバーインスタンスを置き換えるか、自然に置