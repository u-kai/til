Using a Pipeline to Test and Deliver a Server Image Chapter 8 describes using pipelines to test and deliver infrastructure code changes (“Infrastructure Delivery Pipelines”). Pipelines are an excellent way to build server images. Using a pipeline makes it easy to build new versions of an image, ensuring they are built consistently. With a mature pipeline integrated with pipelines for other parts of a system, you can safely roll out operating system patches and updates across your estate weekly or even daily. It’s a good idea to build new server images often, such as weekly, rather than leaving it for long periods, such as every few months. This fits with the core practice of continuously testing and delivering changes. The longer you wait to build a new server image, the more changes it includes, which increases the work needed to test, find, and fix problems. A basic server image pipeline would have three stages, as shown in Figure 13-5.
Each of these stages for building, testing, and publishing a server image merits a closer look. Build Stage for a Server Image The build stage of a server image pipeline automatically implements the online image building process (“Online Image Building Process”) or offline image building process (“Offline Image Building Process”). The stage produces a server image, which the following stages treat as a release candidate (see Figure 13-6).
You can configure the server image build stage to run automatically on changes to any of the inputs to the image listed in “Origin Content for a Server Image”. For example: Someone commits a change to the image builder code, such as Packer template The vendor publishes a new version of your origin source image, such as an AMI provided by the OS vendor You make changes to server configuration code used for the server image Package maintainers publish new versions of packages installed on the server image In practice, many changes to source elements like OS packages are difficult to automatically detect and use to trigger a pipeline. You may also not want to build a new server image for every package update, especially if the image uses dozens or even hundreds of packages. So you could automatically trigger new images only for major changes, like the source server image or image builder code. You can then implement scheduled builds — for example, weekly — to roll up all of the updates to smaller source elements. As mentioned, the result of the build stage is a server image that you can use as a release candidate. If you want to test your image before making it available — recommended for any nontrivial use case — then you should not mark the image for use at this point. You can tag the image with a version number, according to the guidance given earlier. You might also tag it to indicate that it is an untested release candidate; for example, Release_Status=Candidate. Test Stage for a Server Image Given the emphasis on testing throughout this book, you probably understand the value of automatically testing new images as you build them. People usually test server images using the same testing tools that they use to test server code, as described in “Testing Server Code”. If you build server images online (see “Online Image Building Process”), you could run your automated tests on the server instance after you configure it and before you shut it down and convert it to an image. But there are two concerns with this. First, your tests might pollute the image, leaving test files, log entries, or other residue as a side effect of your tests. They might even leave user accounts or other avenues for accessing servers created from the image. The other concern with testing the server instance before you turn it into an image is that it may not reliably replicate servers created from the image. The process of converting the instance into an image might change important aspects of the server, such as user access permissions. The most reliable method for testing a server image is to create and test a new instance from the final image. The drawback of doing this is that it takes longer to get the feedback from your tests. So a typical server image test stage, as shown in Figure 13-7, takes the identifier of the image created in the build stage, uses it to create a temporary instance, and runs automated tests against that. If the tests pass, then the stage tags the image to indicate that it’s ready for the next stage of the pipeline.
Delivery Stages for a Server Image Your team’s image pipeline may have additional stages for other activities — for example, security testing. Ultimately, an image version that passes its test stages is tagged as ready for use. In some systems, the pipeline that creates the image includes the stages to rebuild servers with the new image (see Figure 13-8). It could run a stage for each delivery environment in the progression to production, perhaps triggering application deployment and test stages. Figure 13-8. Pipeline that delivers images to environments In systems where different teams are responsible for managing infrastructure and environments, the image pipeline may end once it has marked the image as ready for use. Other teams’ pipelines take new image versions as inputs, as described in “Providing and Using a Server Image Across Teams”.
第8章では、パイプラインを使用してインフラストラクチャのコード変更をテストおよびデリバリーする方法について説明しています（「インフラストラクチャデリバリーパイプライン」）。パイプラインはサーバーイメージを構築するための優れた方法です。パイプラインを使用することで、イメージの新しいバージョンを簡単に構築し、一貫して構築されていることを保証することができます。システムの他の部分のパイプラインと統合された成熟したパイプラインを使用すると、週ごとまたは毎日のペースでオペレーティングシステムのパッチやアップデートを安全に展開することができます。新しいサーバーイメージを頻繁に（たとえば週に1回）構築することは、数か月ごとなどの長期間放置するよりも良いアイデアです。これは、継続的なテストと変更の提供の中核的なプラクティスに合致しています。新しいサーバーイメージを構築するのを待つ時間が長くなるほど、含まれる変更が増え、テスト、問題の発見、修正に必要な作業が増えます。図13-5に示すように、基本的なサーバーイメージパイプラインには3つのステージがあります。

ビルドステージでは、サーバーイメージパイプラインのビルドステージが自動的にオンラインイメージビルディングプロセスまたはオフラインイメージビルディングプロセスを実装します。このステージでは、リリース候補としてサーバーイメージが生成されます（図13-6参照）。

サーバーイメージのビルドステージは、「サーバーイメージの元コンテンツ」にリストされているイメージの入力のいずれかが変更された場合に自動的に実行されるように設定することができます。例えば：
- 人がイメージビルダーコード（Packerテンプレートなど）を変更し、コミットする
- ベンダーがオリジンソースイメージ（OSベンダーが提供するAMIなど）の新しいバージョンを公開する
- サーバーイメージに使用されるサーバーコンフィギュレーションコードを変更する
- パッケージメンテナーがサーバーイメージにインストールされたパッケージの新しいバージョンを公開する

実際には、OSパッケージなどのソース要素への多くの変更は自動的に検出してパイプラインをトリガーするのが難しい場合があります。また、イメージが数十または数百のパッケージを使用している場合、すべてのパッケージの更新ごとに新しいイメージを自動的にトリガーする必要はありません。したがって、ソースサーバーイメージやイメージビルダーコードなどの主要な変更に対してのみ新しいイメージを自動的にトリガーし、その他の小規模なソース要素の更新を週ごとにまとめてビルドすることができます。前述のように、ビルドステージの結果はリリース候補として使用できるサーバーイメージです。利用可能にする前にイメージをテストする場合（どのユースケースでも推奨）、この時点でイメージを使用するようにはマークしないでください。以前に示したガイダンスに従って、イメージにバージョン番号を付けることができます。また、未テストのリリース候補であることを示すタグを付けることもできます。例えば、Release_Status=Candidateとします。

サーバーイメージに対するテストステージでは、本書全体を通じてテストに重点を置いているため、イメージを構築する際に自動的に新しいイメージをテストすることの価値は理解できるでしょう。人々はサーバーコードをテストするためにサーバーイメージと同じテストツールを使用することが一般的です（「サーバーコードのテスト」を参照）。オンラインイメージビルディングプロセスを使用してサーバーイメージを構築する場合、構成後、シャットダウンする前にサーバーインスタンスで自動化されたテストを実行することができます。しかし、これには2つの懸念があります。まず、テストがイメージを汚染し、テストファイルやログエントリ、その他の残留物を残す可能性があります。イメージから作成されたサーバーにアクセスするためのユーザーアカウントなど、他のアクセス経路も残すかもしれません。イメージに変換する前にサーバーインスタンスをテストする場合、イメージから作成されたサーバーを確実に複製することができない可能性があります。インスタンスをイメージに変換するプロセスでは、ユーザーアクセス権限などの重要なサーバーの側面が変更される可能性があります。サーバーイメージをテストする最も信頼性の高い方法は、最終イメージから新しいインスタンスを作成してテストすることです。これを行うことの欠点は、テストからフィードバックを得るのに時間がかかるということです。したがって、図13-7に示す通常のサーバーイメージのテストステージでは、ビルドステージで作成されたイメージの識別子を使用して一時的なインスタンスを作成し、それに対して自動化されたテストを実行します。テストが成功すると、ステージはイメージにタグを付けて、次のパイプラインのステージの準備ができていることを示します。

サーバーイメージの配信ステージ チームのイメージパイプラインには、他の活動（セキュリティテストなど）のための追加のステージがある場合があります。最終的に、テストステージをパスしたイメージバージョンは、使用する準備ができているとしてタグ付けされます。一部のシステムでは、イメージを作成するパイプラインには、新しいイメージでサーバーを再構築するステージが含まれている場合があります（図13-8参照）。プロダクションへの進行における各デリバリー環境向けにステージを実行し、アプリケーションの展開とテストのステージをトリガーすることもあります。図13-8. 環境にイメージを配信するパイプライン 異なるチームがインフラストラクチャと環境の管理を担当するシステムでは、イメージパイプラインは、使用可能にマークされたイメージがある時点で終了する場合があります。他のチームのパイプラインは、新しいイメージバージョンを入力として受け取ることができます（「複数のチーム間でのサーバーイメージの提供と使用」を参照）。