Managing Infrastructure and Application Code Should application and infrastructure code be kept in separate repositories, or together? Each answer seems obviously correct to different people. The right answer depends on your organization’s structure and division of ownership. Managing infrastructure and application code in separate repositories supports an operating model where separate teams build and manage infrastructure and applications. But it creates challenges if your application teams have responsibility for infrastructure, particularly infrastructure specific to their applications.
Separating code creates a cognitive barrier, even when application team members are given responsibility for elements of the infrastructure that relate to their application. If that code is in a different repository than the one they most often work in, they won’t have the same level of comfort digging into it. This is especially true when it’s code that they’re less familiar with, and when it’s mixed with code for infrastructure for other parts of the system. Infrastructure code located in the team’s own area of the codebase is less intimidating. There’s less feeling that a change might break someone else’s applications or even fundamental parts of the infrastructure. DevOps and Team Structures The DevOps movement encourages organizations to experiment with alternatives to the traditional divide between development and operations. See Matthew Skelton and Manuel Pais’s writings on Team Topologies for more in-depth thoughts on structuring application and infrastructure teams. Delivering Infrastructure and Applications Regardless of whether you manage application and infrastructure code together, you ultimately deploy them into the same system.2 Changes to infrastructure code should be integrated and tested with applications throughoutAs a counter-example, many organizations have a legacy view of production infrastructure as a separate silo. Quite often, one team owns the production infrastructure, including a staging or preproduction environment, but doesn’t have responsibility for development and testing environments (Figure 18-9).
This separation creates friction for application delivery, and also for infrastructure changes. Teams don’t discover conflicts or gaps between the two parts of the system until late in the delivery process. As explained in Chapter 8, continuously integrating and testing all parts of the system as people work on changes is the most effective way to ensure high quality and reliable delivery. So your delivery strategy should deliver changes to infrastructure code across all environments. There are a few options for the flow of infrastructure changes.
インフラストラクチャおよびアプリケーションコードの管理は、別々のリポジトリに保持すべきか、一緒に保持すべきか？ 異なる人々にとって、それぞれの回答は明らかに正しいと思われます。正しい答えは、組織の構造と所有の分割に依存します。インフラストラクチャおよびアプリケーションコードを別々のリポジトリで管理することは、別々のチームがインフラストラクチャとアプリケーションを構築および管理する運用モデルをサポートします。しかし、特にアプリケーションチームがアプリケーション固有のインフラストラクチャに責任を持つ場合、課題も生じます。
コードを分離すると、アプリケーションチームのメンバーが自分のアプリケーションに関連するインフラストラクチャの要素に責任をもたされていても、認知的な障壁が生まれます。もしコードが彼らが最も頻繁に作業を行うリポジトリとは異なる場所にある場合、彼らは同じレベルの快適さでそれを理解することはありません。これは、彼らがあまり馴染みのないコードであり、システムの他の部分のインフラストラクチャのコードと混在している場合に特に当てはまります。チームのコードベース内にあるインフラストラクチャコードは、より扱いやすくなります。他の誰かのアプリケーションやインフラストラクチャの基本的な部分を壊してしまう可能性が少なくなります。 DevOpsとチーム構造 DevOpsの運動は、開発と運用の伝統的な分断に代替案を試みることを組織に奨励しています。「Team Topologies」（Matthew SkeltonおよびManuel Pais）の執筆を詳しく参照して、アプリケーションとインフラストラクチャのチーム構造に関する考え方を知ることができます。インフラストラクチャとアプリケーションの提供 不管アプリケーションとインフラストラクチャのコードを一緒に管理するかどうかに関わらず、最終的には同じシステムにデプロイします。インフラストラクチャのコードの変更は、アプリケーションと統合し、テストする必要があります。対照例として、多くの組織では、本番インフラストラクチャを別々の隔離されたシロと見なしています。非常にしばしば、1つのチームが本番インフラストラクチャ、ステージング環境またはプレプロダクション環境を含むものを所有していますが、開発およびテスト環境には責任を持っていません（図18-9を参照）。この分離は、アプリケーションの提供プロセスおよびインフラストラクチャの変更に摩擦を生み出します。チームは、システムの2つの部分の間の衝突やギャップを発見するのが遅くなることがあります。第8章で説明したように、変更に取り組む人々がシステムのすべての部分を継続的に統合し、テストすることは、高品質かつ信頼性のある提供を確保するために最も効果的な方法です。したがって、提供戦略はすべての環境にわたってインフラストラクチャコードの変更を行う必要があります。インフラストラクチャの変更のフローにはいくつかのオプションがあります。