Cross-Project Tests Progressive testing (see “Progressive Testing”) involves testing each project separately before testing it integrated with other projects, as shown in Figure 18-7.
You can comfortably put the test code to run in the individual stages for each project with that project. But what about the test code for the integration stage? You can put these tests in one of the projects, or create a separate project for the integration tests. Keeping integration tests within a project In many cases where you integrate multiple projects, one project is an obvious entry point for certain types of tests. For example, many functional tests connect to a front-end service to prove that the entire system works. If a backend component, such as a database, isn’t configured correctly, the frontend service can’t connect to it, so the test fails. In these cases, the integration test code lives comfortably with the project that provisions the frontend service. Most likely, the test code is coupled to that service. For example, it needs to know the hostname and port for that service. Separate these tests from tests that run in earlier delivery stages — for example, when testing with test doubles. You can keep each set of tests in a separate subfolder in the project. Integration tests also fit well in projects that consume other projects (see “Using Test Fixtures to Handle Dependencies”), rather than in the provider project. The ShopSpinner example includes one stack project that defines application infrastructure instances, sharing network structures defined in a different stack. Putting integration tests into the shared network stack project goes against the direction of the dependency. The network project needs to know specific details of the application stack, and any other stacks that use it, to test that integration works correctly. The application infrastructure stack already knows about the shared network stack, so keeping the integration tests with the application stack code avoids dependency loops between the projects.

クロスプロジェクトテスト プログレッシブテスト（「プログレッシブテスト」を参照）では、図18-7に示されるように、他のプロジェクトと統合してテストする前に、それぞれのプロジェクトを個別にテストします。
各プロジェクトごとにテストコードをそのプロジェクトに合わせて実行することができます。しかし、統合ステージのテストコードはどうなるでしょうか？これらのテストを1つのプロジェクトに配置するか、統合テスト用に別のプロジェクトを作成することができます。プロジェクト内で統合テストを保持するプロジェクトの内部テストコードを保持するケースは多く、複数のプロジェクトを統合する場合において特定の種類のテストには明らかなエントリーポイントとなるプロジェクトが1つあります。たとえば、多くの機能テストは、システム全体が正常に動作していることを証明するためにフロントエンドサービスに接続します。バックエンドコンポーネント（データベースなど）が正しく構成されていない場合、フロントエンドサービスはそれに接続することができず、テストは失敗します。このような場合、統合テストコードはフロントエンドサービスを提供するプロジェクトと一緒に快適に存在します。おそらく、テストコードはそのサービスに結びついています。たとえば、そのサービスのホスト名とポートを知る必要があります。これらのテストを、テストダブルを使用してテストする場合など、前のデリバリーステージで実行されるテストとは別のサブフォルダに保持することができます。統合テストは、プロバイダープロジェクトではなく他のプロジェクト（「依存関係を処理するためのテストフィクスチャの使用」を参照）を消費するプロジェクトにも適しています。ShopSpinnerの例では、アプリケーションインフラストラクチャインスタンスを定義する1つのスタックプロジェクトがあり、異なるスタックで定義されたネットワーク構造を共有しています。統合テストを共有ネットワークスタックプロジェクトに配置することは依存関係の向きに逆らっています。ネットワークプロジェクトは、アプリケーションスタックの特定の詳細やそれを使用する他のスタックを知る必要があり、統合が正しく機能するかをテストするためです。アプリケーションインフラストラクチャスタックはすでに共有ネットワークスタックについて知っていますので、統合テストをアプリケーションスタックコードと一緒に保持することで、プロジェクト間での依存関係ループを回避します。