Organizing Projects and Repositories In this context, a project is a collection of code used to build a discrete component of the system. There is no hard rule on how much a single project or its component can include. “Patterns and Antipatterns for Structuring Stacks” describes different levels of scope for an infrastructure stack, for instance. A project may depend on other projects in the codebase. Ideally, these dependencies and the boundaries between projects are well-defined, and clearly reflected in the way project code is organized. Conway’s Law (see “Align Boundaries with Organizational Structures”) says that there is a direct relationship between the structure of the organization and the systems that it builds. Poor alignment of team structures and ownership of systems, and the code that defines those systems, creates friction and inefficiency. The flip side of drawing boundaries between projects is integrating projects when there are dependencies between them, as described for stacks in Chapter 17. See “Integrating Projects” for a discussion of how and when different dependencies may be integrated with a project.
There are two dimensions to the problem of how to organize code. One is where to put different types of code — code for stacks, server configuration, server images, configuration, tests, delivery tooling, and applications. The other is how to arrange projects across source code repositories. This last question is a bit simpler, so let’s start there. One Repository, or Many? Given that you have multiple code projects, should you put them all in a single repository in your source control system, or spread them among more than one? If you use more than one repository, should every project have its own repository, or should you group some projects together into shared repositories? If you arrange multiple projects into repositories, how should you decide which ones to group and which ones to separate? There are some trade-off factors to consider: Separating projects into different repositories makes it easier to maintain boundaries at the code level. Having multiple teams working on code in a single repository can add overhead and create conflicts. Spreading code across multiple repositories can complicate working on changes that cross them. Code kept in the same repository is versioned and can be branched together, which simplifies some project integration and delivery strategies. Different source code management systems (such as Git, Perforce, and Mercurial) have different performance and scalability characteristics and features to support complex scenarios. Let’s look at the main options for organizing projects across repositories in the light of these factors.
One Repository for Everything Some teams, and even some larger organizations, maintain a single repository with all of their code. This requires source control system software that can scale to your usage level. Some software struggles to handle a codebase as it grows in size, history, number of users, and activity level.1 So splitting repositories becomes a matter of managing performance. A single repository can be easier to use. People can check out all of the projects they need to work on, guaranteeing they have a consistent version of everything. Some version control software offers features, like sparse-checkout, which let a user work with a subset of the repository.
Monorepo — One Repository, One Build A single repository works well with build-time integration (see “Pattern: Build-Time Project Integration”). The monorepo strategy uses the build-time integration pattern for projects maintained in a single repository. A simplistic version of monorepo builds all of the projects in the repository, as shown in Figure 18-1.
Although the projects are built together, they may produce multiple artifacts, such as application packages, infrastructure stacks, and server images.
プロジェクトとリポジトリの整理 プロジェクトは、システムの個別のコンポーネントを構築するために使用されるコードのコレクションです。単一のプロジェクトまたはそのコンポーネントが含めることができる量には厳密なルールはありません。たとえば、「スタックの構造に対するパターンとアンチパターン」では、インフラストラクチャのスタックのスコープの異なるレベルが説明されています。プロジェクトは、コードベース内の他のプロジェクトに依存する場合があります。理想的には、これらの依存関係とプロジェクト間の境界が明確に定義され、プロジェクトコードの組織化方法に明確に反映されます。コンウェイの法則（組織構造とそれが構築したシステムとの直接的な関係）は、チームの構造とシステムの所有権、およびそれらのシステムを定義するコードの整合性が不十分な場合には摩擦と非効率性を生み出すと言っています。プロジェクト間の境界を引くことの反対側は、Chapter 17 でスタックについて説明されるように、プロジェクト間の依存関係がある場合にプロジェクトを統合することです。「プロジェクトの統合」では、異なる依存関係がいつ、どのようにしてプロジェクトに統合されるかについて議論されています。
コードの組織化方法には 2 つの側面があります。1 つはさまざまなタイプのコードをどこに置くか、つまりスタック、サーバーの設定、サーバーのイメージ、構成、テスト、配信ツール、アプリケーションのためのコードです。もう 1 つは、ソースコードリポジトリ全体にわたってプロジェクトをどのように配置するかです。最後の質問は少し簡単ですので、まずそこから始めましょう。1 つのリポジトリか、複数のリポジトリか？複数のコードプロジェクトを持つ場合、ソースコントロールシステムの 1 つのリポジトリにまとめるか、複数のリポジトリに分散するかどうかを決める必要があります。複数のリポジトリを使用する場合、すべてのプロジェクトに独自のリポジトリを持たせるべきか、いくつかのプロジェクトを共有リポジトリにグループ化するべきかどうかを決める必要があります。いくつかのトレードオフの要素を考慮する必要があります。プロジェクトを異なるリポジトリに分割することで、コードレベルでの境界を維持しやすくなります。単一のリポジトリで複数のチームがコードを作業すると、オーバーヘッドが発生し、競合が発生する可能性があります。複数のリポジトリにコードを分散すると、それらをまたぐ変更の作業が複雑になる可能性があります。同じリポジトリに保存されるコードはバージョン管理され、一緒にブランチを作成することができますので、一部のプロジェクトの統合とデリバリー戦略が簡素化されます。Git、Perforce、Mercurial など、異なるソースコード管理システムには、複雑なシナリオをサポートするためのパフォーマンスと拡張性の特性が異なります。これらの要素を考慮に入れて、リポジトリ全体にわたってプロジェクトを組織化するための主なオプションを見てみましょう。
すべてのための 1 つのリポジトリ 一部のチームや大きな組織では、すべてのコードを 1 つのリポジトリで管理しています。これには、使用状況レベルにスケーリングできるソースコントロールシステムソフトウェアが必要です。一部のソフトウェアは、サイズ、履歴、ユーザー数、活動レベルの増加に伴い、コードベースを処理するのに苦労することがあります。したがって、リポジトリの分割はパフォーマンスの管理の問題となります。1 つのリポジトリを使用すると、使いやすくなります。人々は作業するために必要なすべてのプロジェクトをチェックアウトできるため、すべてのバージョンが一貫していることが保証されます。一部のバージョン管理ソフトウェアには、スパースチェックアウトのような機能があり、ユーザーはリポジトリのサブセットで作業することができます。
モノレポ - 1 つのリポジトリ、1 つのビルド 単一のリポジトリは、ビルドタイムの統合に適しています（「パターン：ビルドタイムプロジェクトの統合」を参照）。モノレポ戦略は、単一のリポジトリでメンテナンスされているプロジェクトに対してビルドタイムの統合パターンを使用します。モノレポの簡略化バージョンでは、リポジトリ内のすべてのプロジェクトがビルドされます（18-1 図を参照）。
これらのプロジェクトは一緒にビルドされますが、アプリケーションパッケージ、インフラストラクチャスタック、およびサーバーイメージなど、複数のアーティファクトを生成する場合があります。

- 考えまとめ
  - 会社で一つのリポジトリは難しそうだが，あるテーマごとにリポジトリをもつ，ぐらいがいいのでは？
