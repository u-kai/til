One repository, multiple builds Most organizations that keep all of their projects in a single repository don’t necessarily run a single build across them all. They often have a few different builds to build different subsets of their system (see Figure 18-2).
Often, these builds will share some projects. For instance, two different builds may use the same shared library (see Figure 18-3).
One pitfall of managing multiple projects is that it can blur the boundaries between projects. People may write code for one project that refers directly to files in another project in the repository. Doing this leads to tighter coupling and less visibility of dependencies. Over time, projects become tangled and hard to maintain, because a change to a file in one project can have unexpected conflicts with other projects. A Separate Repository for Each Project (Microrepo) Having a separate repository for each project is the other extreme (Figure 18-4).
This strategy ensures a clean separation between projects, especially when you have a pipeline that builds and tests each project separately before integrating them. If someone checks out two projects and makes a change to files across projects, the pipeline will fail, exposing the problem. Technically, you could use build-time integration across projects managed in separate repositories, by first checking out all of the builds (see Figure 18-5).
In practice, it’s more practical to build across multiple projects in a single repository, because their code is versioned together. Pushing changes for a single build to multiple repositories complicates the delivery
process. The delivery stage would need some way to know which versions of all of the involved repositories to check out to create a consistent build. Single-project repositories work best when supporting delivery-time and apply-time integration. A change to any one repository triggers the delivery process for its project, bringing it together with other projects later in the flow. Multiple Repositories with Multiple Projects While some organizations push toward one extreme or the other — single repository for everything, or a separate repository for each project — most maintain multiple repositories with more than one project (see Figure 18-6).
Often, the grouping of projects into repositories happens organically, rather than being driven by a strategy like monorepo or microrepo. However, there are a few factors that influence how smoothly things work.
One factor, as seen in the discussions of the other repository strategies, is the alignment of a project grouping with its build and delivery strategy. Keep projects in a single repository when they are closely related, and especially when you integrate the projects at build time. Consider separating projects into separate repositories when their delivery paths aren’t tightly integrated. Another factor is team ownership. Although multiple people and teams can work on different projects in the same repository, it can be distracting. Changelogs intermingle commit history from different teams with unrelated workstreams. Some organizations restrict access to code. Access control for source control systems is often managed by repository, which is another driver for deciding which projects go where. As mentioned for single repositories, projects within a repository more easily become tangled together with file dependencies. So teams might divide projects between repositories based on where they need stronger boundaries from an architectural and design perspective.

1つのリポジトリ、複数のビルド
すべてのプロジェクトを1つのリポジトリに保持している多くの組織は、必ずしもすべてのプロジェクトで単一のビルドを実行しているわけではありません。彼らは通常、システムの異なるサブセットをビルドするためにいくつかの異なるビルドを持っています（図18-2を参照）。
これらのビルドは、いくつかのプロジェクトを共有することがあります。たとえば、2つの異なるビルドが同じ共有ライブラリを使用することがあります（図18-3を参照）。
複数のプロジェクトを管理する際の注意点の1つは、プロジェクト間の境界が曖昧になる可能性があることです。リポジトリ内の別のプロジェクトのファイルを直接参照するコードを書くことがあります。これを行うと、密結合が生じ、依存関係の可視性が低下します。時間の経過とともに、プロジェクトは絡み合ってメンテナンスが困難になります。なぜなら、1つのプロジェクトのファイルの変更が他のプロジェクトと予期しない競合を引き起こす可能性があるからです。各プロジェクトに個別のリポジトリ（マイクロリポジトリ）を持つ
各プロジェクトに個別のリポジトリを持つ戦略は、別の極端です（図18-4を参照）。
この戦略は、パイプラインが各プロジェクトを個別にビルドしてテストし、それらを統合する前にいずれもチェックアウトする場合、プロジェクト間にきれいな分離を確保します。もし誰かが2つのプロジェクトをチェックアウトしてプロジェクト間のファイルを変更した場合、パイプラインは失敗し、問題が露呈します。技術的には、別々のリポジトリで管理されるプロジェクト間でビルド時の統合を使用することができますが、まずすべてのビルドをチェックアウトする必要があります（図18-5を参照）。
実際には、コードが共にバージョン管理されているため、単一のリポジトリで複数のプロジェクトをビルドする方が実用的です。1つのビルドの変更を複数のリポジトリにプッシュすることは、配信プロセスを複雑にします。配信段階では、関連するすべてのリポジトリのどのバージョンをチェックアウトして一貫したビルドを作成するかを知る必要があります。単一プロジェクトリポジトリは、配信時と適用時の統合をサポートする場合に最適です。1つのリポジトリに変更があると、そのプロジェクトの配信プロセスがトリガーされ、後続のフローで他のプロジェクトと統合されます。複数のプロジェクトを持つ複数のリポジトリ
一部の組織は、すべてのもののための単一のリポジトリ、またはプロジェクトごとの別々のリポジトリに向かって進む一方で、ほとんどの組織は複数のリポジトリに複数のプロジェクトを保持しています（図18-6を参照）。
プロジェクトをリポジトリにグループ化することは、単一リポジトリまたはマイクロリポジトリのような戦略によるものではなく、自然に起こることが多いです。ただし、うまく機能する要素がいくつかあります。
他のリポジトリ戦略の議論で見られるように、プロジェクトグループ化とビルド・デリバリー戦略の整合性は1つの要素です。関連性が強い場合やビルド時にプロジェクトを統合する場合は、プロジェクトを単一のリポジトリに保持します。デリバリーパスが緊密に統合されていない場合は、プロジェクトを別々のリポジトリに分けることを検討してください。もう1つの要素は、チームの所有権です。同じリポジトリで異なるプロジェクトに取り組むことができるが、それは注意散漫になるかもしれません。変更ログは、異なるチームのコミット履歴と関連のないワークストリームを混在させます。一部の組織では、コードへのアクセスを制限しています。ソースコントロールシステムのアクセス制御は、リポジトリごとに管理されることが多く、どのプロジェクトをどこに配置するかを決定するための別の要因となります。単一リポジトリの場合と同様に、リポジトリ内のプロジェクトはファイルの依存関係で絡み合いやすくなります。したがって、チームはアーキテクチャと設計の観点から境界を強化する必要がある場合、プロジェクトをリポジトリ間で分割することがあります。