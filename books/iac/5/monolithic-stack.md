Antipattern: Monolithic Stack A monolithic stack is an infrastructure stack that includes too many elements, making it difficult to maintain (see Figure 5-2). Figure 5-2. A monolithic stack is an infrastructure stack that includes too many elements, making it difficult to maintain What distinguishes a monolithic stack from other patterns is that the number or relationship of infrastructure elements within the stack is difficult to manage well. Motivation People build monolithic stacks because the simplest way to add a new element to a system is to add it to the existing project. Each new stack adds more moving parts, which may need to be orchestrated, integrated, and tested. A single stack is simpler to manage. For a modestly sized collection of infrastructure elements, a monolithic stack might make sense. But more often, a monolithic stack organically grows out of control. Applicability A monolithic stack may be appropriate when your system is small and simple. It’s not appropriate when your system grows, taking longer to provision and update. Consequences Changing a large stack is riskier than changing a smaller stack. More things can go wrong — it has a larger blast radius. The impact of a failed change may be broader since there are more services and applications within the stack. Larger stacks are also slower to provision and change, which makes them harder to manage. As a result of the speed and risk of changing a monolithic stack, people tend to make changes less frequently and take longer to do it. This added friction can lead to higher levels of technical debt. Blast Radius The immediate blast radius is the scope of code that the command to apply your change includes.2 For example, when you run terraform apply, the direct blast radius includes all of the code in your project. The indirect blast radius includes other elements of the system that depend on the resources in your direct blast radius, and which might be affected by breaking those resources. Implementation You build a monolithic stack by creating an infrastructure stack project and then continuously adding code, rather than splitting it into multiple stacks. Related patterns The opposite of a monolithic stack is a micro stack (see “Pattern: Micro Stack”), which aims to keep stacks small so that they are easier to maintain and improve. A monolithic stack may be an application group stack (see “Pattern: Application Group Stack”) that has grown out of control. Is My Stack a Monolith? Whether your infrastructure stack is a monolith is a matter of judgment. The symptoms of a monolithic stack include: It’s difficult to understand how the pieces of the stack fit together (they may be too messy to understand, or perhaps they don’t fit well together). New people take a while learning the stack’s codebase. Debugging problems with the stack is hard. Changes to the stack frequently cause problems. You spend too much time maintaining systems and processes whose purpose is to manage the complexity of the stack. A key indicator of whether a stack is becoming monolithic is how many people are working on changes to it at any given time. The more common it is for multiple people to work on the stack simultaneously, the more time you spend coordinating changes. Multiple teams making changes to the same stack is even worse. If you frequently have failures and conflicts when deploying changes to a given stack, it may be too large. Feature branching is a strategy for coping with this, but it can add friction and overhead to delivery. The habitual use of feature branches to work on a stack suggests that the stack has become monolithic. CI is a more sustainable way to make it safer for multiple people to work on a single stack. However, as a stack grows increasingly monolithic, the CI build takes longer to run, and it becomes harder to maintain good build discipline. If your team’s CI is sloppy, it’s another sign that your stack is a monolith. These issues relate to a single team working on an infrastructure stack. Multiple teams working on a shared stack is a clear sign to consider splitting it into more manageable pieces.
アンチパターン：モノリシックスタック モノリシックスタックは、管理が難しくなるほど多くの要素が含まれるインフラストラクチャスタックです（図5-2を参照）。図5-2.モノリシックスタックは、管理が難しいほど多くの要素が含まれるインフラストラクチャスタックである モノリシックスタックを他のパターンと区別するのは、スタック内のインフラストラクチャ要素の数や関係がうまく管理できないことです。動機 人々はモノリシックスタックを構築するのは、システムに新しい要素を追加する最も簡単な方法が既存のプロジェクトに追加することだからです。新しいスタックを追加すると、実行する必要がある動作が増え、それをオーケストレーション、統合、テストする必要があるかもしれません。単一のスタックの方が管理が簡単です。インフラストラクチャ要素の数が適度に少ない場合、モノリシックスタックは意味をなすかもしれません。しかし、より頻繁に、モノリシックスタックは制御を失って成長します。適用性 システムが小さくシンプルな場合、モノリシックスタックは適しているかもしれません。ただし、システムが成長し、プロビジョニングや更新に時間がかかる場合は適していません。結果 大きなスタックを変更することは、小さなスタックを変更するよりもリスクが高くなります。問題が発生する可能性があることがより多くなります-より広い範囲に波及します。変更の失敗の影響はより広範囲に及ぶ可能性があります。なぜなら、スタック内にはより多くのサービスやアプリケーションがあるからです。大きなスタックはプロビジョニングと変更が遅くなるため、管理が難しくなります。モノリシックスタックを変更する速度とリスクの結果、人々は変更をより頻繁に行わず、より長い時間がかかります。この追加の摩擦は、技術的負債のレベルを高める可能性があります。影響範囲 直接の影響範囲は、変更を適用するコードのスコープです。2たとえば、terraform applyを実行すると、直接の影響範囲にはプロジェクト内のすべてのコードが含まれます。間接の影響範囲には、直接の影響範囲のリソースに依存するシステムの他の要素が含まれており、これらのリソースを破壊する可能性があります。実装 1つのスタックに複数のスタックを分割する代わりに、モノリシックスタックはインフラストラクチャスタックプロジェクトを作成し、コードを連続的に追加して構築します。 関連パターン モノリシックスタックの対極はマイクロスタックです（"パターン：マイクロスタック"を参照）。このパターンは、スタックを小さく保ってメンテナンスと改善を容易にすることを目指しています。モノリシックスタックはアプリケーショングループスタック（"パターン：アプリケーショングループスタック"を参照）とも呼ばれることがありますが、これは制御を失って成長しました。 スタックがモノリシックかどうかは判断の問題です。モノリシックスタックの症状には次のようなものがあります：スタックの各部分がどのように組み合わさっているか理解するのが難しい（理解しづらいか、うまく組み合わさっていないかもしれません）。新しいメンバーがスタックのコードベースを学ぶのに時間がかかります。スタックのデバッグは困難です。スタックへの変更は頻繁に問題を引き起こします。スタックの複雑さを管理するためのシステムとプロセスの維持に余分な時間を費やしています。スタックがモノリシック化しているかどうかの鍵となる指標は、いつでもそれに変更を加えている人の数です。複数の人が同時にスタックに取り組むことがより一般的な場合、変更を調整するためにより多くの時間を費やすことになります。同じスタックに対して複数のチームが変更を加える場合はさらに悪化します。特定のスタックに変更をデプロイする際に頻繁な障害や競合が発生する場合、そのスタックは大きすぎる可能性があります。機能ブランチはこれに対処するための戦略ですが、デリバリーに摩擦とオーバーヘッドを追加する可能性があります。スタックで機能ブランチを頻繁に使用することは、スタックがモノリシック化していることを示しています。CIは、複数の人が単一のスタックで作業する際により持続可能な方法ですが、スタックがますますモノリシックになると、CIビルドの実行時間が長くなり、ビルドの規律を保つのが難しくなります。チームのCIが雑然としている場合は、スタックがモノリスである可能性があります。これらの問題は、1つのチームがインフラストラクチャスタックに取り組んでいる場合に関連します。複数のチームが共有スタックに取り組んでいる場合、それをより管理しやすい部分に分割することを検討する明確なサインです。