Configuring a New Server Instance This chapter has described what the elements of a server are, where they come from, ways to create a new server instance, and the value of prebuilding server images. The last piece of the server creation and provisioning process is applying automated server configuration code to new servers. There are several points in the process where you can do this, as illustrated in Figure 11-5. Figure 11-5. Where configuration can be applied in the server life cycle Configuration can be applied when creating the server image, when creating the server instance from the image, and when the server is running: Configuring a server image
You apply configuration when building a server image that will be used to create multiple server instances. Think of this as configuring one time, and using it many times. This is often called baking a server image. Configuring a new server instance You apply configuration when creating a new server instance. Think of this as configuring many times. This is sometimes called frying a server instance. Configuring a running server instance You apply configuration to a server that is already in use. One common reason to do this is to make a change, like applying security patches. Another reason is to revert any changes made outside the automated configuration to enforce consistency. Some teams also apply configuration to transform an existing server; for example, turning a web server into an application server. The last of these, configuring a running server instance, is usually done to change a server, which is the topic of Chapter 12. The first two are options for applying configuration when creating a new server, so are firmly in the scope of this chapter. The main question is determining the right time to apply configuration for a new server — frying it into each new server instance, or baking it into the server image? Frying a Server Instance As explained, frying a server involves applying configuration when you create the new server instance. You can take this to an extreme, keeping each server image to a bare minimum, and building everything specific to a given server into the live image. Doing this means new servers always have the latest changes, including system patches, the most recent software package versions, and up-to-date configuration options. Frying a server is an example of delivery-time integration (see “Pattern: Delivery-Time Project Integration”). This approach simplifies image management. There are not many images, probably only one for each combination of hardware and OS version used in the infrastructure — for example, one for 64-bit Windows 2019 and one each for 32-bit and 64-bit Ubuntu 18.x. The images don’t need to be updated very often, as there isn’t much on them that changes. And in any case, you can apply the latest patches when you provision each server.
Some teams I’ve been with have focused on frying early in our adoption of infrastructure automation. Setting up the tooling and processes for managing server images is a lot of effort. We put that work on our backlog to do after building our core infrastructure management. In other cases, frying makes sense because servers are highly variable. A hosting company I know lets customers choose from a large number of customizations for servers. The company maintains minimalist base server images and puts more effort into the automation that configures each new server. There are several potential issues with installing and configuring elements of a server when creating each instance. These include: Speed Activities that occur when building a server add to the creation time. This added time is a particular issue for spinning up servers to handle spikes in load or to recover from failures. Efficiency Configuring a server often involves downloading packages over the network from repositories. This can be wasteful and slow. For example, if you need to spin up 20 servers in a short time, having each one of them download the same patches and application installers is wasteful. Dependencies Configuring a server usually depends on artifact repositories and other systems. If any of these are offline or unreachable, you can’t create a new server. This can be especially painful in an emergency scenario where you need to rebuild a large number of servers quickly. In these situations, network devices or repositories may also be down, creating a complex ordered graph of which systems to restart or rebuild first to enable the next set of systems to come up. Baking Server Images At the other end of the server creation spectrum is configuring nearly everything into the server image. Building new servers is then very quick and straightforward since you only need to apply instance-specific configuration. Baking a server image is an example of build-time integration (see “Pattern: Build-Time Project Integration”).
You can see the advantages of baking from the disadvantages of frying. Baking configuration into server images is especially appropriate for systems that use a large number of similar server instances, and when you need to be able to create servers frequently and quickly. One challenge with baking server images is that you need to set up the tooling and automated processes to make it easy to update and roll out new versions. For example, if an important security patch is released for your operating system or for key packages that are baked into your server images, you want to be able to build new images and roll them out to your existing servers quickly and with minimal disruption. Doing this is covered in Chapter 13. Another issue with baking server images is speed. Even with a mature automated process for updating images, it can take many minutes — 10 to 60 minutes is common — to build and release a new image. You can mitigate this by rolling changes out to running servers (the topic of Chapter 12), or by having a process that combines baking and frying. Combining Baking and Frying In practice, most teams use a combination of baking and frying to configure new servers. You can balance which activities to configure into server images, and which to apply when creating a server instance. You may apply some configuration elements at both parts of the process. The main considerations for deciding when is the right time to apply a particular configuration are the time it takes and the frequency of change. Things that take longer to apply, and which change less often, are clear candidates for baking into the server image. For example, you can install application server software on a server image, making it much quicker to spin up multiple server instances and saving network bandwidth in the process. On the flip side of this trade-off, something that is quicker to install, or changes more often, is better to fry. An example of this is applications developed in-house. One of the most common use cases for spinning up new servers on demand is testing as part of a software release process.
Highly productive development teams may push a dozen or more new builds of their application every day, relying on a CI process to automatically deploy and test each build. Baking a new server image for each new application build is too slow for this kind of working pace, so it’s more efficient to deploy the application when creating the test server. Another way that teams combine baking and frying is to bake as much as possible onto server images, but to fry updated versions. A team may bake updated server images at a slower pace; for example, weekly or monthly. When they need to update something that they usually bake onto the image, such as a security patch or configuration improvement, they can put this into the server creation process to fry it on top of the baked image. When the time comes to bake an updated image, they fold the updates into it and remove it from the creation process. This method lets the team incorporate new changes quickly, with less overhead. Teams often use this in combination with continuously applying code (see “Pattern: Continuous Configuration Synchronization”) to update existing servers without rebuilding them. Applying Server Configuration When Creating a Server Most of the tooling used to create servers in the ways discussed earlier (see “Creating a New Server Instance”), whether a command-line tool, platform API call, or a stack management tool, provides a way to apply server configuration code. For example, a stack management tool should have syntax to support popular tools, or to run arbitrary commands on a new server instance, as with Example 11-3. Example 11-3. Stack code that runs my fictional server configuration tool server:
source_image: stock-linux-1.23
memory: 2GB
vnet: ${APPSERVER_VNET}
configure:
tool: servermaker
code_repo: servermaker.shopspinner.xyz
server_role: appserver
parameters:
app_name: catalog_service
app_version: 1.2.3 This code runs the Servermaker tool, passing it the hostname of the server that hosts server configuration code, the role to apply to the server (appserver), and some parameters to pass to the server configuration code (app_name and app_version). Some tools also allow you to embed server configuration code directly into the code for the stack, or shell commands to execute. It can be tempting to use this to implement the server configuration logic, and for simple needs, this may be fine. But in most cases, this code grows in size and complexity. So it’s better to extract the code to keep your codebase clean and maintainable.
新しいサーバーインスタンスの設定 この章では、サーバーの要素、その出所、新しいサーバーインスタンスを作成する方法、およびプリビルドされたサーバーイメージの価値について説明しました。サーバーの作成および設定プロセスの最後の部分は、自動化されたサーバー構成コードを新しいサーバーに適用することです。図11-5に示すように、このプロセスではいくつかのポイントでこの作業を行うことができます。 図11-5. サーバーライフサイクルで構成が適用できる場所 サーバーイメージの設定 サーバーイメージを作成する際に設定を適用します。これは一度の設定を行い、それを複数回使用すると考えてください。これはしばしばサーバーイメージを作ることと呼ばれます。 新しいサーバーインスタンスの設定 新しいサーバーインスタンスを作成する際に設定を適用します。これは複数回の設定を行うと考えてください。これはしばしばサーバーインスタンスを作ることと呼ばれます。 実行中のサーバーインスタンスの設定 既に使用されているサーバーに設定を適用します。これを行う一般的な理由としては、セキュリティパッチの適用などの変更を行うためです。また、自動化された構成外で行われた変更を元に戻し、一貫性を確保するために設定を適用する場合もあります。一部のチームでは、既存のサーバーを変換するためにも構成を適用します。例えば、ウェブサーバーからアプリケーションサーバーに変換する場合などです。 最後の「実行中のサーバーインスタンスの設定」は通常、サーバーを変更するために行われることが多く、これは第12章のトピックです。最初の2つは新しいサーバーを作成する際に構成を適用するためのオプションであり、したがってこの章の範囲内です。メインの質問は、新しいサーバーに設定を適用する適切なタイミングはいつか、それを各新しいサーバーインスタンスに焼き付けるか、サーバーイメージに焼き付けるかですか？ サーバーインスタンスを作成する際の設定 説明したように、サーバーを作成する際には設定を適用します。これを極限まで推し進めると、各サーバーイメージを最小限に保ち、特定のサーバーに固有のすべてをイメージに組み込むことになります。これにより、新しいサーバーは常に最新の変更、システムパッチ、最新のソフトウェアパッケージのバージョン、最新の設定オプションを含むようになります。サーバーを焼くというのは、「パターン：デリバリータイムプロジェクトの統合」の例です。このアプローチはイメージの管理を単純化します。イメージは多くはありません。インフラストラクチャで使用されるハードウェアとOSバージョンの組み合わせごとにおそらく1つだけです。例えば、64ビットWindows 2019用の1つ、32ビットおよび64ビットUbuntu 18.x用の1つずつです。イメージはあまり頻繁に更新する必要はありません。変更される要素はあまりありません。何かしらの変更を適用する必要がある場合は、各サーバーをプロビジョニングする際に最新のパッチを適用することができます。 私が所属しているチームのいくつかは、インフラストラクチャの自動化を導入する段階では焼き付けに力を入れてきました。サーバーイメージの管理のためのツールとプロセスの設定は大変な作業です。私たちはこの作業をバックログに追加して、基本的なインフラストラクチャ管理の構築後に行うようにしました。他の場合では、焼き付けが意味があります。ホスティング会社では、顧客が多くのカスタマイズオプションから選べるようになっています。会社ではミニマリストな基本サーバーイメージを保守し、新しいサーバーの設定に更なる努力を注いでいます。サーバーの各新しいインスタンスに設定を適用することは、サーバーイメージを焼くことの一例です。 サーバーの要素のインストールと構成を各インスタンス作成時に行う方法には、いくつかの潜在的な問題があります。これには以下のものが含まれます： 速度 サーバーを構築する際に行われるアクティビティは、作成時間に追加の負荷をかけます。これは特に負荷の急増や障害からの回復にサーバーを立ち上げる際に問題となります。 効率 サーバーの設定には、ネットワーク経由でのパッケージのダウンロードなどが含まれることが多いです。これは無駄で遅い場合があります。例えば、短時間で20台のサーバーを立ち上げる必要がある場合、それぞれのサーバーが同じパッチとアプリケーションインストーラをダウンロードするのは無駄です。 依存関係 サーバーの設定には通常、アーティファクトのリポジトリや他のシステムへの依存があります。これらがオフラインまたは接続できない場合、新しいサーバーを作成することはできません。特に緊急のシナリオで多数のサーバーを急速に再構築する必要がある場合は、これは非常に困難です。このような状況では、ネットワークデバイスやリポジトリもダウンしている可能性があるため、再起動や再構築するターゲットシステムの複雑な順序付きのグラフを作成することになります。 サーバーイメージの焼き付け サーバー作成スペクトラムのもう一方の端には、ほぼすべての設定をサーバーイメージに組み込むことです。その後、新しいサーバーを非常に迅速かつ簡単に構築できるようになります。なぜなら、インスタンス固有の設定を適用するだけで済むからです。サーバーイメージへの焼き付けは、「