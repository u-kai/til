Testing Server Code Chapter 8 explained how automated testing and CD theory applies to infrastructure, and Chapter 9 described approaches for implementing this with infrastructure stacks. Many of the concepts in both of those chapters apply to testing server code. Progressively Testing Server Code There is a self-reinforcing dynamic between code design and testing. It’s easier to write and maintain tests for a cleanly structured codebase. Writing tests, and keeping them all passing, forces you to maintain that clean structure. Pushing every change into a pipeline that runs your tests helps your team keep the discipline of continuously refactoring to minimize technical debt and design debt. The structure described earlier, of server roles composed of server configuration modules, which may themselves be organized into library modules and application modules, aligns nicely to a progressive testing strategy (see “Progressive Testing”). A series of pipeline stages can test each of these in increasing stages of integration, as shown in Figure 11-3. Figure 11-3. Progressively testing server code modules A separate stage tests each code module whenever someone commits a change to that module. The server role also has a test stage. This stage runs the tests whenever one of the modules used by the role changes and passes its own stage. The role-testing
stage also runs when someone commits a change to the role code, for example adding or removing a module, or changing a parameter. What to Test with Server Code It’s tricky to decide what to test with server code. This goes back to the question of whether there’s any value in testing declarative code (see “Challenge: Tests for Declarative Code Often Have Low Value”). Server code modules, especially in a well-designed codebase, tend to be small, simple, and focused. A module that installs a Java JVM, for example, may be a single statement, with a few parameters: package:
name: java-${JAVA_DISTRIBUTION}
version: ${JAVA_VERSION} In practice, even simple-seeming package installation modules may have more code than this, customizing file paths, configuration files, and perhaps adding a user account. But there’s often not much to test that doesn’t simply restate the code itself. Tests should focus on common issues, variable outcomes, and combinations of code. Consider common issues, things that tend to go wrong in practice, and how to sanity check. For a simple package installation, you might want to check that the command is available in the default user path. So a test would invoke the command, and make sure it was executed: given command 'java -version' {
its(exit_status) { should_be 0 }
} If the package may have radically different outcomes depending on the parameters passed to it, you should write tests to assure you that it behaves correctly in different cases. For the JVM installation package, you could run the test with different values for the Java distribution, for example making sure that the java command is available no matter which distribution someone chooses. In practice, the value of testing is higher as you integrate more elements. So you may write and run more tests for the application server role than for the modules the role includes.
This is especially true when those modules integrate and interact with one another. A module that installs Tomcat isn’t likely to clash with one that installs a monitoring agent, but a security hardening module might cause an issue. In this case, you may want to have tests that run on the application server role, to confirm that the application server is up and accepting requests even after ports have been locked down. How to Test Server Code Most automated server code tests work by running commands on a server or container instance, and checking the results. These tests may assert the existence and status of resources, such as packages, files, user accounts, and running processes. Tests may also look at outcomes; for example, connecting to a network port to prove whether a service returns the expected results. Popular tools for testing conditions on a server include Inspec, Serverspec, and Terratest. The strategies for testing full infrastructure stacks include running tests offline and online (see “Offline Testing Stages for Stacks” and “Online Testing Stages for Stacks”). Online testing involves spinning things up on the infrastructure platform. You can normally test server code offline using containers or local virtual machines. An infrastructure developer working locally can create a container instance or local VM with a minimal operating system installation, apply the server configuration code, and then run the tests. Pipeline stages that test server code can do the same, running the container instance or VM on the agent (for example, the Jenkins node running the job). Alternatively, the stage could spin up a standalone container instance on a container cluster. This works well when the pipeline orchestration is itself containerized. You can follow the guidance for stacks to orchestrate server code testing (see “Test Orchestration”). This includes writing scripts that set up the testing prerequisites, such as container instances, before running the tests and reporting results. You should run the same scripts to test locally that you use to test from your pipeline service, so the results are consistent.
サーバーコードのテストには、自動化されたテストとCD（継続的デリバリー）の理論がインフラストラクチャにどのように適用されるかを説明した、Testing Server Code Chapter 8と、そのインフラストラクチャスタックにこれを実装するためのアプローチを説明したChapter 9の内容があります。これらの章で説明されている多くの概念は、サーバーコードのテストにも適用されます。

サーバーコードのテストは、コードの設計とテストの間に自己強化的な動的があります。クリーンな構造のコードベースに対しては、テストを書き、メンテナンスすることが容易です。テストを書き、それらをすべて合格させることで、クリーンな構造を維持する必要が生じます。テストを実行するパイプラインにすべての変更をプッシュすることは、技術的負債と設計負債を最小限に抑えるために、継続的なリファクタリングの規律をチームに保つのに役立ちます。サーバーロールがサーバー構成モジュールで構成される構造（ライブラリモジュールやアプリケーションモジュールに組織化されることもあります）は、プログレッシブなテスト戦略にうまく適合します（「プログレッシブテスト」を参照）。

図11-3に示すように、一連のパイプラインステージでは、統合の段階を徐々に上げながら、それぞれをテストすることができます。各コードモジュールごとに別個のステージがあります。モジュールに変更がコミットされるたびに、それぞれのモジュールに対してテストが実行されます。サーバーロールにもテストステージがあります。このステージでは、ロールが使用するモジュールのいずれかが変更され、自身のステージをパスした場合に、テストが実行されます。ロールコードに変更がコミットされた場合にも、ロールテストステージは実行されます。たとえば、モジュールの追加や削除、パラメータの変更などです。

サーバーコードで何をテストするかを決めるのは難しいです。これは、宣言的なコードのテストに価値があるのかどうかという問題にさかのぼります（「課題：宣言的コードのテストはしばしば低い価値を持つ」を参照）。特に、設計が優れたコードベースでは、サーバーコードモジュールは小さく、シンプルで焦点が絞られています。例えば、Java JVMをインストールするモジュールは、パッケージ名とバージョンなどのパラメータを指定した1つの文である場合があります。

実際には、このようなシンプルな見た目のパッケージインストールモジュールには、ファイルパスのカスタマイズ、設定ファイルのカスタマイズ、ユーザーアカウントの追加など、この以上のコードが含まれる場合があります。しかし、コード自体を単純に再述するだけのテスト以外にあまりテストすることはありません。テストは一般的な問題、可変な結果、コードの組み合わせに焦点を当てるべきです。実際のインストールパッケージの場合、デフォルトのユーザーパスでコマンドが利用可能かどうかをチェックするために、テストがコマンドを実行し、実行されたことを確認する必要があります。

パッケージによっては、パラメータによって大きく異なる結果が生じる場合もありますので、異なるケースで正しく機能することを確認するためのテストを書く必要があります。JVMインストールパッケージの場合、Javaのディストリビューションに対して異なる値でテストを実行して、どのディストリビューションを選んでもjavaコマンドが利用可能であることを確認することができます。

実際に統合する要素が多くなるほど、テストの価値は高くなります。したがって、アプリケーションサーバーロールのモジュールよりも、アプリケーションサーバーロール自体に対してより多くのテストを書き、実行することがあります。特に、それらのモジュールが統合し、相互作用する場合にはこれが当てはまります。Tomcatをインストールするモジュールは、モニタリングエージェントをインストールするモジュールと衝突する可能性は低いですが、セキュリティの強化モジュールは問題を引き起こす可能性があります。この場合、ポートがロックされた後でもアプリケーションサーバーが起動しリクエストを受け入れることを確認するために、アプリケーションサーバーロールで実行されるテストが必要になる場合があります。

ほとんどの自動化されたサーバーコードのテストは、サーバーまたはコンテナインスタンスでコマンドを実行し、結果を確認することで動作します。これらのテストでは、パッケージ、ファイル、ユーザーアカウント、実行中のプロセスなどのリソースの存在とステータスをアサートすることがあります。テストはまた、結果を確認することもあります。たとえば、期待される結果が返されるかどうかを証明するために、ネットワークポートに接続することが考えられます。サーバーの条件をテストするための人気のあるツールには、Inspec、Serverspec、Terratestなどがあります。インフラストラクチャスタックをテストするための戦略には、オフラインテストおよびオンラインテストが含まれます（「スタックのオフラインテスト段階」と「スタックのオンラインテスト段階」を参照）。

オンラインテストでは、インフラストラクチャプラットフォーム上でものを立ち上げることが必要です。通常、サーバーコードをオフラインでテストするには、コンテナまたはローカル仮想マシンを使用することができます。ローカルで作業しているインフラストラクチャ開発者は、最小限のオペレーティングシステムのインストールが行われたコンテナインスタンスまたはローカル仮想マシンを作成し、サーバー構成コードを適用し、その後テストを実行することができます。サーバーコードをテストするパイプラインステージも同様に行うことができます。エージェント（たとえば、ジョブを実行しているJenkinsノード）でコンテナインスタンスまたはVMを実行するか、コンテナクラスター上で単独のコンテナインスタンスを起動するかが、ステージによって異なります。この方法は、パイプラインオーケストレーション自体がコンテナ化されている場合にうまく機能します。サーバーコードのテストをオーケストレーションするために、スタックのガイダンスに従うことができます（「テストオーケストレーション」を参照）。これには、テストの前提条件（たとえばコンテナインスタンス）を設定するためのスクリプトを書くことが含まれます。テストおよび結果の報告前にこれらのスクリプトを実行する必要があります。ローカルでテストするために使用するスクリプトとパイプラインサービスからテストするために使用するスクリプトは同じものを実行する必要があります。これにより、結果が一貫性のあるものになります。