Small Changes The biggest messes I’ve made in code were when I built up too much work locally before pushing. It’s tempting to focus on completing the full piece of work that you have in mind. It’s harder to make a small change that only takes you a little further toward that full thing. Implementing large changes as a series of small changes requires a new mindset and new habits. Fortunately, the software development world has shown the path. I’ve included many of the techniques that support building systems a piece at a time throughout this book, including TDD, CI, and CD. Progressively testing and delivering code changes using a pipeline, as described in Chapter 8 and referenced throughout the book, is an enabler. You should be able to make a small change to your code, push it, get feedback on whether it works, and put it into production. Teams that use these techniques effectively push changes very frequently. A single engineer may push changes every hour or so, and each change is integrated into the main codebase and tested for production readiness in a fully integrated system. People knock around various terms and techniques for making a significant change as a series of small changes: Incremental An incremental change is one that adds one piece of the planned implementation. You could build the example ShopSpinner system incrementally by implementing one stack at a time. First, create the shared networking stack. Then, add the web cluster stack. Finally, build the application infrastructure stack. Iterative
An iterative change makes a progressive improvement to the system. Start building the ShopSpinner system by creating a basic version of all three stacks. Then make a series of changes, each one expanding what the stacks can do. Walking skeleton A walking skeleton is a basic implementation of the main parts of a new system that you implement to help validate its general design and structure.2 People often create a walking skeleton for an infrastructure project along with similar initial implementations of applications that will run on it, so teams can see how delivery, deployment, and operations might work. The initial implementation and selection of tools and services for the skeleton are often not the ones that are planned for the long term. For example, you might plan to use a full-featured monitoring solution, but build your walking skeleton using more basic services provided out of the box by your cloud provider. Refactoring Refactoring involves changing the design of a system, or a component of the system, without changing its behavior. Refactoring is often done to pave the way for changes that do change behavior.3 A refactoring might improve the clarity of the code so that it’s easier to change, or it might reorganize the code so that it aligns with planned changes. Example of Refactoring

小さな変更 私がコードで最も大きな混乱を引き起こしたのは、プッシュする前にローカルであまりにも多くの作業を積み上げた時でした。頭に描いている作業の全体を完成させることに集中することは魅力的です。その全体に少し近づくだけの小さな変更をすることは難しいです。大きな変更を小さな変更の連続として実装するには、新しい考え方と新しい習慣が必要です。幸いなことに、ソフトウェア開発の世界はその道を示しています。私はこの本全体でシステムを一つずつ構築するための多くの技術を紹介しています。TDD、CI、CDなどを含んでいます。第8章で説明され、本全体で参照されているように、パイプラインを使用してコードの変更を段階的にテストし、配信することは能力を高めるものです。あなたはコードに小さな変更を加えて、それをプッシュし、それが機能するかどうかのフィードバックを得て、本番環境に入れることができるはずです。これらの技術を効果的に使用するチームは、非常に頻繁に変更をプッシュします。個々のエンジニアは1時間ごとに変更をプッシュすることもあり、それぞれの変更はメインのコードベースに統合され、本番適用のテストが完了した統合システムでテストされます。一連の小さな変更として重要な変更を行うためのさまざまな用語や技法があります。逐次的な変更は、計画された実装に1つの要素を追加する変更です。例えば、ShopSpinnerシステムの例を示すスタックを1つずつ実装していくことで、逐次的な変更を行うことができます。まず、共有ネットワーキングスタックを作成します。次に、Webクラスタースタックを追加します。最後に、アプリケーションインフラストラクチャースタックを作成します。反復的な変更は、システムに漸進的な改善を加える変更です。ShopSpinnerシステムの構築を開始するには、すべての3つのスタックの基本バージョンを作成します。そして、各変更を行い、スタックができることを拡張していきます。歩行骨格は、新しいシステムの主要なパーツの基本的な実装であり、その一般的なデザインと構造を検証するために実装されるものです。インフラのプロジェクトのために、歩行骨格を作成する人々は、それを実行するアプリケーションと同様の最初期の実装も作成し、配信、展開、運用の方法をチームが確認できるようにします。最初期の実装や歩行骨格に使用するツールやサービスの選択は、通常は長期的に計画されているものとは異なるものです。例えば、高機能なモニタリングソリューションを使用する予定かもしれませんが、歩行骨格はクラウドプロバイダーによって提供される基本的なサービスを使用して作成されます。リファクタリングは、システムまたはシステムのコンポーネントの設計を変更することで、その振る舞いを変更しない変更です。リファクタリングは、振る舞いを変更する変更のための道筋を整えるために行われることがよくあります。リファクタリングによって、コードの明瞭さが向上し、変更が容易になる場合もありますし、計画された変更に合わせてコードを再編成する場合もあります。