Continuity by Preventing Errors As mentioned, Iron Age approaches to governing changes were mainly preventative. Because the cost of fixing a mistake was high, organizations invested heavily in preventing mistakes. Because changes were mainly manual, prevention involved restricting who could make changes. People needed to plan and design
changes in detail, and other people exhaustively reviewed and discussed each change. The idea was that having more people take more time to consider a change ahead of time would catch mistakes. One problem with this approach is the gap between design documents and implementation. Something that looks simple in a diagram can be complicated in reality. People make mistakes, especially when carrying out substantial, infrequent upgrades. The result is that traditional low-frequency, highly planned large batch change operations have a high failure rate, and often lengthy recovery times. The practices and patterns described throughout this book aim to prevent errors without sacrificing the frequency and speed of change. Changes defined as code represent their implementation better than any diagram or design document possibly can. Continuously integrating, applying, and testing changes as you work proves their readiness for production. Using a pipeline to test and deliver changes ensures steps aren’t skipped, and enforces consistency across environments. This reduces the likelihood of failures in production. The core insight of Agile software development and Infrastructure as Code is to flip the attitude toward change. Rather than fearing change and doing it as little as possible, you can prevent errors by making changes frequently. The only way to get better at making changes is to make changes frequently, continuously improving your systems and processes. Another key insight is that as systems become more complex, our ability to replicate and accurately test how code will behave in production shrinks. We need to stay aware of what we can and cannot test before production, and how to mitigate risks by improving our visibility of production systems (see “Testing in Production”).

Continuity by Fast Recovery The practices described so far in this chapter can reduce downtime. Limiting the size of changes, making them incrementally, and testing changes before production can lower your change failure rate. But it’s unwise to assume that errors can be prevented entirely, so we also need to be able to recover quickly and easily.
The practices advocated throughout this book make it easy to rebuild any part of your system. Your system is composed of loosely coupled components, each defined as idempotent code. You can easily repair, or else destroy and rebuild, any component instance by reapplying its code. You’ll need to ensure the continuity of data hosted on a component if you rebuild it, which is discussed in “Data Continuity in a Changing System”. In some cases, your platform or services can automatically rebuild failed infrastructure. Your infrastructure platform or application runtime destroys and rebuilds individual components when they fail a health check. Continuously applying code to instances (“Apply Code Continuously”) automatically reverts any deviation from the code. You can manually trigger a pipeline stage (“Infrastructure Delivery Pipelines”) to reapply code to a broken component. In other failure scenarios, these systems might not automatically fix a problem. A compute instance might malfunction in such a way that it still passes its health check. An infrastructure element might stop working correctly while still matching the code definition, so reapplying the code doesn’t help. These scenarios need some kind of additional action to replace failed components. You might flag a component so that the automated system considers it to be failed, and destroys and replaces it. Or, if recovery uses a system that reapplies code, you might need to destroy the component yourself and allow the system to build a new instance. For any failure scenario that needs someone to take an action, you should make sure to have tools, scripts, or other mechanisms that are simple to execute. People shouldn’t need to follow a sequence of steps; for example, backing up data before destroying an instance. Instead, they should invoke an action that carries out all of the required steps. The goal is that, in an emergency, you don’t need to think about how to correctly recover your system.
エラーを防ぐことによる連続性
前述のように、鉄器時代の統治の変化に対するアプローチは主に予防的なものでした。間違いを修正するコストが高いため、組織は間違いを防ぐために多額の投資をしました。変更が主に手作業だったため、予防には誰が変更を行うことができるかを制限することが含まれていました。人々は変更を詳細に計画し、設計する必要があり、他の人々は各変更を徹底的にレビューし、議論しました。その考え方は、変更を事前に考慮するためにより多くの人々がより多くの時間をかけることで、間違いを見つけ出すことができるというものでした。このアプローチの問題の一つは、設計書と実装のギャップです。図解で簡単に見えるものも、現実では複雑になる場合があります。人々は、特に大規模な、まれなアップグレードを行う際には、間違いを com\tt{・・・・・}やります。その結果、従来の低頻度で、高度に計画された大規模な一括変更作業は、高い失敗率としばしば長い回復時間を持っています。本書全体で説明されている実践とパターンは、エラーを防止し、変更の頻度と速度を犠牲にせず、目指しています。コードとして定義された変更は、どの図解や設計書よりも実装を表現しています。作業中に変更を持続的に統合し、適用し、テストすることで、その準備が本番に利用できることが証明されます。変更をテストし、配信するためにパイプラインを使用することで、ステップが飛ばされることなく、環境全体での一貫性が強制されます。これにより、本番での障害の可能性が低下します。アジャイルソフトウェア開発とインフラストラクチャコードの中心的な洞察は、変化への態度を変えることです。可能な限り変化を恐れずに、頻繁に変更することでエラーを防ぐことができます。変更をうまく行うためには、頻繁に変更を行い、システムやプロセスを絶えず改善することが唯一の方法です。もう一つの重要な洞察は、システムが複雑になるにつれて、プロダクションでのコードの振る舞いを再現し正確にテストする能力が縮小するということです。本番前に何をテストできるか、できないかを常に意識し、プロダクションシステムの可視性を向上させることにより、リスクを軽減する必要があります（「本番でのテスト」を参照）。

迅速な回復による連続性
この章で説明されている実践では、ダウンタイムを削減することができます。変更のサイズを制限し、段階的に行い、本番前にテストを行うことで変更の失敗率を低くすることができます。しかし、エラーを完全に防ぐことはできないという前提は危険ですので、迅速かつ簡単に回復する必要もあります。
この本で提唱されている実践により、システムの任意の部分を簡単に再構築することができます。システムは緩く結合されたコンポーネントで構成されており、それぞれが恒等的なコードとして定義されています。コンポーネントのインスタンスは、そのコードを再適用することで簡単に修復したり、破棄して再構築したりすることができます。再構築する際には、コンポーネントにホストされているデータの連続性を確保する必要がありますが、これについては「変化するシステムにおけるデータの連続性」で説明されています。一部の場合では、インフラストラクチャが自動的に失敗したインフラストラクチャを再構築することができる場合もあります。インフラストラクチャプラットフォームやアプリケーションランタイムは、ヘルスチェックに合格しなかった場合に個々のコンポーネントを破棄し、再構築します。コードを連続的に適用することにより（「コードの連続適用」）、コードからの逸脱を自動的に元に戻すことができます。壊れたコンポーネントにコードを再適用するためにパイプラインステージを手動でトリガーすることもできます（「インフラストラクチャデリバリーパイプライン」）。他の障害シナリオでは、これらのシステムが問題を自動的に修正しない場合もあります。計算インスタンスは、ヘルスチェックに合格しながらも正常に機能しない場合があります。インフラストラクチャ要素は、コード定義に一致しながら正常に動作しない場合があり、したがって、コードを再適用しても助けになりません。これらのシナリオには、失敗したコンポーネントを置き換えるための追加のアクションが必要です。自動システムで失敗したコンポーネントとしてマークし、破棄して置き換えるように指示することができます。または、回復にコードを再適用するシステムを使用する場合、コンポーネントを手動で破棄し、システムに新しいインスタンスを構築させる必要があります。アクションを実行するためのツール、スクリプト、またはその他のメカニズムが容易に実行できるようにする必要があります。人々は手順のシーケンスを追う必要はありません。例えば、インスタンスを破棄する前にデータをバックアップするなどは必要ありません。代わりに、必要なすべての手順を実行するアクションを呼び出すべきです。目標は、緊急時にシステムを正しく回復する方法を考える必要がないようにすることです。

- 今は間違いをすぐに冒しても修正が簡単
  - じゃあ早くやろうよってことかいな
- コードの連続的適用っていうのは GitOps に近い感じか
- でもコードそのものが悪かったら意味ないよね的な
  - やはりリポジトリには動くコード以外は置いちゃいけないな
