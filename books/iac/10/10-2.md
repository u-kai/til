This example defines inbound and outbound connections, referencing other parts of the system. These are the public internet, presumably a gateway, and inbound HTTPS ports for application servers, defined and deployed to the same cluster using their own deployment manifests. Application runtimes provide many common services to applications. Many of these services are types of service discovery. Service Discovery Applications and services running in an infrastructure often need to know how to find other applications and services. For example, a frontend web application may send requests to a backend service to process transactions for users. Doing this isn’t difficult in a static environment. Applications may use a known hostname for other services, perhaps kept in a configuration file that you update as needed. But with a dynamic infrastructure where the locations of services and servers are fluid, a more responsive way of finding services is needed. A few popular discovery mechanisms are: Hardcoded IP addresses Allocate IP addresses for each service. For example, the monitoring server always runs on 192.168.1.5. If you need to change the address or run multiple instances of a service (for example, for a controlled rollout of a major upgrade), you need to rebuild and redeploy applications. Hostfile entries Use server configuration to generate the /etc/hosts file (or equivalent) on each server, mapping service names to the current IP address. This method is a messier alternative to DNS, but I’ve seen it used to work around legacy DNS implementations.7 DNS (Domain Name System) Use DNS entries to map service names to their current IP address, either using DNS entries managed by code, or DDNS (Dynamic DNS). DNS is a mature, well-supported solution to the problem. Resource tags Infrastructure resources are tagged to indicate what services they provide, and the context such as environments. Discovery involves using the platform API to look up resources with relevant tags. Care should be taken to avoid coupling application code to the infrastructure platform. Configuration registry Application instances can maintain the current connectivity details in a centralized registry (see “Configuration Registry”), so other applications can look it up. This may be helpful when you need more information than the address; for example, health or other status indications. Sidecar A separate process runs alongside each application instance. The application may use the sidecar as a proxy for outbound connections, a gateway for inbound connections, or as a lookup service. The sidecars will need some method to do network discovery itself. This method could be one of the other discovery mechanisms, or it might use a different communication protocol.8 Sidecars are usually part of a service mesh ( I discuss service meshes in “Service Mesh”), and often provide more than service discovery. For example, a sidecar may handle authentication, encryption, logging, and monitoring. API gateway An API gateway is a centralized HTTP service that defines routes and endpoints. It usually provides more services than this; for example, authentication, encryption, logging, and monitoring. In other words, an API gateway is not unlike a sidecar, but is centralized rather than distributed.9 Avoid Hard Boundaries Between Infrastructure, Runtime, and Applications In theory, it could be useful to provide application runtimes as a complete set of services to developers, shielding them from the details of the underlying infrastructure. In practice, the lines are much fuzzier than presented in this model. Different people and teams need access to resources at different levels of abstraction, with different levels of control. So you should not design and implement systems with absolute boundaries, but instead define pieces that can be composed and presented in different ways to different users. Conclusion The purpose of infrastructure is to run useful applications and services. The guidance and ideas in this book should help you in providing collections of infrastructure resources in the shapes needed to do this. An application-driven approach to infrastructure focuses on the runtime requirements of applications, helping you to design stacks, servers, clusters, and other middle-tier constructs for running applications.
この例では、他のシステムの一部を参照しながらインバウンドとアウトバウンドの接続を定義しています。これらは公共のインターネット、おそらくはゲートウェイ、そしてアプリケーションサーバーのインバウンドHTTPSポートであり、それぞれのデプロイマニフェストを使用して同じクラスタに定義され、展開されます。アプリケーションランタイムは、アプリケーションに多くの共通のサービスを提供します。これらのサービスの多くは、サービスディスカバリのタイプです。インフラストラクチャで実行されるアプリケーションやサービスは、しばしば他のアプリケーションやサービスを見つける方法を知る必要があります。たとえば、フロントエンドのWebアプリケーションは、ユーザーのトランザクションを処理するためにバックエンドのサービスにリクエストを送信するかもしれません。これは静的な環境では困難ではありません。アプリケーションは、他のサービスの既知のホスト名を使用することがありますが、必要に応じて更新する構成ファイルに保持されます。しかし、サービスやサーバーの場所が可動的な動的なインフラストラクチャの場合、より迅速なサービスの検索方法が必要です。いくつかの一般的なディスカバリメカニズムは次のとおりです： 
- ハードコードされたIPアドレスは、各サービスにIPアドレスを割り当てます。たとえば、監視サーバーは常に192.168.1.5で実行されます。アドレスを変更したり、サービスの複数のインスタンスを実行する場合（たとえば、重要なアップグレードの管理された展開のため）、アプリケーションを再構築および再デプロイする必要があります。 
- ホストファイルエントリは、サーバーの設定を使用して、各サーバーの/etc/hostsファイル（または同等のファイル）を生成し、サービス名を現在のIPアドレスにマッピングします。このメソッドはDNSのより複雑な代替手段ですが、古いDNSの実装回避策として使用されることもあります。 
- DNS（Domain Name System）は、DNSエントリを使用してサービス名を現在のIPアドレスにマッピングします。これは、コードによって管理されるDNSエントリまたはDDNS（Dynamic DNS）を使用します。DNSは、問題の解決において成熟した、よくサポートされた解決策です。 
- リソースタグは、インフラストラクチャリソースにタグを付けて、それらが提供するサービスと環境などのコンテキストを示します。ディスカバリでは、関連するタグを持つリソースをプラットフォームAPIを使用して検索します。アプリケーションコードをインフラストラクチャプラットフォームに結びつけないように注意する必要があります。 
- 構成レジストリは、アプリケーションインスタンスが現在の接続詳細を集中管理レジストリ（「構成レジストリ」を参照）に保持できるようにします。他のアプリケーションがそれを参照できるようになります。これは、アドレス以上の情報が必要な場合に役立ちます。たとえば、ヘルスやその他のステータス指示などです。 
- サイドカーアプリケーションのインスタンスごとに別のプロセスが実行されます。アプリケーションは、サイドカーをアウトバウンド接続のプロキシ、インバウンド接続のゲートウェイ、またはルックアップサービスとして使用することができます。サイドカーは、ネットワークディスカバリ自体を行うための方法が必要です。この方法は、他のディスカバリメカニズムの1つである可能性もありますし、異なる通信プロトコルを使用する可能性もあります。サイドカーは通常、サービスメッシュの一部であり（「サービスメッシュ」で説明します）、サービスディスカバリ以上のことも提供します。たとえば、サイドカーは認証、暗号化、ログ記録、およびモニタリングを処理する場合があります。 
- APIゲートウェイは、ルートとエンドポイントを定義する集中型のHTTPサービスです。通常、認証、暗号化、ログ記録、およびモニタリングなどのサービスを提供します。言い換えれば、APIゲートウェイは分散ではなく集中化されたサイドカーのようなものです。 
- インフラストラクチャ、ランタイム、およびアプリケーションの間にハードバウンダリを回避する アプローチ は、理論上では、アプリケーションランタイムを開発者に完全なサービスセットとして提供し、基礎となるインフラストラクチャの詳細を隠すのに有用であるかもしれません。実際には、用語はこのモデルで提示されるものよりかなり曖昧です。さまざまな人々やチームが、異なる抽象度のリソースに異なるレベルの制御でアクセスする必要があります。したがって、絶対的な境界を持つようにシステムを設計および実装すべきではありませんが、代わりに異なるユーザーにさまざまな方法で構成および表示できる部分を定義する必要があります。 結論 インフラストラクチャの目的は、有用なアプリケーションやサービスを実行することです。本書のガイダンスとアイデアは、必要な形状のインフラストラクチャリソースのコレクションを提供する際に役立ちます。アプリケーション指向のインフラストラクチャのアプローチは、アプリケーションのランタイム要件に焦点を当て、アプリケーションの実行に適したスタック、サーバー、クラスター、および他のミドルティアの構築をサポートします。