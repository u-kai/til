allow_to: [ $APPSERVER_APPLICATIONS.https_inbound ] This example specifies where and how to find the container image (the container_image block), how many instances to run, and how to check their health. It also defines inbound and outbound connection rules. Deploying FaaS Serverless Applications In Chapter 3, I listed some FaaS serverless application runtime platforms as a type of compute resource (see “Compute Resources”). Most of these have their own format for defining application runtime requirements, and packaging these with code and related pieces for deploying to an instance of the runtime. When writing a FaaS application, the details of whatever servers or containers your code runs in are hidden from you. But your code probably needs infrastructure to work. For example, you may need network routing for inbound or outbound connections, storage, or message queues. Your FaaS framework may integrate with the underlying infrastructure platform, automatically provisioning the necessary infrastructure. Or you may need to define the infrastructure elements in a separate stack definition tool. Many stack tools like Terraform and CloudFormation let you declare your FaaS code provisioning as a part of an infrastructure stack. Chapter 14 is relevant for defining and provisioning FaaS runtimes to run your code. Application Data Data is often an afterthought for deploying and running applications. We provision databases and storage volumes but, as with many parts of infrastructure, it’s making changes to them that turns out to be hard. Changing data and structures is time consuming, messy, and risky. Application deployment often involves creating or changing data structures, including converting existing data when structures change. Updating data structures should be a concern of the application and application deployment process, rather than the infrastructure platform and runtime. However, the infrastructure and application runtime services need to support maintaining data when infrastructure and other underlying resources change or fail. See “Data Continuity in a Changing System” for ways to approach this challenge. Data Schemas and Structures Some data storage is strictly structured, such as SQL databases, while others are unstructured or schema-less. A strictly structured, schema-driven database enforces structures on data, refusing to store incorrectly formatted data. Applications that use a schema-less database are responsible for managing the data format. A new application release may include a change to data structures. For a schema-driven database, this involves changing the definition of the data structures in the database. For example, the release may add a new field to data records, a classic example being splitting a single “name” field into separate fields for first, middle, and last name. When data structures change, any existing data needs to be converted to the new structure with either type of database. If you are splitting a “name” field, you will need a process that divides the names in the database into their separate fields. Changing data structures and converting data is called schema migration. There are several tools and libraries that applications and deployment tools can use to manage this process, including Flyway, DBDeploy, Liquibase, and db-migrate.5 Developers can use these tools to define incremental database changes as code. The changes can be checked into version control, and packaged as part of a release. Doing this helps to ensure that database schemas stay in sync with the application version deployed to an instance. Teams can use database evolution strategies to safely and flexibly manage frequent changes to data and schemas. These strategies align with Agile software engineering approaches, including CI and CD, as well as Infrastructure as Codeallow_to: [$APPSERVER_APPLICAT IONS.https_inbound]
こ の 例では、コンテナ イメージ（container_image ブロック）の場所と方法、実行するインスタンスの数、およびその健康状態の確認方法を指定しています。また、インバウンドおよびアウトバウンドの接続ルールも定義しています。 「FaaS サーバーレスアプリケーションの展開」  
第 3 章では、FaaS サーバーレスアプリケーションのランタイムプラットフォームをコンピューティングリソースの一種としてリストアップしました（「コンピューティングリソース」を参照）。これらのほとんどは、独自の形式を持っており、ランタイムのインスタンスにデプロイするためのコードや関連する部品を定義するためのものです。 FaaS アプリケーションを作成する際、コードが実行されるサーバーやコンテナの詳細は隠されていますが、おそらくコードにはインフラストラクチャが必要です。たとえば、ネットワークのルーティング、インバウンドまたはアウトバウンドの接続、ストレージ、メッセージキューなどが必要な場合があります。 FaaS フレームワークは、必要なインフラストラクチャを自動的にプロビジョニングするように、基礎となるインフラストラクチャプラットフォームと統合する場合があります。または、インフラストラクチャ要素を別のスタック定義ツールで定義する必要がある場合もあります。Terraform や CloudFormation などの多くのスタックツールでは、FaaS コードのプロビジョニングをインフラストラクチャスタックの一部として宣言することができます。第 14 章では、コードを実行するための Faa S ランタイムを定義してプロビジョニングするための方法について説明しています。アプリケーションデータ  
データは、アプリケーションの展開と実行については後に考慮されることが多いです。私たちはデータベースやストレージボリュームをプロビジョニングしますが、インフラストラクチャの多くの部分と同様、それらを変更することが困難であることがわかります。データや構造を変更することは時間がかかり、混乱し、リスクが伴います。アプリケーションの展開では、データ構造を作成または変更する必要があります。これには、既存の データを 変更した構造に変換する必要があります。データ構造の変更では、どちらのタイ プのデータベースでも、データの構造の定義を変更する必要があります。たとえば、リリースで新しいフィールドをデータレコードに追加する場合、クラシックな例として単一の「名前」フィールドを名前、ミドルネーム、姓の別々のフィールドに分割する場合があります。データ構造が変更されると、いずれのデータベースでも既存のデータを新しい構造に変換する必要があります。たとえば、「名前」フィールドを分割する場合、データベースの名前を別のフィールドに分割するプロセスが必要になります。データ構造の変更とデータの変換は、スキーマの移行と呼ばれています。Flyway、DBDeploy、Liquibase、db-migrate など、いくつかのツールやライブラリが、このプロセスを管理するためにアプリケーションやデプロイメントツールで使用できます。開発者は、これらのツールを使用して、データベースの変更をコードとして定義することができます。変更はバージョン管理にチェックインすることができ、リリースの一部としてパッケージ化することができます。これにより、データベーススキーマがインスタンスに展開されたアプリケーションバージョンと同期されることが保証されます。チームはデータとスキーマの頻繁な変更を安全かつ柔軟に管理するためのデータベースエボリューション戦略を使用できます。これらの戦略は、CI や CD を含むアジャイルなソフトウェアエンジニアリングの手法とも一致しており、Infrastructure As Code とも一致しています。クラウドネイティブアプリケーションストレージインフラストラクチャ
クラウドネイティブインフラストラクチャは、需要に応じてアプリケーションとサービスに動的に割り当てられます。一部のプラットフォームは、コンピューティングとネットワーキングだけでなく、クラウドネイティブストレージも提供しています。システムがアプリケーションインスタンスを追加すると、ストレージデバイスを自動的にプロビジョニングして接続することができます。アプリケーションデプロイメントマニフェスト（例 10.2 参照）で、プロビジョニング時に必要なフォーマットやデータを指定します。例 10.2. データストレージアプリケーションのデプロイメントマニフェストの例：
volume_image: db_cluster_node_volume
この単純な例では、動的にスケーリングするデータベースクラスタのノードを作成する方法が定義されています。各ノードインスタンスについて、プラットフォームはデータベースソフトウェアを含むコンテナのインスタンスを作成し、空のデータベースセグメントで初期化されたイメージからクローンされたディスクボリュームを接続します。インスタンスが起動すると、クラスタに接続し、データをローカルボリュームに同期します。アプリケーション接続

コードを実行するためのコンピューティングリソースとデータを保持するためのストレージリソースに加えて、アプリケーションはインバウンドおよびアウトバウンドの接続にネットワーキングが必要です。ウェブサーバーなどのサーバー指向のアプリケーションパッ
