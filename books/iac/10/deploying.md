Deploying Applications to Servers Servers, whether physical or virtual, are the traditional runtime platform. An application is packaged using an operating system packaging format such as an RPM, a .deb file, or a Windows MSI. Or it is packaged in a language runtime format, such as a Ruby gem or Java .war file. More recently, container images, such as Docker images, have gained popularity as a format for packaging and deploying applications to servers.
Defining and provisioning servers as code is the topic of Chapter 11. This topic overlaps with application deployment, given the need to decide when and how to run deployment commands (see “Configuring a New Server Instance”). Packaging Applications in Containers Containers pull dependencies from the operating system into an application package, the container image, as shown in Figure 10-2.2
Including dependencies in the container makes it larger than typical operating system or language packages, but has several advantages:
A container creates a more consistent environment for running an application. Without a container, the application relies on libraries, configuration, user accounts, and other elements that may be different on different servers. A container bundles the runtime environment along with the application and its dependencies.  A containerized application is mostly isolated from the server it runs on, which gives you flexibility for where you can run it.  By packaging the application’s operating system context in the container image, you simplify and standardize the requirements for the host server. The server needs to have the container execution tooling installed, but little else.  Reducing the variability of runtime environments for an application improves quality assurance. When you test a container instance in one environment, you can be reasonably confident it will behave the same in other environments.  Deploying Applications to Server Clusters People have been deploying applications to groups of servers since before container-based application clusters were a thing. The usual model is to have a server cluster (as described in “Compute Resources”), and run an identical set of applications on each server. You package your applications the same way you would for a single server, repeating the deployment process for each server in the pool, perhaps using a remote command scripting tool like Capistrano or Fabric. See Figure 10-3.
If you deploy an application to multiple servers, you need to decide how to orchestrate the deployment. Do you deploy the application to all of the servers at once? Do you need to take the entire service offline while you do this? Or do you upgrade one server at a time? You can leverage incremental deployment to servers for progressive deployment strategies like the blue-green and canary deployment patterns (see “Changing Live Infrastructure” for more on these strategies). In addition to deploying application code onto servers, you may need to deploy other elements like changes to data structures or connectivity.
アプリケーションのサーバーへの展開
サーバー（物理的または仮想）は、従来のランタイムプラットフォームです。アプリケーションは、RPM、.debファイル、またはWindowsのMSIといったオペレーティングシステムのパッケージング形式、あるいはRubyのgemやJavaの.warファイルなどの言語ランタイムの形式でパッケージ化されます。より最近では、Dockerイメージなどのコンテナイメージがアプリケーションのパッケージングと展開の形式として人気を集めています。
サーバーをコードとして定義しプロビジョニングすることは、第11章のトピックです。このトピックは、デプロイメントコマンドを実行するタイミングと方法を決定する必要があるため、アプリケーションの展開と重複します（「新しいサーバーインスタンスの設定」を参照）。
コンテナにアプリケーションの依存関係を含めることで、典型的なオペレーティングシステムや言語パッケージよりもコンテナは大きくなりますが、いくつかの利点があります：
コンテナは、アプリケーションを実行するためのより一貫した環境を作成します。コンテナがない場合、アプリケーションは異なるサーバーで異なるライブラリ、設定、ユーザーアカウントなどに依存しています。コンテナはランタイム環境とアプリケーションとその依存関係をまとめてバンドルします。コンテナ化されたアプリケーションは、実行されるサーバーからほとんど分離されており、実行場所の柔軟性があります。コンテナイメージにアプリケーションのオペレーティングシステムのコンテキストをパッケージ化することで、ホストサーバーの要件を簡素化し標準化します。サーバーにはコンテナの実行ツールがインストールされている必要がありますが、他にはほとんど必要ありません。アプリケーションのランタイム環境の変動性を減らすことは、品質保証を向上させます。１つの環境でコンテナインスタンスをテストすると、他の環境でも同様の動作が期待できます。
アプリケーションをサーバークラスターに展開する
コンテナベースのアプリケーションクラスターが登場する前から、人々はグループのサーバーにアプリケーションを展開してきました。通常のモデルは、サーバークラスター（「計算リソース」で説明されている）を持ち、各サーバーで同一のセットのアプリケーションを実行します。アプリケーションは、単一のサーバーに展開する場合と同じ方法でパッケージ化し、プール内の各サーバーに対してデプロイメントプロセスを繰り返すことがあります。CapistranoやFabricのようなリモートコマンドスクリプトツールを使用することもあります。図10-3を参照してください。
アプリケーションを複数のサーバーに展開する場合、デプロイメントをどのようにオーケストレートするかを決定する必要があります。すべてのサーバーにアプリケーションを一度に展開しますか？それともこの間にサービス全体をオフラインにする必要がありますか？または１つずつサーバーをアップグレードしますか？ブルーグリーンやキャナリーデプロイメントといったプログレッシブデプロイメント戦略には、サーバーへのインクリメンタルデプロイメントを活用することができます（これらの戦略については、「ライブインフラの変更」を参照）。サーバーへのアプリケーションコードの展開に加えて、データ構造や接続性の変更など、その他の要素を展開する必要がある場合もあります。