Pattern: Continuous Configuration Synchronization Also known as: scheduled server configuration update. Continuous configuration synchronization involves repeatedly and frequently applying configuration code to a server, regardless of whether the code has changed. Doing this reverts or surfaces any unexpected differences that might creep in, whether to the server, or other resources used by the configuration code. Motivation We would like to believe that server configuration is predictable. Once I apply code to a server, nothing should change until the next time I apply the code. And if I haven’t changed the code, there’s no need to apply it. However, servers, and server code, are sneaky. Sometimes a server changes for obvious reasons, such as someone logging in and making a change by hand. People often make minor changes this way because they don’t think it will cause any problems. They are often mistaken about this. In other cases, teams manage some aspects of a server with a different tool or process. For example, some teams use a specialized tool to update and patch servers, especially for security patches. Even if a server hasn’t changed, applying the same server configuration code multiple times can introduce differences. For example, the code may use parameters from a central configuration registry. If one of those parameters changes, the code may do something different the next time it runs on a server. Packages are another external source of change. If your configuration code installs a package from a repository, it may update the package to a newer version when it becomes available. You can try to specify package versions, but this leads down one of two terrible roads. Down one road, your system eventually includes many out-of-date packages, including ones with security vulnerabilities well known to attackers. Down the other road, you and your team spend enormous amounts of energy manually updating package version numbers in your server code. By reapplying your server configuration code regularly, on an automated schedule, you ensure that you keep all of your servers configured consistently. You also ensure that any differences, from whatever sources, are applied sooner rather than later. Applicability It is easier to implement continuous synchronization than the main alternative, immutable servers. Most Infrastructure as Code tools — Ansible, Chef, and Puppet, for example — are designed with this pattern in mind. It is quicker and less disruptive to apply changes by updating an existing server instance than by building a new instance. Consequences When an automated process applies server configuration across your estate, there is a risk that something will break. All of the things that might change unexpectedly, as described earlier in the “Motivation” section, are things that could break a server. To counter this, you should have an effective monitoring system to alert you to problems, and a good process for testing and delivering code before applying changes to production systems.
Implementation As mentioned before, most server configuration as code tools are designed to run continuously. The specific mechanisms they use are described in “Pattern: Push Server Configuration” and in “Pattern: Pull Server Configuration”. Most continuous synchronization implementations run on a schedule. These tend to have some way of varying the runtime on different servers so that all of your servers don’t wake up and run their configuration at the same time.1 However, sometimes you want to apply code more quickly, maybe to apply a fix, or to support a software deployment. Different tools have different solutions for doing this. Related patterns Continuous synchronization is implemented using either the push (“Pattern: Push Server Configuration”) or pull (“Pattern: Pull Server Configuration”) configuration pattern. The alternative to this pattern is immutable servers (“Pattern: Immutable Server”).
パターン：継続的な構成同期
別名：スケジュールされたサーバー構成の更新
継続的な構成同期は、コードが変更されたかどうかに関係なく、コンフィギュレーションコードをサーバーに繰り返し頻繁に適用することを意味します。これにより、サーバーまたは構成コードで使用される他のリソースに潜入するか予想外の違いが明らかにされます。

動機
サーバーの構成が予測可能であることを望みます。サーバーにコードを適用すると、コードを次に適用するまで何も変更されないはずです。コードを変更していない場合は、適用する必要はありません。しかし、サーバーやサーバーコードはずる賢いものです。サーバーは、手作業でログインして変更を行うなど、明らかな理由で変更されることがあります。人々はしばしばこの方法で細かい変更を行いますが、問題が発生しないと考えています。これについてはしばしば誤解が生じます。

他の場合では、チームが異なるツールやプロセスを使用してサーバーの一部を管理することもあります。例えば、セキュリティパッチのために特化したツールを使用してサーバーを更新およびパッチするチームもあります。サーバーが変更されていない場合でも、同じサーバー構成コードを複数回適用すると、違いが生じる場合があります。例えば、コードは中央の構成レジストリからパラメータを使用する場合があります。これらのパラメータのいずれかが変更されると、次回サーバーで実行されるときにコードが異なる動作をする場合があります。また、パッケージは変更の外部ソースです。構成コードがリポジトリからパッケージをインストールする場合、利用可能になるとパッケージを新バージョンに更新する可能性があります。パッケージのバージョンを指定しようとすることもできますが、これには二つの問題のある選択肢があります。一つは、システムに古いパッケージが含まれるようになり、攻撃者によく知られたセキュリティの脆弱性を引き起こす可能性があることです。もう一つは、あなたとあなたのチームがサーバーコードでパッケージのバージョン番号を手動で更新するために膨大なエネルギーを費やすことです。

定期的にサーバーの構成コードを自動スケジュールで再適用することで、サーバーを一貫して構成することが保証されます。さらに、様々なソースからの差異が早く適用されるようになります。

適用範囲
主要な代替手段であるイミュータブルサーバーよりも、連続同期の実装は簡単です。Ansible、Chef、Puppetなど、ほとんどのインフラストラクチャとしてのコードツールは、このパターンを考慮して設計されています。既存のサーバーインスタンスを更新する方法は、新しいインスタンスを作成する方法よりも迅速で少ない障害を引き起こします。

結果
自動化プロセスがエンタープライズ全体でサーバー構成を適用する場合、何かが壊れるリスクがあります。前述の「動機」セクションで説明したように、予期せずに変更される可能性がある全ての要素は、サーバーを壊す可能性があります。これを防ぐためには、問題を通知する効果的な監視システムと、変更を本番システムに適用する前にコードをテストして配信する良いプロセスが必要です。

実装
前述したように、ほとんどのサーバー構成コードツールは連続的に実行するように設計されています。具体的なメカニズムは、「パターン：サーバー構成のプッシュ」と「パターン：サーバー構成のプル」で説明されています。ほとんどの連続同期の実装はスケジュールで実行されます。これらは通常、異なるサーバーでランタイムを変える方法があり、すべてのサーバーが同時に起動して構成を実行することはありません。ただし、修正を適用したり、ソフトウェアの展開をサポートしたりするために、より速くコードを適用したい場合もあります。異なるツールには、これを実現するための異なるソリューションがあります。

関連するパターン
連続同期は、「パターン：サーバー構成のプッシュ」または「パターン：サーバー構成のプル」の構成パターンを使用して実装されます。このパターンの代替手段は、「パターン：イミュータブルサーバー」です。