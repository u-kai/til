Pattern: Immutable Server An immutable server is a server instance whose configuration is never changed. You deliver changes by creating a new server instance with the changed configuration and using it to replace the existing server.2 Motivation Immutable servers reduce the risk of making changes. Rather than applying a change to a running server instance, you create a new server instance. You have the opportunity to test the new instance, and then swap it out for the previous instance. You can then check that the new instance is working correctly before destroying the original, or swap it back into place if something goes wrong. Applicability Organizations that need tight control and consistency of server configuration may find immutable servers useful. For example, a telecommunications company that runs thousands of server images may decide not to apply changes to running servers, preferring to guarantee the stability of their configuration. Consequences Implementing immutable servers requires a robust automated process for building, testing, and updating server images (as described in Chapter 13). Your system and application design must support swapping server instances without interrupting service (see “Changing Live Infrastructure” for ideas). Despite the name, immutable servers do change.3 Configuration drift may creep in, especially if people can log in to servers and make changes manually rather than using the configuration change process to build new server instances. So teams using immutable servers should be careful to ensure the freshness of running instances. It’s entirely possible to combine immutable servers with the apply on change antipattern (see “Antipattern: Apply On Change”), which can result in servers that run, unchanged, for a
long time, without including patches and improvements made to servers built later. Teams should also consider disabling access to servers, or make the ability to make accessing and manually changing services require a “break glass” procedure.4 Implementation Most teams who use immutable servers handle the bulk of their configuration in server images, favoring baking images (see “Baking Server Images”) over frying instances. So a pipeline, or set of pipelines, to automatically build and update server images is a foundation for immutable servers. You can fry configuration onto immutable server instances (as described in “Frying a Server Instance”), as long as you don’t make changes to the instance after you create it. However, a stricter form of immutable servers avoids adding any differences to server instances. With this approach, you create and test a server image, and then promote it from one environment to the next. Because little or nothing changes with each server instance, you lower the risk of issues creeping in from one environment to the next. Related patterns People tend to bake servers (see “Baking Server Images”) to support immutable servers. Continuous synchronization (see “Pattern: Continuous Configuration Synchronization”) is the opposite approach, routinely applying changes to running server instances. Immutable servers are a subset of immutable infrastructure (see “Immutable Infrastructure”). Patching Servers Many teams are used to patching servers as a special, separate process. However, if you have an automated pipeline that delivers changes to servers, and continuously synchronize server code to existing servers, you can use this same process to keep your servers patched. Teams I’ve worked with pull, test, and deliver the latest security patches for their operating systems and other core packages on a weekly basis, and sometimes daily. This rapid, frequent patching process impressed the CIO at one of my clients when the business press trumpeted a high-profile security vulnerability in a core OS package. The CIO demanded that we drop everything and create a plan to address the vulnerability, with estimates for how long it would take and the cost impact of diverting resources to the effort. They were pleasantly surprised when we told them that the patch fixing the issue had already been rolled out as part of that morning’s routine update.
パターン：イミュータブルサーバー
イミュータブルサーバーは、その設定が決して変更されないサーバーインスタンスです。変更を配信する際には、変更した設定で新しいサーバーインスタンスを作成し、既存のサーバーと置き換えることで実現します。

動機
イミュータブルサーバーは変更のリスクを減らすものです。実行中のサーバーインスタンスに変更を適用するのではなく、新しいサーバーインスタンスを作成します。新しいインスタンスをテストし、その後、以前のインスタンスと交換します。新しいインスタンスが正常に動作していることを確認した後、元のインスタンスを削除するか、何か問題があれば以前のインスタンスに戻すことができます。

適用範囲
サーバーの設定を厳密に制御し一貫性を持たせる必要がある組織は、イミュータブルサーバーが役立つ場合があります。たとえば、数千のサーバーイメージを実行する通信会社は、実行中のサーバーに変更を適用せず、設定の安定性を保証することを選択するかもしれません。

結果
イミュータブルサーバーを実装するには、サーバーイメージのビルド、テスト、更新のための堅牢な自動化プロセスが必要です（第13章で説明されています）。システムとアプリケーションの設計は、サーバーインスタンスを中断することなく交換するようにサポートする必要があります。名前の通り、イミュータブルサーバーは変更されます。設定のドリフトが発生する可能性があります。特に、人々がサーバーにログインし、設定変更プロセスではなく手動で変更を行います。したがって、イミュータブルサーバーを使用するチームは、実行中のインスタンスの新鮮さを確保するために注意する必要があります。イミュータブルサーバーと変更時に適用するアンチパターン（「アンチパターン：変更時に適用する」を参照）を組み合わせることも完全に可能です。この場合、後で作成されたサーバーに適用されたパッチや改善がないまま、変更されずに長時間実行されるサーバーを結果として得ることができます。チームはまた、サーバーへのアクセスを無効にしたり、アクセスや手動での変更を行うために「緊急用ガラスを破る」手順を必要とすることも検討するべきです。

実装
イミュータブルサーバーを使用する多くのチームは、サーバーイメージに大部分の設定を処理し、インスタンスの焼き付け（「サーバーイメージの焼き付け」を参照）を好む傾向があります。したがって、サーバーイメージの自動的なビルドと更新のためのパイプライン、または一連のパイプラインは、イミュータブルサーバーの基礎です。インスタンス作成後にインスタンスに変更を加えない限り、イミュータブルサーバーインスタンスに設定を焼き付けることも可能です（「サーバーインスタンスの焼き付け」に記載されています）。ただし、より厳格な形態のイミュータブルサーバーでは、サーバーインスタンスに対して何の違いも追加しません。このアプローチでは、サーバーイメージを作成しテストした後、それを次の環境に移行します。各サーバーインスタンスごとにほとんど何も変わらないため、1つの環境から次の環境に問題が移行するリスクが低下します。

関連するパターン
人々はイミュータブルサーバーをサポートするためにサーバーを焼き付ける傾向があります（「サーバーイメージの焼き付け」を参照）。連続同期（「パターン：連続的な設定同期」を参照）は逆のアプローチであり、定期的に実行中のサーバーインスタンスに変更を適用します。イミュータブルサーバーはイミュータブルインフラストラクチャ（「イミュータブルインフラストラクチャ」を参照）のサブセットです。

サーバーのパッチング
多くのチームは、サーバーのパッチを別の特別なプロセスとして行うことに慣れています。しかし、サーバーへの変更を配信し、サーバーコードを連続的に実行中のサーバーに同期する自動化パイプラインがあれば、同じプロセスを使用してサーバーのパッチを適用することができます。私が働いたチームは、オペレーティングシステムや他のコアパッケージの最新のセキュリティパッチを毎週、時には毎日で取り込んでテストし、配信しています。あるクライアントのCIOは、ビジネスプレスで中核OSパッケージの著名なセキュリティ脆弱性が騒がれた際に、この迅速かつ頻繁なパッチングプロセスに感銘を受けました。CIOは、脆弱性を修正するパッチについての計画を立て、リソースをそれに割くことの期間とコストの影響を見積もることを要求しました。朝の定期更新の一環として、問題を修正するパッチが既に展開されていることを伝えたとき、彼らは驚いて喜びました。