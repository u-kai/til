Applying Code to Infrastructure A typical workflow for making a change to infrastructure starts with code in a shared source repository. A member of the team pulls the latest version of the code to their working environment and edits it there. When they’re ready, they push the code into the source repository, and apply the new version of the code to various environments. Many people run their tools from the command line in their working environment when they are starting with infrastructure automation. However, doing that has pitfalls.
Applying Code from Your Local Workstation Applying infrastructure code from the command line can be useful for a test instance of the infrastructure that nobody else uses. But running the tool from your local work environments creates problems with shared instances of infrastructure, whether it’s a production environment or a delivery environment (see “Delivery Environments”). The person might make changes to their local version of the code before applying it. If they apply the code before pushing the changes to the shared repository, then nobody else has access to that version of the code. This can cause problems if someone else needs to debug the infrastructure. If the person who applied their local version of the code does not immediately push their changes, someone else might pull and edit an older version of the code. When they apply that code, they’ll revert the first person’s changes. This situation quickly becomes confusing and hard to untangle (see Figure 20-2).
Note that locking solutions, such as Terraform’s state locking, don’t prevent this situation. Locking stops two people from applying their code to the same instance simultaneously. But, as of this writing, locking solutions don’t stop people from applying divergent versions of code, as long as they each wait their turn. So the lesson is that, for any instance of infrastructure, code should always be applied from the same location. You could designate an individual to be responsible for each instance. But this has many pitfalls,
including a risky dependency on one person and their workstation. A better solution is to have a central system that handles shared infrastructure instances. Applying Code from a Centralized Service You can use a centralized service to apply infrastructure code to instances, whether it’s an application that you host yourself or a third-party service. The service pulls code from a source code repository or an artifact repository (see “Packaging Infrastructure Code as an Artifact”) and applies it to the infrastructure, imposing a clear, controlled process for managing which version of code is applied. If two people pull and edit code, they must resolve any differences in their code when they integrate their code with the branch that the tool uses. When there is a problem, it’s easy to see which version of the code was applied and correct it (see Figure 20-3).
A central service also ensures that the infrastructure tool is run consistently, rather than assuming that a person doesn’t make a mistake or “improve” (deviate from) the workflow. It uses the same versions of the tool, scripts, and supporting utilities every time. Using a central service aligns well with the pipeline model for delivering infrastructure code across environments (see “Infrastructure Delivery Pipelines”). Whatever tool or service you use to orchestrate changes through your pipeline takes on the responsibility for running your infrastructure tool to apply the latest version of code to each environment. Another benefit of having a central service execute your infrastructure code is that it forces you and your team to automate the entire process. If you run the tool from your workstation, it’s easy to leave a few loose ends, steps that you need to do manually before or after running the tool. A central service gives you no choice other than making sure the task is entirely automated. Tools and Services That Run Your Infrastructure Tool for You There are several options for a centralized service to apply infrastructure code. If you use a build server like Jenkins or a CD tool like GoCD or ConcourseCI, you can implement jobs or stages to execute your infrastructure tool. These tools support managing different versions of code from a source repository and can promote code between stages. These multipurpose tools also make it easy to integrate workflows across applications, infrastructure, and other parts of your system. You can use self-hosted instances of these services, or use a hosted offering. See “Delivery Pipeline Software and Services” for more on pipeline servers and software. Several vendors offer products or services specialized for running infrastructure tools. Examples include Terraform Cloud, Atlantis, and Pulumi for Teams. WeaveWorks provides Weave Cloud, which applies infrastructure code to Kubernetes clusters.

インフラストラクチャへのコードの適用 インフラストラクチャへの変更を行うための典型的なワークフローは、共有のソースリポジトリにコードを適用することから始まります。チームのメンバーは、最新のコードを自分の作業環境に取り込んで編集します。準備ができたら、コードをソースリポジトリにプッシュし、新しいバージョンのコードをさまざまな環境に適用します。多くの人々は、インフラストラクチャの自動化を開始する際に、コマンドラインからツールを実行します。しかし、それには注意が必要です。

ローカルのワークステーションからコードを適用する ローカルのワーク環境からインフラストラクチャのコードを実行することは、誰も使わないインフラストラクチャのテストインスタンスには有用です。しかし、ローカルの作業環境からツールを実行すると、本番環境やデリバリー環境（「デリバリー環境」を参照）などの共有インスタンスで問題が発生します。その人は適用する前にローカルバージョンのコードを変更するかもしれません。変更を共有リポジトリにプッシュする前にコードを適用すると、他の誰もがそのバージョンのコードにアクセスできません。これは、他の人がインフラストラクチャをデバッグする必要がある場合に問題を引き起こすことがあります。ローカルバージョンのコードを適用した人がすぐに変更をプッシュしない場合、他の誰かが古いバージョンのコードをプルして編集する可能性があります。そのコードを適用すると、最初の人の変更は元に戻されます。この状況はすぐに混乱し、解決が難しくなります（図20-2を参照）。

Terraformのステートロックなどのロックソリューションでは、この状況を防ぐことはできません。ロックは、同じインスタンスに2人が同時に自分のコードを適用することを防ぎます。ただし、この執筆時点では、ロックソリューションは、順番を待つ限り、人々が異なるバージョンのコードを適用することを防ぐことはありません。したがって、インフラストラクチャの任意のインスタンスでは、コードは常に同じ場所から適用されるべきです。各インスタンスを担当する人物を指定することもできますが、これには多くの落とし穴があります。個々の人とそのワークステーションにリスクのある依存関係などです。より良い解決策は、共有インフラストラクチャインスタンスを処理する中央システムを持つことです。 中央サービスからコードを適用する 中央サービスを使用して、アプリケーションを自分自身でホストするか、サードパーティのサービスであるかに関係なく、インフラストラクチャコードをインスタンスに適用できます。このサービスは、ソースコードリポジトリまたはアーティファクトリポジトリ（「インフラストラクチャコードをアーティファクトとしてパッケージ化する」を参照）からコードを取得し、インフラストラクチャに適用し、適用するコードのバージョンを明示的に管理するための明確かつ制御されたプロセスを実施します。2人がコードをプルして編集する場合、ツールが使用するブランチにコードを統合する際に、コードの違いを解決する必要があります。問題が発生した場合、適用されたコードのどのバージョンが適用されたかが簡単に確認でき、修正できます（図20-3を参照）。

中央サービスには、インフラストラクチャツールが一貫して実行されることも保証されます。ただし、ワークフローからの逸脱や「改善」を行うと仮定している代わりに、同じバージョンのツール、スクリプト、およびサポートユーティリティが毎回使用されます。中央サービスの使用は、環境全体にわたってインフラストラクチャコードを配信するためのパイプラインモデルとよく一致します（「インフラストラクチャデリバリーパイプライン」を参照）。パイプラインを通じて変更を管理するために使用するツールやサービスは、各環境に最新バージョンのコードを適用するための責任を負います。インフラストラクチャコードを実行するための中央サービスを使用することのもう1つの利点は、あなたとチームがプロセス全体を自動化することを強制することです。ワークステーションからツールを実行すると、ツールを実行する前または後に手動で行う必要のあるいくつかの手続きを見落とすことが簡単です。中央サービスでは、そのタスクが完全に自動化されていること以外の選択肢はありません。あなたのインフラストラクチャコードを実行するためのツールとサービス いくつかのオプションがあります。JenkinsなどのビルドサーバーやGoCDやConcourseCIなどのCDツールを使用する場合、インフラストラクチャツールを実行するためのジョブやステージを実装できます。これらのツールは、ソースリポジトリからさまざまなバージョンのコードを管理し、ステージ間でコードを昇格させることができます。これらの多目的ツールは、アプリケーション、インフラストラクチャ、システムの他の部分を横断したワークフローを簡単に統合することも可能です。これらのサービスのセルフホスト型インスタンスを使用するか、ホストされているオファリングを使用できます。 パイプラインサーバーとソフトウェアの「デリバリーパイプラインソフトウェアとサービス」の詳細については、「デリバリーパイプラインソフトウェアとサービス」を参照してください。いくつかのベンダーは、インフラストラクチャツールを実行するために特化した製品やサービスを提供しています。Terraform Cloud、Atlantis、Pulumi for Teamsなどの例があります。WeaveWorksはWeave Cloudを提供し、Kubernetesクラスタにインフラストラクチャコードを適用しています。