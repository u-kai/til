Preventing Configuration Drift Chapter 2 described the perils of configuration drift (see “Configuration Drift”), where similar infrastructure elements become inconsistent over time. Configuration drift often results when teams use
infrastructure coding tools to automate parts of older ways of working, rather than fully adapting their ways of working. There are several things you can do in your workflows to avoid configuration drift. Minimize Automation Lag Automation lag is the time that passes between instances of running an automated process, such as applying infrastructure code. The longer it’s been since the last time the process ran, the more likely it will fail.10 Things change over time, even when nobody has consciously made a change. Even if code hasn’t changed, applying it after a long gap in time can still fail, for various reasons: Someone has changed another part of the system, such as a dependency, in a way that only breaks when your code is reapplied.  An upgrade or configuration change to a tool or service used to apply your code might be incompatible with your code.  Applying unchanged code might nevertheless bring in updates to transitive dependencies, such as operating system packages.  Someone may have made an manual fix or improvement that they neglected to fold back into the code. Reapplying your code reverts the fix.  The corollary to automation lag is, the more frequently you apply infrastructure code, the less likely it is to fail. When failures do occur, you can discover the cause more quickly, because less has changed since the last successful run. Avoid Ad Hoc Apply One habit that some teams carry over from Iron Age ways of working is only applying code to make a
specific change. They might only use their infrastructure code to provision new infrastructure, but not for making changes to existing systems. Or they may write and apply infrastructure code to make ad hoc changes to specific parts of their systems. For example, they code a one-off configuration change for one of their application servers. Even when teams use code to make changes, and apply code to all instances, sometimes they may only apply code when they make a change to the code. These habits can create configuration drift or automation lag. Apply Code Continuously A core strategy for eliminating configuration drift is to continuously apply infrastructure code to instances, even when the code hasn’t changed. Many server configuration tools, including Chef and Puppet, are designed to reapply configuration on a schedule, usually hourly.11 The GitOps methodology (see “GitOps”) involves continuously applying code from a source code branch to each environment. You should be able to use a central service to apply code (as described in “Applying Code from a Centralized Service”) to continuously reapply code to each instance. Immutable Infrastructure Immutable infrastructure solves the problem of configuration drift in a different way. Rather than applying configuration code frequently to an infrastructure instance, you only apply it once, when you create the instance. When the code changes, you make a new instance and swap it out for the old one. Making changes by creating a new instance requires sophisticated techniques to avoid downtime (“Zero Downtime Changes”), and may not be applicable to all use cases. Automation lag is still potentially an issue, so teams that use immutable infrastructure tend to rebuild instances frequently, as with phoenix servers.12
GitOps GitOps is a variation of Infrastructure as Code that involves continuously synchronizing code from source code branches to environments. GitOps emphasizes defining systems as code (see “Core Practice: Define Everything as Code”). GitOps doesn’t prescribe an approach to testing and delivering infrastructure code, but it is compatible with using a pipeline to deliver code (“Infrastructure Delivery Pipelines”). However, GitOps discourages the use of delivery artifacts (“Packaging Infrastructure Code as an Artifact”), instead promoting code changes by merging them to source code branches (see “Delivering code from a source code repository”). Another key element of GitOps is continuously synchronizing code to systems (“Apply Code Continuously”). Rather than having a build server job or pipeline stage apply the code when it changes (“Avoid Ad Hoc Apply”), GitOps uses a service that continuously compares the code to the system, reducing configuration drift (see “Configuration Drift”). Some teams describe their process as GitOps, but only implement the branches for environments practice without continuously synchronizing code to environments. This makes it to easy to fall into an ad hoc change process, and bad habits of copying, pasting, and editing code changes for each environment, per the copy-paste antipattern (see “Antipattern: Copy-Paste Environments”.

構成のずれを防ぐ
第2章では、構成のずれの危険性について説明しました（「構成のずれ」を参照）。構成のずれは、似たようなインフラストラクチャ要素が時間の経過とともに不一致になることがよくあります。チームが従来の作業方法の一部を自動化するためにインフラストラクチャコーディングツールを使用する場合、完全に作業方法を適応させるのではなく、古い作業方法の一部を自動化することが頻繁に構成のずれの原因となります。構成のずれを避けるために、ワークフローで次のようなことができます。自動化の遅延を最小化する
自動化遅延とは、インフラストラクチャコードを適用するなどの自動化プロセスの実行間隔が経過する時間のことです。プロセスが前回実行されてから経過した時間が長いほど、失敗する可能性が高くなります。事象は時間の経過と共に変化します。誰も意識的な変更を行っていなくても、コードが変わっていなくても、時間の経過後に適用することはさまざまな理由で失敗する可能性があります。他の一部のシステム、例えば依存関係のようなものが変更され、その変更がコードが再適用された場合にのみ壊れるようになっていることがあります。ツールやサービスのアップグレードや構成変更が、コードと互換性がない場合があります。変更していないコードでも、オペレーティングシステムパッケージなどのトランジティブな依存関係の更新が適用される場合があります。手作業による修正や改善が行われ、その修正をコードに組み込んでいない場合には、コードを再適用すると修正が元に戻ってしまいます。自動化の遅延の相補的な現象が、インフラストラクチャコードをより頻繁に適用すればするほど、失敗する可能性が低くなるということです。障害が発生した場合、最後の成功した実行から変更が少ないため、原因をより早く発見できます。アドホックな適用を回避する
一部のチームが鉄器時代の作業方法から引き継いでいる習慣の一つは、特定の変更を行うためにのみコードを適用するということです。彼らはインフラストラクチャコードを新しいインフラストラクチャをプロビジョニングするためだけに使用するかもしれませんが、既存のシステムの変更には使用しないかもしれません。あるいは、システムの特定の部分にアドホックな変更を加えるためにインフラストラクチャコードを作成して適用するかもしれません。例えば、彼らはアプリケーションサーバの一回限りの設定変更のためにコードを作成します。チームが変更を行い、すべてのインスタンスにコードを適用しているにもかかわらず、時にはコードを適用するのはコードを変更した場合に限られるかもしれません。これらの習慣は構成のずれや自動化の遅延を生み出す可能性があります。コードを継続的に適用する
構成のずれを排除するための基本戦略は、コードが変更されていなくても、インスタンスに対して継続的にインフラストラクチャコードを適用することです。ChefやPuppetなどの多くのサーバー構成ツールは、通常は毎時に設定を再適用するように設計されています。GitOpsメソドロジーは、ソースコードブランチから環境ごとにコードを継続的に適用するために用意されています。中央のサービスを使用してコードを継続的に適用することができるはずです（「中央サービスからコードを適用する」で説明されています）。不変なインフラストラクチャ
不変なインフラストラクチャは、構成のずれの問題を異なる方法で解決します。インフラストラクチャのインスタンスに頻繁に構成コードを適用するのではなく、インスタンスを作成するときに一度だけ適用します。コードが変更された場合は、新しいインスタンスを作成し、古いインスタンスと取り換えます。新しいインスタンスを作成して変更を行うには、ダウンタイムを回避するために高度な技術が必要です（「ダウンタイムなしの変更」）、またすべてのユースケースに適用できるわけではありません。自動化の遅延は依然として懸念事項ですので、不変なインフラストラクチャを使用するチームは、フェニックスサーバと同様に、頻繁にインスタンスを再構築する傾向があります。GitOps
GitOpsは、ソースコードブランチから環境へのコードを連続的に同期するInfrastructure as Codeの変種です。GitOpsでは、システムをコードとして定義すること（「コアプラクティス: すべてをコードで定義する」）が重視されています。GitOpsはインフラストラクチャコードのテストと提供方法を指定するものではありませんが、パイプラインを使用してコードを提供すること（「インフラストラクチャデリバリーパイプライン」）は互換性があります。ただし、GitOpsはデリバリーアーティファクトの使用を descrecouraged（「インフラストラクチャコードをアーティファクトとしてパッケージ化」）し、代わりにコード変更をソースコードブランチにマージすることで提供することを推奨しています（「ソースコードリポジトリからコードを提供する」を参照）。GitOpsのもう一つの重要な要素は、コードをシステムに連続的に同期することです（「コードを継続的に適用する」）。コードが変更されたときにビルドサーバージョブやパイプラインステージがコードを適用するのではなく（「アドホックな適用を避ける」）、GitOpsはコードとシステムを連続的に比較するサービスを使用して構成のずれを減らします（「構成のずれを参照」）。一部のチームは自分たちのプロセスをGitOpsと呼んでいますが、継続的にコードを環境に同期させないで、環境のためにブランチのみを実装している場合があります。これにより、アドホックな変更プロセスに陥りやすくなり、コピー、貼り付け、編集によるコード変更の悪い習慣に陥る可能性があります（「アンチパターン: コピー&ペースト環境」を参照）。