Personal Infrastructure Instances In most of the workflows discussed in this book, you pull code, edit it, and then push it into a shared code repository.5 Then a pipeline delivery process applies it to relevant environments. Ideally, you can test your code changes before you push them into the shared repository. Doing this gives you a way to make sure your change does what you expect and is faster than waiting for a pipeline to run your code through to an online test stage (see “Online Testing Stages for Stacks”). It also helps avoid breaking the build when one of your changes fails a pipeline stage, disrupting everyone working on the codebase. Your team can do a few things to make it easier to test code changes before pushing. First, make sure each person working on the infrastructure code can create their own instance of the infrastructure. There’s a limit to what people can test locally, without your cloud platform, as discussed in “Offline Testing Stages for Stacks”. You might be tempted to run shared “dev” instances of the infrastructure. But as explained earlier, having multiple people apply locally edited code to a shared instance becomes messy. So create a way for people to spin up their own infrastructure instances, and destroy them when they’re not actively using them. Second, keep the pieces of your infrastructure small. This is, of course, one of the three core practices in this book (see Chapter 15). You should be able to spin up an instance of any component of your system on its own, perhaps using test fixtures to handle dependencies (see “Using Test Fixtures to Handle Dependencies”). It’s hard for people to work on personal instances if they need to spin up the entire system, unless the system is exceptionally small. Third, people should use the same tools and scripts to apply and test their instances of infrastructure that are used with shared instances, for example, in the pipeline. It helps to create packages for the tooling and scripts that you can use across these different locations.6
Centrally Managed Personal Instances It’s safer for people to apply code to personal instances from their workstations than it is for shared instances. But there may be advantages to using a centralized service for personal instances. I’ve seen a team struggle to tear down a personal instance that someone left running when they went on vacation. They created the instance using a local version of the infrastructure code that they didn’t push to the repository, making it hard to destroy. So some teams establish a practice where each person pushes changes to a personal branch, which the central service applies to their personal infrastructure instance that they can test. In this arrangement, the personal branch emulates local code, so people don’t consider a change committed until they’ve merged it to the shared branch or trunk. But the code is centrally available for other people to view and use in their absence. Source Code Branches in Workflows Branches are a powerful feature of shared source repositories that make it easier for people to make changes to different copies of a codebase — branches — and then integrate their work when they’re ready. There are many strategies and patterns for using branches as part of a team’s workflow. Rather than elaborating on them here, I refer you to Martin Fowler’s article, “Patterns for Managing Source Code Branches”. It’s worth highlighting a few distinctions of branching strategy in the context of Infrastructure as Code. One is the difference between path to production patterns and integration patterns for branching. The other is the importance of integration frequency. Teams use path to production branching patterns to manage which versions of code to apply to environments.7 Typical path to production patterns include release branches and environment branches (environment branches are discussed in “Delivering code from a source code repository”).
Integration patterns for branching describes ways for people working on a codebase to manage when and how they integrate their work.8 Most teams use the mainline integration pattern, either with feature branching or continuous integration. The specific pattern or strategy is less important than how you use it. The most important factor in the effectiveness of a team’s use of branches is integration frequency, how often everyone merges all of their code into the same (main) branch of the central repository.9 The DORA Accelerate research finds that more frequent integration of all of the code within a team correlates to higher commercial performance. Their results suggest that everyone in the team should integrate all of their code together — for example, to main or trunk — at least once a day. Merging Is Not Integration People sometimes confuse a build server automatically running tests on branches with continuous integration. The practice of continuous integration, and the correlation with higher team performance, is based on fully integrating all of the changes that everyone is working on in the codebase. Although someone using the feature branch pattern may frequently merge the current main branch to their own branch, they don’t normally integrate their own work back into main until they’ve finished working on their feature. And if other people are working the same way on their own feature branches, then the code is not fully integrated until everyone finishes their feature and merges their changes to the main branch. Integration involves merging in both directions — individuals merging their own changes to the main branch as well as merging main back to their own branch or local copy of the code. Continuous integration, therefore, means everyone doing this as they work, at least once a day.

個人インフラストラクチャのインスタンス 本書で議論されているワークフローのほとんどでは、コードを取得し、編集し、共有のコードリポジトリにプッシュします。その後、パイプラインデリバリープロセスが関連する環境に適用します。理想的には、コードを共有リポジトリにプッシュする前に、コードの変更をテストできるでしょう。これにより、変更が期待どおりの動作をすることや、パイプラインがコードをオンラインテストステージ（「スタックのオンラインテストステージ」を参照）まで実行するのを待つよりも早くテストできます。また、コードベースで作業している他の全員に影響を与えるような変更でビルドが破損することを避けるのにも役立ちます。チームは、プッシュする前にコードの変更をテストしやすくするためにいくつかのことを行うことができます。まず、インフラストラクチャコードで作業している各個人が独自のインフラストラクチャのインスタンスを作成できるようにしてください。クラウドプラットフォームなしでローカルでテストできる範囲には限界がありますが、これについては「スタックのオフラインテストステージ」で説明されています。インフラストラクチャの共有「dev」インスタンスを実行することが誘惑されるかもしれません。しかし、以前に説明したように、複数の人々が共有のインスタンスにローカルで編集したコードを適用すると、混乱が生じます。そのため、個人が自分自身のインフラストラクチャインスタンスを立ち上げ、アクティブに使用していないときには破棄できるような方法を作成してください。次に、インフラストラクチャを構成する部分を小さくしておくことです。これはもちろん、本書の 3 つの主要なプラクティスの 1 つです（第 15 章を参照）。システムの任意のコンポーネントのインスタンスを独立して立ち上げることができるようにすべきです。たとえば、テストフィクスチャを使用して依存関係を処理することができます（「テストフィクスチャを使用して依存関係を処理する」を参照）。システム全体を立ち上げる必要がある場合、個人が個別のインスタンスを作業することは困難です（システムが非常に小さい場合を除く）。3 つ目に、人々は共有インスタンスで使用されていると同じツールとスクリプトを使用して、インフラストラクチャインスタンスを適用およびテストするべきです。たとえば、パイプラインで使用されるものです。さまざまな場所で使用できるように、ツールとスクリプトのためのパッケージを作成すると役立ちます。

集中管理された個人インスタンス 人々が共有インスタンスではなく個人インスタンスにコードを適用する方が安全です。しかし、個人インスタンスには集中管理されたサービスを使用する利点があるかもしれません。例えば、休暇中に実行し続けてしまった個人インスタンスを解体するのに苦労したチームを見たことがあります。彼らはリポジトリにプッシュしなかったインフラストラクチャコードのローカルバージョンを使用してインスタンスを作成し、解体が困難になりました。そのため、一部のチームでは、各個人が変更を個人ブランチにプッシュし、中央サービスがそれを個人インフラストラクチャインスタンスに適用し、テストできるようにするという方法を確立しています。このアレンジでは、個人ブランチは地元のコードをエミュレートし、変更が共有ブランチまたはメインブランチにマージされるまで、変更が確定されていないとはみなされません。ただし、コードは他の人々が閲覧して使用できるように、集中的に利用できます。 ワークフロー内のソースコードブランチ ソースリポジトリのブランチは、異なるコードベースのコピー（ブランチ）で変更を行い、準備ができたときにその作業を統合するための強力な機能です。チームのワークフローの一部としてブランチを使用するための多くの戦略とパターンがあります。ここで詳しく説明する代わりに、Martin Fowler の記事「Patterns for Managing Source Code Branches」を参照してください。それを使用する方法が重要で、具体的なパターンや戦略よりも重要です。ブランチング戦略の文脈でのブランチング戦略と統合頻度の重要性も挙げる価値があります。チームは、どのバージョンのコードを環境に適用するかを管理するために、パスから本番へのブランチングパターンを使用します。一般的なパスから本番へのパターンには、リリースブランチや環境ブランチ（環境ブランチについては「ソースコードリポジトリからのコードのデリバリー」で説明されています）があります。

統合パターンについてのブランチングパターンは、コードベースで作業する人々が自分の作業をいつ、どのように統合するかを管理する方法を示しています。多くのチームは、フィーチャーブランチングまたは継続的統合を使用したメインライン統合パターンを使用しています。具体的なパターンや戦略よりも、それをどのように使用するかが重要です。チームのブランチの使用の有効性における最も重要な要素は、統合頻度です。すべてのコードをチーム内で同じ（メイン）ブランチにマージする頻度が高いほど、商業的なパフォーマンスが高くなることが DORA Accelerate の研究でわかっています。その結果、チームの全員がすべてのコードをマージする必要があります。たとえば、main または trunk に、少なくとも 1 日に 1 回以上の頻度でマージする必要があります。

マージは統合ではない 人々は、ビルドサーバーがブランチでテストを自動的に実行することを継続的統合と混同することがあります。継続的統合の実践と高いチームのパフォーマンスの相関は、コードベースで作業しているすべての変更を完全に統合することに基づいています。フィーチャーブランチパターンを使用している場合、現在のメインブランチを自分自身のブランチに頻繁にマージするかもしれませんが、自分の作業が終了するまで通常は自分の作業をメインに統合しません。他の人々も自分自身のフィーチャーブランチで同じように作業している場合、コードはみんなが自分のフィーチャーを終え、変更をメインブランチにマージするまで完全に統合されません。統合には、両方向にマージが含まれます - 個人が自分の変更をメインブランチに統合するだけでなく、メインを自分のブランチやローカルコードのコピーに統合します。したがって、継続的統合とは、それを日常的に行うことを意味します。

- 結局ブランチはどうすればいい
- 一応ブランチを分けて個人での開発をすることは有益だが，1 日に 1 回はマージすることが CI の原理では重要とされているみたい
