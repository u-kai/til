Pattern: Delivery-Time Project Integration Given multiple projects with dependencies between them, delivery-time project integration builds and tests each project individually before combining them. This approach integrates versions of code later than with build-time integration. Once the projects have been combined and tested, their code progresses together through the rest of the delivery cycle. As an example, the ShopSpinner application-infrastructure-stack project defines a cluster of virtual machines using the server image defined in the application-server-image project (see Figure 19-5). When someone makes a change to the infrastructure stack code, the delivery pipeline builds and tests the stack project on its own, as described in Chapter 9.
If the new version of the stack project passes those tests, it proceeds to the integration test phase, which tests the stack integrated with the last server image that passed its own tests. This stage is the integration point for the two projects. The versions of the projects then progress to later stages in the pipeline together. Figure 19-5. Example of integrating projects during delivery Motivation Building and testing projects individually before integrating them is one way to enforce clear boundaries and loose coupling between them. For example, a member of the ShopSpinner team implements a firewall rule in application-infrastructure-stack, which opens a TCP port defined in a configuration file in application-
server-image. They write code that reads the port number directly from that configuration file. But when they push their code, the test stage for the stack fails, because the configuration file from the other project is not available on the build agent. This failure is a good thing. It exposes coupling between the two projects. The team member can change their code to use a parameter value for the port number to open, setting the value later (using one of the patterns described in Chapter 7). The code will be more maintainable than a codebase with direct references to files across projects. Applicability Delivery-time integration is useful when you need clear boundaries between projects in a codebase, but still want to test and deliver versions of each project together. The pattern is difficult to scale to a large number of projects. Consequences Delivery-time integration puts the complexity of resolving and coordinating different versions of different projects into the delivery process. This requires a sophisticated delivery implementation, such as a pipeline (see “Delivery Pipeline Software and Services”). Implementation Delivery pipelines integrate different projects using the “fan-in” pipeline design. The stage that brings different projects together is called a fan-in stage, or project integration stage.2 How the stage integrates different projects depends on what types of projects it combines. In the example of a stack project that uses a server image, the stack code would be applied and passed a reference to the relevant version of the image. Infrastructure dependencies are retrieved from the code delivery repository (see “Using a Repository to Deliver Infrastructure Code”). The same set of combined project versions need to be applied in later stages of the delivery process. There are two common approaches to handling this.
One approach is to bundle all of the project code into a single artifact to use in later stages. For example, when two different stack projects are integrated and tested, the integration stage could zip the code for both projects into a single archive, promoting that to downstream pipeline stages. A GitOps flow would merge the projects to the integration stage branch, and then merge them from that branch to downstream branches. Another approach is to create a descriptor file with the version numbers of each project. For example: descriptor-version: 1.9.1

stack-project:
  name: application-infrastructure-stack
  version: 1.2.34

server-image-project:
  name: application-server-image
  version: 1.1.1 The delivery process treats the descriptor file as an artifact. Each stage that applies the infrastructure code pulls the individual project artifact from the delivery repository. A third approach would be to tag relevant resources with an aggregated version number. Related patterns The build-time project integration pattern (see “Pattern: Build-Time Project Integration”) integrates the projects at the beginning, rather than after some delivery activities have already taken place on the separate projects. The apply-time project integration pattern integrates the projects at each delivery stage that uses them together but doesn’t “lock” the versions.

パターン：納期プロジェクト統合
複数のプロジェクト間に依存関係がある場合、納期プロジェクト統合では各プロジェクトを個別にビルドおよびテストし、その後に統合します。このアプローチでは、ビルド時間プロジェクト統合よりも後のコードのバージョンを統合します。プロジェクトが結合されテストされた後、そのコードは納期のサイクルの残りの部分で一緒に進みます。例えば、ShopSpinnerアプリケーションインフラストラクチャスタックプロジェクトは、アプリケーションサーバイメージプロジェクトで定義されたサーバイメージを使用して仮想マシンのクラスタを定義します（図19-5を参照）。インフラストラクチャスタックコードに変更が加えられると、納期パイプラインは章9で説明されるように、スタックプロジェクトを単体でビルドおよびテストします。

スタックプロジェクトの新しいバージョンがこれらのテストに合格した場合、統合テストフェーズに進みます。このステージでは、統合テストがスタックと前回のサーバイメージを統合して行われます。このステージは、2つのプロジェクトの統合ポイントです。その後、プロジェクトのバージョンは一緒にパイプラインの後のステージに進みます。（図19-5を参照）。プロジェクトを統合する例　動機 プロジェクトを個別にビルドおよびテストしてから統合することは、それらの間に明確な境界線と緩やかな結合を強制する方法の一つです。例えば、ShopSpinnerチームのメンバーは、アプリケーションインフラストラクチャスタックでファイアウォールルールを実装します。これにより、アプリケーションサーバイメージの設定ファイルで定義されたTCPポートが開かれます。彼らはポート番号を設定ファイルから直接読み取るコードを書きます。しかし、コードをプッシュすると、スタックのテストステージが失敗します。なぜなら、ビルドエージェント上に他のプロジェクトの設定ファイルが存在しないためです。この失敗は良いことです。これにより、2つのプロジェクト間の結合が露呈されます。チームメンバーは、開くポート番号にパラメータ値を使用してコードを変更し、その値を後で設定できるようにします（第7章で説明されているパターンのいずれかを使用して）。コードは、プロジェクト間のファイルへの直接参照よりも保守しやすくなります。
適用性　納期プロジェクト統合は、コードベース内のプロジェクト間に明確な境界線が必要でありながら、各プロジェクトのバージョンをテストおよび納品したい場合に役立ちます。しかし、大量のプロジェクトにスケールするのは難しいです。
結果 生産期間プロジェクト統合は、異なるプロジェクトの異なるバージョンを解決および調整する複雑さを納期プロセスに置く必要があります。これには、パイプラインなどの高度な納期実装が必要です（「納期パイプラインソフトウェアおよびサービス」を参照）。実装納期パイプラインは、要素ごとのプロジェクトを統合するための「ファンイン」パイプラインデザインを使用します。異なるプロジェクトを統合するステージは、ファンインステージまたはプロジェクト統合ステージと呼ばれます。このステージが異なるプロジェクトをどのように統合するかは、組み合わせるプロジェクトの種類によって異なります。スタックプロジェクトがサーバイメージを使用している例では、スタックコードに該当バージョンのイメージへの参照が適用されます。インフラストラクチャの依存関係はコード配信リポジトリから取得されます（「インフラストラクチャコードの配信にリポジトリを使用する」を参照）。統合されたプロジェクトのバージョンセットは、納期プロセスの後の段階で適用する必要があります。これを処理するためには一般的に2つのアプローチがあります。1つ目のアプローチは、すべてのプロジェクトコードを単一のアーティファクトにまとめて、後の段階で使用する方法です。例えば、2つの異なるスタックプロジェクトが統合されてテストされる場合、統合ステージは両プロジェクトのコードを単一のアーカイブに圧縮し、それをダウンストリームのパイプラインステージに進めます。GitOpsフローでは、プロジェクトは統合ステージのブランチにマージされ、そのブランチからダウンストリームのブランチにマージされます。2つ目のアプローチは、各プロジェクトのバージョン番号が記載されたディスクリプタファイルを作成する方法です。例えば：descriptor-version: 1.9.1
stack-project:
  name: application-infrastructure-stack
  version: 1.2.34
server-image-project:
  name: application-server-image
  version: 1.1.1
納期プロセスは、ディスクリプタファイルをアーティファクトとして扱います。インフラストラクチャコードを適用する各ステージは、ディスクリプタファイルから各個々のプロジェクトアーティファクトを配送リポジトリから取得します。3つ目のアプローチとして、関連するリソースに集約バージョン番号を付ける方法が考えられます。
関連パターン ビルド時間プロジェクト統合パターン（「パターン：ビルド時間プロジェクト統合」を参照）は、別々のプロジェクトですでにいくつかの納期活動が行われた後ではなく、最初にプロジェクトを統合します。適用時間プロジェクト統合パターンは、それらを一緒に使用する納期ステージごとにプロジェクトを統合しますが、バージョンを「ロック」しません。