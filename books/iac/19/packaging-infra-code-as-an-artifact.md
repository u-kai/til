Packaging Infrastructure Code as an Artifact With some tools, “preparing the code for use” involves assembling the files into a package file with a specific format, an artifact. This process is typical with general-purpose programming languages like Ruby (gems), JavaScript (NPM), and Python (Python packages used with the pip installer). Other package formats for installing files and applications for specific operating systems include .rpm, .deb, .msi, and NuGet (Windows). Not many infrastructure tools have a package format for their code projects. However, some teams build their own artifacts for these, bundling stack code or server code into ZIP files or “tarballs” (tar archives
compressed with gzip). Some teams use OS packaging formats, creating RPM files that unpack Chef Cookbook files onto a server, for example. Other teams create Docker images that include stack project code along with the stack tool executable. Other teams don’t package their infrastructure code into artifacts, especially for tools that don’t have a native package format. Whether they do this depends on how they publish, share, and use their code, which depends on what kind of repository they use. Using a Repository to Deliver Infrastructure Code Teams use a source code repository for storing and managing changes to their infrastructure source code. They often use a separate repository for storing code that is ready for delivery to environments and instances. Some teams, as we’ll see, use the same repository for both purposes. Conceptually, the build stage separates these two repository types, taking code from the source code repository, assembling it, and then publishing it to the delivery repository (see Figure 19-2).
The delivery repository usually stores multiple versions of a given project’s code. Promotion phases, as described shortly, mark versions of the project code to show which stage they have progressed to; for example, whether it’s ready for integration testing or production. An apply activity pulls a version of the project code from the delivery repository and applies it to a particular instance, such as the SIT environment or the PROD environment. There are a few different ways to implement a delivery repository. A given system may use different repository implementations for different types of projects. For example, they may use a tool-specific repository, like Chef Server, for projects that use that tool. The same system might use a general file storage service, such as an S3 bucket, for a project using a tool like Packer that doesn’t have a package format or specialized repository. There are several types of delivery code repository implementations.
Specialized artifact repository Most of the package formats discussed in the previous section have a package repository product, service, or standard that multiple products and services may implement. There are multiple repository products and hosted services for ​.rpm, .deb, .gem, and .npm files. Some repository products, like Artifactory and Nexus, support multiple package formats. Teams in an organization that runs one of these sometimes use them to store their artifacts, such as ZIP files and tarballs. Many cloud platforms include specialized artifact repositories, such as server image storage. The ORAS (OCI Registry As Storage) project offers a way to use artifact repositories originally designed for Docker images as a repository for arbitrary types of artifacts. If an artifact repository supports tags or labels, you can use these for promotion. For example, to promote a stack project artifact to the system integration test stage, you might tag it with SIT_STAGE=true, or Stage=SIT. Alternatively, you might create multiple repositories within a repository server, with one repository for each delivery stage. To promote an artifact, you copy or move the artifact to the relevant repository. Tool-specific repository Many infrastructure tools have a specialized repository that doesn’t involve packaged artifacts. Instead, you run a tool that uploads your project’s code to the server, assigning it a version. This works nearly the same way as a specialized artifact repository, but without a package file. Examples of these include Chef Server (self-hosted), Chef Community Cookbooks (public), and Terraform Registry (public modules). General file storage repository Many teams, especially those who use their own formats to store infrastructure code projects for delivery, store them in a general-purpose file storage service or product. This might be a file server, web
server, or object storage service. These repositories don’t provide specific functionality for handling artifacts, such as release version numbering. So you assign version numbers yourself, perhaps by including it in the filename (for example, my-stack-v1.3.45.tgz). To promote an artifact, you might copy or link it to a folder for the relevant delivery stage. Delivering code from a source code repository Given that source code is already stored in a source repository, and that many infrastructure code tools don’t have a package format and toolchain for treating their code as a release, many teams simply apply code to environments from their source code repository. Applying code from the main branch (trunk) to all of the environments would make it difficult to manage different versions of the code. So most teams doing this use branches, often maintaining a separate branch for each environment. They promote a version of the code to an environment by merging it to the relevant branch. GitOps combines this practice with continuous synchronization (see “Apply Code Continuously” and “GitOps” for more detail). Using branches for promoting code can blur the distinction between editing code and delivering it. A core principle of CD is never changing code after the build stage.1 While your team may commit to never editing code in branches, it’s often difficult to maintain this discipline.
インフラストラクチャコードをアーティファクトとしてパッケージ化するいくつかのツールでは、「コードを使用できるように準備する」ということは、ファイルを特定の形式のパッケージファイル（アーティファクト）に組み立てることを意味します。これは、Ruby（gems）、JavaScript（NPM）、および Python（pip インストーラで使用される Python パッケージ）などの汎用プログラミング言語で一般的なプロセスです。特定のオペレーティングシステムにファイルやアプリケーションをインストールするための他のパッケージ形式には、.rpm、.deb、.msi、および NuGet（Windows）があります。多くのインフラストラクチャツールには、コードプロジェクトのためのパッケージ形式はありません。しかし、一部のチームは、スタックコードやサーバーコードを ZIP ファイルや「tarballs」（gzip で圧縮された tar アーカイブ）にバンドルして、独自のアーティファクトを作成します。たとえば、RPM ファイルを使用して Chef Cookbook ファイルをサーバーに展開するチームもあります。また、スタックツールの実行可能ファイルとともにスタックプロジェクトコードを含む Docker イメージを作成するチームもあります。特にネイティブのパッケージ形式を持たないツールの場合、他のチームはインフラストラクチャコードをアーティファクトにパッケージ化しません。これを行うかどうかは、彼らがどのようにコードを公開、共有、使用するかに依存し、それは彼らがどのようなリポジトリを使用するかに依存します。インフラストラクチャコードの配信にリポジトリを使用するチームは、ソースコードリポジトリを使用してインフラストラクチャソースコードの変更を格納および管理するためのソースコードリポジトリを使用します。彼らはしばしば、環境とインスタンスに配信するためのコードを格納する別個のリポジトリを使用します。後で説明するように、一部のチームは両方の目的に同じリポジトリを使用します。概念的には、ビルドステージはこれらの 2 つのリポジトリのタイプを分離し、ソースコードリポジトリからコードを取得し、それを組み立てて配信リポジトリに公開します（図 19-2 を参照）。配信リポジトリは通常、特定のプロジェクトのコードの複数のバージョンを格納します。後で説明するプロモーションフェーズでは、プロジェクトコードのバージョンを進行したステージを示すためにマークします。たとえば、統合テストまたは本番用に準備ができているかどうかなどです。適用アクティビティは、プロジェクトコードのバージョンを配信リポジトリから取得し、SIT 環境や PROD 環境などの特定のインスタンスに適用します。配信リポジトリを実装するためのいくつかの異なる方法があります。特定のアーティファクトリポジトリ-前のセクションで説明した多くのパッケージ形式には、複数の製品やサービスが実装するパッケージリポジトリの製品、サービス、または標準があります。.rpm、.deb、.gem、および.npm ファイル用の複数のリポジトリ製品とホスティングサービスがあります。Artifactory や Nexus などの一部のリポジトリ製品は、複数のパッケージ形式をサポートしています。このような製品を実行している組織のチームは、ZIP ファイルや tarball などのアーティファクトを保存するためにこれらを使用することがあります。多くのクラウドプラットフォームには、サーバーイメージのストレージなどの特化したアーティファクトリポジトリも含まれています。OCI Registry As Storage プロジェクトは、Docker イメージ用に設計されたアーティファクトリポジトリを任意のタイプのアーティファクトのリポジトリとして使用する方法を提供しています。アーティファクトリポジトリがタグやラベルをサポートしている場合、これらをプロモーションに使用できます。たとえば、スタックプロジェクトアーティファクトをシステム統合テストステージにプロモートする場合、SIT_STAGE=true または Stage=SIT とタグ付けすることができます。または、配信ステージごとに 1 つのリポジトリサーバー内に複数のリポジトリを作成する場合もあります。アーティファクトをプロモートするには、アーティファクトを関連するリポジトリにコピーまたは移動します。ツール固有のリポジトリ-多くのインフラストラクチャツールは、パッケージ化されたアーティファクトを使用しない特殊なリポジトリを持っています。代わりに、プロジェクトのコードをサーバーにアップロードし、バージョンを割り当てるツールを実行します。これは、特殊なアーティファクトリポジトリとほぼ同じ方法で機能しますが、パッケージファイルはありません。これには、Chef Server（セルフホスト型）、Chef Community Cookbooks（公開）、Terraform Registry（パブリックモジュール）などがあります。一般的なファイルストレージリポジトリ-特に自社のフォーマットを使用してインフラストラクチャコードプロジェクトを配信するチームの多くは、一般的な目的のファイルストレージサービスや製品にそれらを格納します。これはファイルサーバー、ウェブサーバー、またはオブジェクトストレージサービスなどです。これらのリポジトリは、リリースバージョンのナンバリングなどのアーティファクトの処理のための特定の機能を提供しません。そのため、自分でバージョン番号を割り当てることがあります。たとえば、ファイル名にそれを含めることができます（例：my-stack-v1.3.45.tgz）。アーティファクトをプロモートするには、関連する配信ステージ用のフォルダにコピーまたはリンクすることがあります。ソースコードリポジトリからコードを配信するソースコードがすでにソースリポジトリに格納されており、多くのインフラストラクチャコードツールにはコードをリリースとして扱うパッケージ形式とツールチェーンがないため、多くのチームは単純にソースコードリポジトリから環境にコードを適用します。すべての環境に対してメインブランチ（トランク）からコードを適用すると、コードの異なるバージョンを管理することが困難になります。そのため、これを行う多くのチームはブランチを使用し、各環境のために別々のブランチを維持することがよくあります。コードのバージョンを環境にプロモートするには、それを関連するブランチにマージすることによって行います。GitOps は、このプラクティスを連続的な同期と組み合わせます（詳細については、「コードの継続的な適用」と「GitOps」を参照してください）。コードをプロモートするためのブランチの使用は、コードの編集と配信の区別を曖昧にすることがあります。CD の基本原則は、ビルドステージ以降ではコードを変更しないことです。1 チームがブランチでコードを編集しないことを確約するかどうかは、しばしば難しいものです。

- 考えまとめ

  - pip とか npm をとかを自分たち用のライブラリとして利用できるようにするのが結構大事なんかも
  - ただ，os のパッケージ形式であればコンテナがその役割を果たしそう
  - 配信レポジトリってのが，GitHub のようなソースコードのレポジトリとは別そう
    - ECR がその一種？
  - やっぱタグをつかってステージを分けたり，なんらかのタグ活用をしたい
  - Terraform Registry は Terraform のパッケージとかテンプレートが公開されている感じのやつだった
  - 自分でナンバリングするのは嫌だな

    - しかもダサい

  - デプロイする環境を変えるためにブランチを切るのはなかなか有用？
  - CD ではコードを変更しない
  - これを使って，コード変更をコントロールするためにブランチを切る，というよりかは，様々なバージョン，環境にデプロイするためにブランチを切る感じか？
  - ブランチを切ってコード変更を他のブランチから保護する，といったことは逆効果ということが多いので避けたい
