Pattern: Apply-Time Project Integration Also known as: decoupled delivery or decoupled pipelines.
Apply-time project integration involves pushing multiple projects through delivery stages separately. When someone changes a project’s code, the pipeline applies the updated code to each environment in the delivery path for that project. This version of the project code may integrate with different versions of upstream or downstream projects in each of these environments. In the ShopSpinner example, the application-infrastructure-stack project depends on networking structures created by the shared-network-stack project. Each project has its own delivery stages, as illustrated in Figure 19-6.
Integration between the projects takes place by applying the application-infrastructure-stack code to an environment. This operation creates or changes a server cluster that uses network structures (for example, subnets) from the shared networking. This integration happens regardless of which version of the shared networking stack is in place in a given environment. So the integration of versions happens separately each time the code is applied. Motivation Integrating projects at apply time minimizes coupling between projects. Different teams can push changes to their systems to production without needing to coordinate, and without being blocked by problems with a change to another team’s projects. Applicability This level of decoupling suits organizations with an autonomous team structure. It also helps with larger-scale systems, where coordinating releases and delivering them in lock-step across hundreds or thousands of engineers is impractical. Consequences This pattern moves the risk of breaking dependencies across projects to the apply-time operation. It doesn’t ensure consistency through the pipeline. If someone pushes a change to one project through the pipeline faster than changes to other projects, they will integrate with a different version in production than they did in test environments. Interfaces between projects need to be carefully managed to maximize compatibility across different versions on each side of any given dependency. So this pattern requires more complexity in designing, maintaining, and testing dependencies and interfaces.
Implementation In some respects, designing and implementing decoupled builds and pipelines using apply-time integration is simpler than alternative patterns. Each pipeline builds, tests, and delivers a single project. Chapter 17 discusses strategies for integrating different infrastructure stacks. For example, when a stage applies the application-infrastructure-stack, it needs to reference networking structures created by the shared-network-stack. That chapter explains some techniques for sharing identifiers across infrastructure stacks. There is no guarantee of which version of another project’s code was used in any given environment. So teams need to identify dependencies between projects clearly and treat them as contracts. The shared-network-stack exposes identifiers for the networking structures that other projects may use. It needs to expose these in a standardized way, using one of the patterns described in Chapter 17. As explained in “Using Test Fixtures to Handle Dependencies”, you can use test fixtures to test each stack in isolation. With the ShopSpinner example, the team would like to test the application-infrastructure-stack project without using an instance of shared-network-stack. The network stack defines redundant and complex infrastructure that isn’t needed to support test cases. So the team’s test setup can create a stripped-down set of networking. Doing this also reduces the risk that the application stack evolves to assume details of the network stack’s implementation. A team that owns a project that other projects depend on can implement contract tests that prove its code meets expectations. The shared-network-stack can verify that the networking structures — subnets — are created and that their identifiers are exposed using the mechanism that other projects use to consume them. Make sure that contract tests are clearly labeled. If someone makes a code change that causes the test to fail, they should understand that they may be breaking other projects, rather than thinking they only need to update the test to match their change.
Many organizations find consumer-driven contract (CDC) testing useful. With this model, teams working on a consumer project that depends on resources created in a provider project write tests that run in the provider project’s pipeline. This helps the provider team to understand the expectations of consumer teams. Related patterns The build-time project integration pattern (“Pattern: Build-Time Project Integration”) is at the opposite end of the spectrum from this pattern. That pattern integrates projects once, at the beginning of the delivery cycle, rather than each time. Delivery-time project integration (“Pattern: Delivery-Time Project Integration”) also integrates projects once, but at a point during the delivery cycle rather than at the beginning. “Frying a Server Instance” illustrates apply-time integration used for server provisioning. Dependencies like server configuration modules are applied each time a new server instance is created, usually taking the latest version of the server module that was promoted to the relevant stage.

パターン：適用時間プロジェクト統合
別名：分離されたデリバリーまたは分離されたパイプライン

適用時間のプロジェクト統合では、複数のプロジェクトを個別にデリバリーステージに送り込みます。プロジェクトのコードが変更されると、パイプラインはそのプロジェクトのデリバリーパスの各環境に更新されたコードを適用します。このプロジェクトコードのバージョンは、それぞれの環境で上流または下流のプロジェクトの異なるバージョンと統合する可能性があります。ShopSpinnerの例では、application-infrastructure-stackプロジェクトはshared-network-stackプロジェクトによって作成されるネットワーキング構造に依存しています。それぞれのプロジェクトには図19-6に示すように独自のデリバリーステージがあります。

プロジェクト間の統合は、application-infrastructure-stackコードを環境に適用することで行われます。この操作により、共有ネットワーキングからネットワーク構造（サブネットなど）を使用するサーバークラスタが作成または変更されます。この統合は、特定の環境で配置されている共有ネットワーキングスタックのバージョンに関係なく行われます。したがって、コードが適用されるたびにバージョンの統合が個別に行われます。

動機
適用時間でプロジェクトを統合することで、プロジェクト間の結合を最小限に抑えることができます。異なるチームは、他のチームのプロジェクトの変更による問題によるブロックや調整なしに、自身のシステムの変更を本番環境にプッシュすることができます。

適用範囲
このレベルの分離は、自律的なチーム構造を持つ組織に適しています。また、数百人または数千人のエンジニアによるリリースの調整とロックステップでのデリバリーは実現不可能な、より大規模なシステムにも役立ちます。

結果
このパターンは、依存関係をプロジェクト間で破壊するリスクを適用時間の操作に移動します。パイプラインを通じて一貫性を確保することはありません。もし誰かが他のプロジェクトよりも早くパイプラインを通じてプロジェクトの変更をプッシュした場合、テスト環境とは異なるバージョンで本番環境に統合されることになります。プロジェクト間のインターフェースは、与えられた依存関係の両側の異なるバージョン間で互換性を最大化するために注意深く管理する必要があります。そのため、このパターンでは、依存関係とインターフェースの設計、維持、テストにより複雑さが要求されます。

実装
適用時間の統合を使用して分離されたビルドとパイプラインを設計・実装することは、他のパターンと比べて比較的簡単です。各パイプラインは1つのプロジェクトをビルド、テスト、デリバリーします。第17章では、異なるインフラストラクチャスタックを統合するための戦略について説明しています。例えば、ステージがapplication-infrastructure-stackを適用する場合、shared-network-stackによって作成されたネットワーキング構造を参照する必要があります。その章では、インフラストラクチャスタック間で識別子を共有するためのいくつかの技術について説明しています。特定の環境で他のプロジェクトのコードのどのバージョンが使用されたかは保証されません。そのため、チームはプロジェクト間の依存関係を明確に特定し、それらを契約として扱う必要があります。shared-network-stackは、他のプロジェクトが使用するネットワーキング構造（サブネット）の識別子を公開する必要があります。そのためのパターンは第17章で説明されています。「依存関係を処理するためのテストフィクスチャの使用」というセクションでは、各スタックを独立してテストするためにテストフィクスチャを使用できることが説明されています。ShopSpinnerの例では、チームはshared-network-stackのインスタンスを使用せずにapplication-infrastructure-stackプロジェクトをテストしたいと考えています。ネットワークスタックは、テストケースをサポートするために不要な冗長で複雑なインフラストラクチャを定義しています。したがって、チームのテストセットアップでは、最小限のネットワーキングを作成することができます。これにより、アプリケーションスタックがネットワークスタックの実装の詳細を前提としないようにするリスクも低減されます。他のプロジェクトが依存するプロジェクトを所有するチームは、コードが期待通りであることを証明する契約テストを実装することができます。shared-network-stackは、ネットワーキング構造（サブネット）が作成され、他のプロジェクトがそれらを消費するために使用するメカニズムを使用して識別子が公開されていることを検証することができます。契約テストが明確にラベル付けされていることを確認してください。もし誰かがコードの変更によってテストが失敗すると、彼らは自身の変更に一致させるためにテストを更新するだけではなく、他のプロジェクトが壊れる可能性があることを理解する必要があります。

多くの組織は、コンシューマー駆動のコントラクト（CDC）テストが有用です。このモデルでは、プロバイダープロジェクトで作成されたリソースに依存するコンシューマープロジェクトで作成されたテストをプロバイダープロジェクトのパイプラインで実行します。これにより、プロバイダーチームはコンシューマーチームの期待を理解することができます。

関連するパターン
ビルド時間プロジェクト統合パターン（「パターン：ビルド時間プロジェクト統合」）は、このパターンとは対極に位置しています。このパターンでは、プロジェクトをデリバリーサイクルの始めに1回だけ統合します。デリバリー時間プロジェクト統合（「パターン：デリバリー時間プロジェクト統合」）も1回だけプロジェクトを統合しますが、デリバリーサイクルの中での特定のタイミングで統合します。「サーバーのインスタンスをフライアウトする」は、サーバープロビジョニングにおいて適用時間の統合を示した例です。サーバーの構成モジュールのような依存関係は、新しいサーバーインスタンスが作成されるたびに適用されますが、通常は関連するステージに昇格した最新バージョンのサーバーモジュールが使用されます。