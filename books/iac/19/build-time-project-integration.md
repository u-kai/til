Pattern: Build-Time Project Integration The build-time project integration pattern carries out build activities across multiple projects. Doing this involves integrating the dependencies between them and setting the code versions across the projects. The build process often involves building and testing each of the constituent projects before building and testing them together (see Figure 19-4). What distinguishes this pattern from alternatives is that it produces either a single artifact for all of the projects, or a set of artifacts that are versioned, promoted, and applied as a group.
In this example, a single build stage produces a server image using multiple server configuration projects. The build stage may include multiple steps, such as building and testing the individual server configuration modules. But the output — the server image — is composed of code from all of its constituent projects. Motivation Building the projects together resolves any issues with dependencies early. Doing this gives fast feedback on conflicts, and creates a high level of consistency across the codebase through the delivery process into
production. Project code integrated at build time is consistent throughout the entire delivery cycle. The same version of code is applied at every stage of the process through to production. Applicability The use of this pattern versus one of the alternatives is mostly a matter of preference. It depends on which set of trade-offs you prefer, and on your team’s ability to manage the complexity of cross-project builds. Consequences Building and integrating multiple projects at runtime is complex, especially for very large numbers of projects. Depending on how you implement the build, it may lead to slower feedback times. Using build-time project integration at scale requires sophisticated tooling to orchestrate builds. Larger organizations that use this pattern across large codebases, such as Google and Facebook, have teams dedicated to maintaining in-house tooling. Some build tools are available to build very large numbers of software projects, as discussed under implementation. But this approach is not used as widely in the industry as building projects separately, so there are not as many tools and reference materials to help. Because projects are built together, boundaries between them are less visible than with other patterns. This may lead to tighter coupling across projects. When this happens, it can be hard to make a small change without affecting many other parts of the codebase, increasing the time and risk of changes. Implementation Storing all of the projects for the build in a single repository, often called a monorepo, simplifies building them together by integrating code versioning across them (see “Monorepo — One Repository, One Build”).
Most software build tools, like Gradle, Make, Maven, MSBuild, and Rake, are used to orchestrate builds across a modest number of projects. Running builds and tests across a very large number of projects can take a long time. Parallelization can speed up this process by building and testing multiple projects in different threads, processes, or even across a compute grid. But this requires more compute resources. A better way to optimize large-scale builds is using a directed graph to limit building and testing to the parts of the codebase that have changed. Done well, this should reduce the time needed to build and test after a commit so that it only takes a little longer than running a build for separate projects. There are several specialized build tools designed to handle very large-scale, multi-project builds. Most of these were inspired by internal tools created at Google and Facebook. Some of these tools include Bazel, Buck, Pants, and Please. Related patterns The alternatives to integrating project versions at build time are to do so at delivery time (see “Pattern: Delivery-Time Project Integration”) or apply time (see “Pattern: Apply-Time Project Integration”). The strategy of managing multiple projects in a single repository (“Monorepo — One Repository, One Build”), although not a pattern, supports this pattern. The example I’ve used for this pattern, Figure 19-4, applies server configuration code when creating a server image (see “Baking Server Images”). The immutable server pattern (“Pattern: Immutable Server”) is another example of build-time integration over delivery-time integration. Although not documented as a pattern in this book, many project builds resolve dependencies on third-party libraries at build time, downloading them and bundling them with the deliverable. The difference is that those dependencies are not built and tested with the project that uses them. When those dependencies come from other projects within the same organization, it’s an example of delivery-time project integration (see “Pattern: Delivery-Time Project Integration”).
Is It Monorepo or Build-Time Project Integration? Most descriptions of the monorepo strategy for organizing a codebase include building all of the projects in the repository together — what I’ve called build-time project integration. I chose not to name this pattern monorepo because that name hinges on the use of a single code repository, which is an implementation option. I’ve known teams to manage multiple projects in a single repository without building them together. Although these teams often call their codebase a monorepo, they aren’t using the pattern described here. On the other side, it’s technically possible to check out projects from separate repositories and build them together. This fits the pattern described here since it integrates project versions at build time. However, doing this complicates correlating and tracing source code versions to builds, for example, when debugging production issues.

パターン：ビルド時のプロジェクト統合
ビルド時のプロジェクト統合パターンは、複数のプロジェクトにわたるビルド活動を実行します。これには、それらの間の依存関係を統合し、プロジェクト間でコードのバージョンを設定することが含まれます。ビルドプロセスでは、各構成プロジェクトを個別にビルドおよびテストしてから、それらを一緒にビルドおよびテストすることがよく行われます（図19-4を参照）。このパターンを他の代替手段と区別するものは、プロジェクト全体の単一のアーティファクト、またはバージョン管理、プロモーション、およびグループとして適用されるアーティファクトのセットを生成することです。

この例では、単一のビルドステージで、複数のサーバー構成プロジェクトを使用してサーバーイメージを作成します。ビルドステージには、個々のサーバー構成モジュールのビルドおよびテストなど、複数のステップが含まれる場合もあります。しかし、出力であるサーバーイメージは、その構成プロジェクトのコードから構成されます。

動機
プロジェクトを一緒にビルドすることで、依存関係に関する問題を早期に解決することができます。これにより、競合のフィードバックが速くなり、デリバリープロセス全体を通じてコードベースの一貫性が高まります。ビルド時に統合されたプロジェクトコードは、デリバリーサイクル全体で一貫性があります。コードの同じバージョンがプロダクションまでのプロセスのすべてのステージで適用されます。

適用性
このパターンを他の代替手段と比較して使用するかどうかは、主に好みの問題です。どのトレードオフのセットを選ぶか、およびチームがクロスプロジェクトビルドの複雑さを管理できるかに依存します。

結果
ランタイムで複数のプロジェクトをビルドおよび統合することは、特に非常に多数のプロジェクトの場合、複雑です。ビルドの実装方法によっては、フィードバックの時間が遅くなる場合があります。大規模なビルド時のプロジェクト統合を効果的に使用するためには、ソフトウェアビルドのオーケストレートに高度なツールが必要です。GoogleやFacebookなど、大規模なコードベース全体でこのパターンを使用する大企業は、内部ツールの維持に専任のチームを持っています。多数のソフトウェアプロジェクトをビルドするためのいくつかのビルドツールが利用可能ですが、これらはプロジェクト個別にビルドするよりも業界で広く使用されていないため、サポートするツールやリファレンス資料は多くありません。プロジェクトが一緒にビルドされるため、それらの間の境界は他のパターンと比較してはっきりと見えにくくなります。これにより、プロジェクト間の密結合が生じる可能性があります。これが発生すると、他の部分に影響を及ぼさずに小さな変更を行うことは難しくなり、変更にかかる時間とリスクが増大します。

実装
ビルドのためのすべてのプロジェクトを単一のリポジトリに保存することは、通常「モノリポ」と呼ばれる単一のリポジトリを使用することで、コードバージョニングを統合するためにそれらを一緒にビルドすることを容易にします。

Gradle、Make、Maven、MSBuild、Rakeなどのほとんどのソフトウェアビルドツールは、数プロジェクトをまたがるビルドをオーケストレートするために使用されます。非常に多数のプロジェクトを対象とするビルドとテストの実行には時間がかかる場合があります。並列処理を使用することで、異なるスレッド、プロセス、またはコンピュートグリッド上で複数のプロジェクトをビルドおよびテストすることで、このプロセスを高速化することができます。ただし、これにはより多くのコンピュートリソースが必要です。大規模なビルドを最適化する別の方法は、変更されたコードベースの一部に対してビルドとテストを制限するために、有向グラフを使用することです。うまく行けば、コミット後のビルドとテストに必要な時間を減らし、個別のプロジェクト向けのビルドの実行よりもわずかに長い時間しかかかりません。非常に大規模なマルチプロジェクトビルドを処理するために設計されたいくつかの専門のビルドツールがあります。これらの多くは、GoogleやFacebookで作成された内部ツールに触発されたものです。これらのツールには、Bazel、Buck、Pants、Pleaseなどがあります。

関連するパターン
ビルド時にプロジェクトバージョンを統合する代替手段は、デリバリー時（「パターン：デリバリー時のプロジェクト統合」を参照）または適用時（「パターン：適用時のプロジェクト統合」を参照）に行う方法です。「モノリポ - 単一のリポジトリ、単一のビルド」という方法は、パターンではないが、このパターンをサポートします。このパターンの例で使用した図19-4では、サーバーイメージの作成時にサーバー構成コードが適用されます（「サーバーイメージの作成」を参照）。イミュータブルサーバーパターン（「パターン：イミュータブルサーバー」）は、デリバリー時の統合ではなく、ビルド時の統合の別の例です。この本ではパターンとして文書化されていませんが、多くのプロジェクトビルドでは、サードパーティライブラリへの依存関係をビルド時に解決し、ダウンロードしてリリース可能なものと一緒にバンドルすることがあります。違いは、それらの依存関係が使用するプロジェクト内の他のプロジェクトから来る場合、それはデリバリー時のプロジェクト統合の例です（「パターン：デリバリー時のプロジェクト統合」を参照）。

モノレポまたはビルド時のプロジェクト統合か？
コードベースを組織するためのモノレポ戦略のほとんどの説明は、リポジトリ内のすべてのプロジェクトを一緒にビルドすることを含んでいます-私がビルド時のプロジェクト統合と呼んでいることです。私はこのパターンをモノレポとは名付けませんでしたが、その名前は単一のコードリポジトリの使用に依存していますが、これは実装の選択肢です。私は複数のプロジェクトを単一のリポジトリで管理するチームが、それらを一緒にビルドせずに管理することも知っています。これらのチームは自分たちのコードベースをしばしばモノレポと呼んでいますが、ここで説明されているパターンは使用していません。他方、別々のリポジトリからプロジェクトをチェックアウトして一緒にビルドすることも理論的に可能です。これはビルド時にプロジェクトバージョンを統合するためのパターンに合致します。ただし、これを行うと、デバッグ時などの場合に、ソースコードのバージョンとビルドを関連付けてトレースすることが複雑になります。