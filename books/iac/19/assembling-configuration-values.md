Assembling Configuration Values Marshaling and resolving configuration values can be one of the more complex wrapper script tasks. Consider a system like the ShopSpinner example that involves multiple delivery environments, multiple production customer instances, and multiple infrastructure components. A simple, one-level set of configuration values, with one file per combination of component, environment, and customer, requires quite a few files. And many of the values are duplicated.
Imagine a value of store_name for each customer, which must be set for every instance of each component. The team quickly decides to set that value in one location with shared values and add code to its wrapper script to read values from the shared configuration and the per-component configuration. They soon discover they need some shared values across all of the instances in a given environment, creating a third set of configuration. When a configuration item has different values in multiple configuration files, the script must resolve it following a precedence hierarchy. This type of parameter hierarchy is a bit messy to code. It’s harder for people to understand when introducing new parameters, configuring the right values, and tracing and debugging the values used in any given instance. Using a configuration registry puts a different flavor onto the complexity. Rather than chasing parameter values across an array of files, you chase them through various subtrees of the registry. Your wrapper script might handle resolving values from different parts of the registry, as with the configuration files. Or you might use a script to set registry values beforehand, so it owns the logic for resolving a hierarchy of default values to set the final value for each instance. Either approach creates headaches for setting and tracing the origin of any given parameter value.

構成値のマーシャリングと解決は、より複雑なラッパースクリプトのタスクの一つです。ShopSpinner の例のようなシステムでは、複数の配信環境、複数のプロダクションカスタマーインスタンス、複数のインフラストラクチャコンポーネントが関わっています。コンポーネント、環境、およびカスタマーの組み合わせごとに 1 つのファイルを持つ、単純な 1 レベルの構成値のセットでは、かなりの数のファイルが必要になります。そして、多くの値が重複しています。
お客様ごとに設定する必要のある store_name の値を想像してみてください。それは各コンポーネントの各インスタンスに設定する必要があります。チームはすぐに、共有された値を持つ 1 つの場所にその値を設定し、ラッパースクリプトに共有構成とコンポーネントごとの構成から値を読み取るためのコードを追加することを決定します。彼らはすぐに、特定の環境のすべてのインスタンス間で共有される値が必要になることがわかり、これにより第三の構成セットが作成されます。複数の構成ファイルで異なる値を持つ場合、スクリプトは優先度のヒエラルキーに従ってそれを解決する必要があります。このタイプのパラメータヒエラルキーは、コーディングがやや複雑です。新しいパラメータを導入し、適切な値を設定し、特定のインスタンスで使用される値をトレースおよびデバッグするときに、人々にとって理解しにくくなります。構成レジストリを使用すると、複雑さに異なる要素が加わります。ファイルの配列を超えてパラメータ値を追跡するのではなく、それらをレジストリのさまざまなサブツリーを通じて追跡します。ラッパースクリプトは、構成ファイルと同様に、レジストリのさまざまな部分から値を解決することができます。あるいは、スクリプトを使用して事前にレジストリの値を設定し、各インスタンスの最終的な値を設定するためのデフォルト値のヒエラルキーを解決するロジックを所有することもできます。いずれのアプローチも、特定のパラメータ値の設定と起源のトレースに頭痛を引き起こします。

- ある種講義の DRY?
- 設定値以外はおなじ，みたいなことって，どの範囲でどんくらいできて，どのくらいであれば適切なのかなあ．
