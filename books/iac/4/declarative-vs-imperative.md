Declarative Versus Imperative Languages for Infrastructure Declarative code is useful for defining the desired state of a system, particularly when there isn’t much variation in the outcomes you want. It’s common to define the shape of some infrastructure that you would like to repeat with a high level of consistency. For example, you normally want all of the environments supporting a release process to be nearly identical (see “Delivery Environments”). So declarative code is good for defining reusable environments, or parts of environments(per the reusable stack pattern discussed in “Pattern: Reusable Stack”). You can even sup​port limited variations between instances of infrastructure defined with declarative code using instance configuration parameters, as described in Chapter 7. However, sometimes you want to write reusable, sharable code that can produce different outcomes depending on the situation. For example, the ShopSpinner team writes code that can build infrastructure for different application servers. Some of these servers are public-facing, so they need appropriate gateways, firewall rules, routes, and logging. Other servers are internally facing, so they have different connectivity and security requirements. The infrastructure might also differ for applications that use messaging, data storage, and other optional elements. As declarative code supports more complex variations, it involves increasing amounts of logic. At some point, you should question why you are writing complex logic in YAML, JSON, XML, or some other declarative language. So programmable, imperative languages are more appropriate for building libraries and abstraction layers, as discussed in more detail in Chapter 16. And these languages tend to have better support for writing, testing, and managing libraries.
インフラストラクチャのための宣言的言語と命令的言語 宣言的なコードは、システムの望ましい状態を定義するのに役立ちます。特に、望ましい結果に多くの変動がない場合に有用です。高いレベルの一貫性を持つように繰り返し実行したいインフラストラクチャの形状を定義することは一般的です。たとえば、「提供環境」で説明するように、リリースプロセスをサポートするすべての環境がほぼ同じであることが通常です。したがって、宣言的なコードは再利用可能な環境や環境の一部を定義するために適しています（「パターン：再利用可能なスタック」で説明されている再利用可能なスタックパターンに従います）。また、インスタンス構成パラメータを使用して、宣言的なコードで定義されたインフラストラクチャのインスタンス間で限られた変化をサポートすることもできます（第7章で説明されています）。ただし、場合によっては、状況に応じて異なる結果を生み出すことができる再利用可能な共有コードを書きたい場合があります。たとえば、ShopSpinnerチームは、異なるアプリケーションサーバーのインフラストラクチャを構築できるコードを書いています。これらのサーバーの一部は公開向けであり、適切なゲートウェイ、ファイアウォールルール、ルート、およびログが必要です。他のサーバーは内部向けであり、異なる接続性とセキュリティ要件を持っています。また、メッセージング、データストレージ、その他のオプション要素を使用するアプリケーションのためのインフラストラクチャも異なる場合があります。宣言的なコードがより複雑なバリエーションをサポートするにつれて、それにはますます多くのロジックが含まれます。ある時点で、なぜYAML、JSON、XML、または他の宣言的言語で複雑なロジックを書いているのか疑問に思うべきです。したがって、プログラム可能な命令的な言語は、ライブラリや抽象化レイヤを構築するためにはより適しています（第16章で詳しく説明します）。また、これらの言語はライブラリの作成、テスト、管理をサポートする機能がより優れています。