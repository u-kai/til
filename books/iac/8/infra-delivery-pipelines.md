Infrastructure Delivery Pipelines A CD pipeline combines the implementation of progressive testing with the delivery of code across environments in the path to production.13 Chapter 19 drills into details of how pipelines can package, integrate, and apply code to environments. This section explains how to design a pipeline for progressive testing. When someone pushes a code change to the source control repository, the team uses a central system to progress the change through a series of stages to test and deliver the change. This process is automated, although people may be involved to trigger or approve activities. A pipeline automates processes involved in packaging, promoting, and applying code and tests. Humans may review changes, and even conduct exploratory testing on environments. But they should not run commands by hand to deploy and apply changes. They also shouldn’t select configuration options or make other decisions on the fly. These actions should be defined as code and executed by the system.
Automating the process ensures it is carried out consistently every time, for every stage. Doing this improves the reliability of your tests, and creates consistency between instances of the infrastructure. Every change should be pushed from the start of the pipeline. If you find an error in a “downstream” (later) stage in a pipeline, don’t fix it in that stage and continue through the rest of the pipeline. Instead, fix the code in the repository and push the new change from the start of the pipeline, as shown in Figure 8-5. This practice ensures that every change is fully tested. Figure 8-5. Start a new pipeline run to correct a failure In the figure, one change successfully passes through the pipeline. The second change fails in the middle of the pipeline. A fix is made and pushed through to production in the third run of the pipeline. Pipeline Stages Each stage of the pipeline may do different things and may trigger in different ways. Some of the characteristics of a given pipeline stage include: Trigger An event that causes the stage to start running. It may automatically run when a change is pushed to the code repository, or on the successful execution of the stage before it in the pipeline. Or someone may trigger the stage manually, as when a tester or release manager decides to apply a code change to a given environment.
Activity What happens when the stage runs. Multiple actions could execute for a stage. For example, a stage might apply code to provision an infrastructure stack, run tests, and then destroy the stack. Approval How the stage is marked as passing or failing. The system could automatically mark the stage as passing (often referred to as “green”) when commands run without errors, and automated tests all pass. Or a human may need to mark the stage as approved. For example, a tester may approve the stage after carrying out exploratory testing on the change. You can also use manual approval stages to support governance sign-offs. Output Artifacts or other material produced by the stage. Typical outputs include an infrastructure code package or a test report. Scope of Components Tested in a Stage In a progressive testing strategy, earlier stages validate individual components, while later stages integrate components and test them together. Figure 8-6 shows an example of progressively testing the components that lead to a web server running as part of a larger stack.
One stage might run tests for multiple components, such as a suite of unit tests. Or, different components may each have a separate test stage. Chapter 17 outlines different strategies for when to integrate different components, in the context of infrastructure stacks (see “Integrating Projects”). Scope of Dependencies Used for a Stage Many elements of a system depend on other services. An application server stack might connect to an identity management service to handle user authentication. To progressively test this, you might first run a stage that tests the application server without the identity management service, perhaps using a mock service to stand in for it. A later stage would run additional tests on the application server integrated with a test instance of the identity management service, and the production stage would integrate with the production instance (see Figure 8-7).
Figure 8-7. Progressive integration with dependencies Only Include Stages That Add Value Avoid creating unnecessary stages in your pipeline, as each stage adds time and cost to your delivery process. So, don’t create separate stages for each component and integration just for completeness. Split testing into stages this way only when it adds enough value to be worth the overhead. Some reasons that may drive you to do this include speed, reliability, cost, and control.
インフラストラクチャのデリバリーパイプライン CD パイプラインは、テストの進行とコードの環境へのデリバリーを組み合わせたもので、本番環境へのパスにおいてコードを提供します。第 19 章では、パイプラインがコードをパッケージ化、統合、適用する方法の詳細について説明します。このセクションでは、プログレッシブテストのためのパイプラインの設計方法について説明します。誰かがソース管理リポジトリにコードの変更をプッシュすると、チームは変更をテストしてデリバリーするために一連のステージを通過させるための中央システムを使用します。このプロセスは自動化されていますが、人々が活動をトリガーしたり承認したりすることもあります。パイプラインは、コードとテストのパッケージング、プロモーション、適用に関与するプロセスを自動化します。人間は変更をレビューし、環境での探索的テストを実施することもあります。ただし、デプロイや変更の適用については手動でコマンドを実行しないでください。また、設定オプションを選択したり、その場で他の決定を行ったりするべきではありません。これらのアクションはコードとして定義され、システムによって実行されるべきです。
プロセスを自動化することにより、それが一貫して実行され、すべてのステージにおいて毎回同じ結果が得られるようになります。これにより、テストの信頼性が向上し、インフラストラクチャのインスタンス間での一貫性が確保されます。すべての変更はパイプラインの始まりからプッシュされるべきです。パイプラインの後半にある「下流」のステージでエラーが見つかった場合は、そのステージで修正してパイプラインの残りを進めるのではなく、リポジトリでコードを修正し、パイプラインの始まりから新しい変更をプッシュする必要があります（図 8-5 参照）。この方法により、すべての変更が完全にテストされることが保証されます。図 8-5. 失敗を修正するために新しいパイプラインを開始する 図中では、1 つの変更がパイプラインを通過して正常に合格します。2 つ目の変更はパイプラインの中間で失敗します。修正が行われ、パイプラインの 3 回目の実行で本番にプッシュされます。 パイプラインのステージ パイプラインの各ステージは、異なることを行い、異なる形でトリガーされる場合があります。特定のパイプラインステージの特徴には、次のようなものがあります： トリガー ステージが実行を開始する原因となるイベントです。コードがリポジトリにプッシュされると自動的に実行される場合や、それ以前のステージが成功した場合に実行される場合があります。また、テスターやリリースマネージャーが特定の環境にコードの変更を適用することを決定した場合など、誰かがステージを手動でトリガーする場合もあります。
アクティビティ ステージが実行されたときに何が起こるかです。ステージでは複数のアクションが実行される場合があります。たとえば、ステージではインフラストラクチャスタックにコードを適用し、テストを実行し、その後スタックを破棄することがあります。 承認 ステージが合格または失敗としてマークされる方法です。システムは、エラーなしにコマンドが実行され、すべての自動化されたテストが合格した場合にステージを自動的に合格（「緑」）とマークすることができます。また、テスターが変更に対して探索的テストを実施した後、ステージを承認する必要がある場合があります。ガバナンスの承認をサポートするために、手動の承認ステージを使用することもできます。 ステージで生成された成果物またはその他の材料。典型的な出力には、インフラストラクチャコードパッケージやテストレポートなどがあります。 ステージでテストされるコンポーネントのスコープ プログレッシブテストの戦略では、初期のステージでは個々のコンポーネントを検証し、後のステージではコンポーネントを統合し、それらを一緒にテストします。図 8-6 は、ウェブサーバーが大規模なスタックの一部として実行されるためのコンポーネントのプログレッシブなテストの例を示しています。
1 つのステージでは、複数のコンポーネント（たとえば、スイートのユニットテスト）のテストが実行される場合があります。また、異なるコンポーネントごとに個別のテストステージを持つこともあります。第 17 章では、インフラストラクチャスタックのコンテキストで、さまざまなコンポーネントを統合するタイミングについて異なる戦略を概説しています（「プロジェクトの統合」を参照）。 ステージで使用される依存関係のスコープ システムの多くの要素は他のサービスに依存しています。例えば、アプリケーションサーバースタックはユーザー認証を処理するためにアイデンティティ管理サービスに接続するかもしれません。これをプログレッシブにテストするために、まずはアイデンティティ管理サービスを使用せずにアプリケーションサーバーをテストするステージを実行することができます。モックサービスを使用して代わりに立ち上げることができます。後のステージでは、テスト用のアイデンティティ管理サービスのインスタンスとアプリケーションサーバーを統合して追加のテストを実行し、本番ステージでは本番インスタンスと統合します（図 8-7 参照）。
図 8-7. 依存性を持つプログレッシブな統合 パイプラインに付加価値のあるステージのみを含める パイプラインに不要なステージを作成しないようにし、各ステージがデリバリープロセスに時間とコストを追加するためです。したがって、完全性のために各コンポーネントと統合ごとに個別のステージを作成しないでください。このようにテストをステージ分割するのは、そのオーバーヘッドが十分な価値を持つ場合にのみ行ってください。これには、速度、信頼性、コスト、制御などの理由があります。
ステージに必要なプラットフォーム要素 プラットフォームサービスは、システムの依存関係の特定のタイプです
