Progressive Testing Most nontrivial systems use multiple suites of tests to validate changes. Different suites may test different things (as listed in “What Should We Test with Infrastructure?”). One suite may test one concern offline, such as checking for security vulnerabilities by scanning code syntax. Another suite may run online checks for the same concern, for example by probing a running instance of an infrastructure stack for security vulnerabilities. Progressive testing involves running test suites in a sequence. The sequence builds up, starting with simpler tests that run more quickly over a smaller scope of code, then building up to more comprehensive tests over a broader set of integrated components and services. Models like the test pyramid and Swiss cheese testing help you think about how to structure validation activities across your test suites. The guiding principle for a progressive feedback strategy is to get fast, accurate feedback. As a rule, this means running faster tests with a narrower scope and fewer dependencies first and then running tests that progressively add more components and integration points (Figure 8-1). This way, small errors are quickly made visible so they can be quickly fixed and retested.
When a broadly scoped test fails, you have a large surface area of components and dependencies to investigate. So you should try to find any potential area at the earliest point, with the smallest scope that you can. Another goal of a test strategy is to keep the overall test suite manageable. Avoid duplicating tests at different levels. For example, you may test that your application server configuration code sets the correct directory permissions on the log folder. This test would run in an earlier stage that explicitly tests the server configuration. You should not have a test that checks file permissions in the stage that tests the full infrastructure stack provisioned in the cloud. Test Pyramid The test pyramid is a well-known model for software testing.11 The key idea of the test pyramid is that you should have more tests at the lower layers, which are the earlier stages in your progression, and fewer tests in the later stages (see Figure 8-2). The pyramid was devised for application software development. The lower level of the pyramid is composed of unit tests, each of which tests a small piece of code and runs very quickly.12 The middle layer is integration tests, each of which covers a collection of components assembled together. The higher stages are journey tests, driven through the user interface, which test the application as a whole.
The tests in higher levels of the pyramid cover the same scope already covered in lower levels. This means they can be less comprehensive — they only need to test functionality that emerges from the integration of components, rather than proving the behavior of lower-level components. The testing pyramid is less valuable with declarative infrastructure codebases. Most low-level declarative stack code (see “Low-Level Infrastructure Languages”) written for tools like Terraform and CloudFormation is too large for unit testing, and depends on the infrastructure platform. Declarative modules (see “Reuse Declarative Code with Modules”) are difficult to test in a useful way, both because of the lower value of testing declarative code (see “Challenge:
Tests for Declarative Code Often Have Low Value”) and because there is usually not much that can be usefully tested without the infrastructure. This means that, although you’ll almost certainly have low-level infrastructure tests, there may not be as many as the pyramid model suggests. So, an infrastructure test suite for declarative infrastructure may end up looking more like a diamond, as shown in Figure 8-3.
The pyramid may be more relevant with an infrastructure codebase that makes heavier use of dynamic libraries (see “Dynamically Create Stack Elements with Libraries”) written in imperative languages (see “Programmable, Imperative Infrastructure Languages”). These codebases have more small components that produce variable results, so there is more to test. Swiss Cheese Testing Model Another way to think about how to organize progressive tests is the Swiss cheese model. This concept for risk management comes from outside the software industry. The idea is that a given layer of testing may have holes, like one slice of Swiss cheese, that can miss a defect or risk. But when you combine multiple layers, it looks more like a block of Swiss cheese, where no hole goes all the way through. The point of using the Swiss cheese model when thinking about infrastructure testing is that you focus on where to catch any given risk (see Figure 8-4). You still want to catch issues in the earliest layer where it is feasible to do so, but the important thing is that it is tested somewhere in the overall model.
The key takeaway is to test based on risk rather than based on fitting a formula.
プログレッシブテストほとんどの複雑なシステムでは、変更を検証するために複数のテストスイートが使用されます。異なるスイートは異なる事柄をテストします（「インフラストラクチャをテストする際には何をテストすべきか」でリストされています）。1つのスイートは、セキュリティの脆弱性をコード構文のスキャンによってチェックするなど、オフラインで1つの関心事をテストする場合があります。別のスイートでは同じ関心事についてオンラインのチェックを実行する場合もあります。例えば、セキュリティの脆弱性を評価するために実行中のインフラストラクチャスタックのインスタンスをプローブする方法です。プログレッシブテストは、テストスイートを順次実行することを含みます。シーケンスは次第に構築され、より短いスコープのコード上でより速く実行される単純なテストから始まり、より包括的なテストになります。テストピラミッドやスイスチーズテストといったモデルを使用すると、テストスイート全体にわたって検証活動を構造化する方法を考えることができます。プログレッシブフィードバック戦略の指針は、迅速かつ正確なフィードバックを得ることです。一般的には、最初にスコープが狭く依存関係が少ないスピーディーなテストを実行し、次にプログレッシブにより多くのコンポーネントと統合ポイントを追加するテストを実行することが求められます（図 8-1）。これにより、小さなエラーがすぐに可視化され、素早く修正および再テストが行われます。
広範囲のテストが失敗すると、調査するべきコンポーネントと依存関係の面が広がります。そのため、最初の段階でできるだけ小さな範囲で潜在的な問題を見つける必要があります。テスト戦略の別の目標は、全体のテストスイートを管理可能な状態に保つことです。異なるレベルでテストを重複させないようにしてください。例えば、アプリケーションサーバーの設定コードがログフォルダの正しいディレクトリパーミッションを設定しているかをテストすることがあります。このテストは、サーバーの設定を明示的にテストする段階で実行されます。クラウドで提供される完全なインフラストラクチャスタックをテストする段階でファイルのパーミッションをチェックするようなテストは行わないでください。テストピラミッド テストピラミッドは、ソフトウェアテストについてよく知られたモデルです。テストピラミッドの主要なアイデアは、進行の早いステージである下位のレイヤーにより多くのテストを持ち、後のステージではより少ないテストを持つことです（図 8-2を参照）。ピラミッドはアプリケーションソフトウェア開発のために考案されました。ピラミッドの下層はユニットテストで構成されており、それぞれが小さなコードの一部をテストし、非常に速く実行されます。中間層は統合テストであり、複数のコンポーネントが組み合わされたものをカバーします。上位の段階はユーザインターフェースを介して走るジャーニーテストであり、アプリケーション全体をテストします。
ピラミッドのより上位のレベルのテストは、既に下位レベルでカバーされた範囲をカバーします。これは、これらのテストがより包括的でなくても問題ないことを意味します。これらのテストは、コンポーネントの統合から生じる機能のテストを実行する必要がありますが、下位レベルのコンポーネントの動作を証明する必要はありません。テストピラミッドは、宣言的なインフラストラクチャコードベースではあまり価値がありません。TerraformやCloudFormationなどのツールのために書かれた低レベルの宣言的スタックコード（「低レベルのインフラストラクチャ言語」を参照）は、ユニットテストには大きすぎて、インフラストラクチャプラットフォームに依存しています。宣言的モジュール（「モジュールで宣言的コードを再利用する」を参照）は有用な方法でテストすることが難しいです。それは宣言的なコードのテストの価値が低いため（「課題：宣言的コードのテストの価値が低い」を参照）、インフラストラクチャがない場合に有用にテストできるものはほとんどありません。これは、ほとんどの場合、低レベルのインフラストラクチャテストがあるということを意味していますが、ピラミッドモデルが示唆するほど多くはないかもしれません。したがって、宣言的インフラストラクチャのインフラテストスイートは、図 8-3に示されているように、よりダイヤモンド型の形になる場合があります。
インフラストラクチャテストにおいてスイスチーズモデルを使用すると、特定のリスクをキャッチする場所に焦点を当てることができます（図 8-4を参照）。早い段階で問題を発見するためには、最初のレイヤーで問題をキャッチすることが望ましいですが、重要なことは、どこかで全体モデルでテストされることです。
重要なポイントは、式に合わせてテストするのではなく、リスクに基づいてテストすることです。