What Should We Test with Infrastructure? The essence of CI is to test every change someone makes as soon as possible. The essence of CD is to maximize the scope of that testing. As Jez Humble says, “We achieve all this by ensuring our code is always in a deployable state.”6 Quality assurance is about managing the risks of applying code to your system. Will the code break when applied? Does it create the right infrastructure? Does the infrastructure work the way it should? Does it meet operational criteria for performance, reliability, and security? Does it comply with regulatory and governance rules? CD is about broadening the scope of risks that are immediately tested when pushing a change to the codebase, rather than waiting for eventual testing days, weeks, or even months afterwards. So on every push, a pipeline applies the code to realistic test environments and runs comprehensive tests. Ideally, once the code has run through the automated stages of the pipeline, it’s fully proven as production-ready.
Teams should identify the risks that come from making changes to their infrastructure code, and create a repeatable process for testing any given change against those risks. This process takes the form of automated test suites and manual tests. A test suite is a collection of automated tests that are run as a group. When people think about automated testing, they generally think about functional tests like unit tests and UI-driven journey tests. But the scope of risks is broader than functional defects, so the scope of validation is broader as well. Constraints and requirements beyond the purely functional are often called Non-Functional Requirements (NFRs) or Cross-Functional Requirements (CFRs).7 Examples of things that you may want to validate, whether automatically or manually, include: Code quality Is the code readable and maintainable? Does it follow the team’s standards for how to format and structure code? Depending on the tools and languages you’re using, some tools can scan code for syntax errors and compliance with formatting rules, and run a complexity analysis. Depending on how long they’ve been around, and how popular they are, infrastructure languages may not have many (or any!) of these tools. Manual review methods include gated code review processes, code showcase sessions, and pair programming. Functionality Does it do what it should? Ultimately, functionality is tested by deploying the applications onto the infrastructure and checking that they run correctly. Doing this indirectly tests that the infrastructure is correct, but you can often catch issues before deploying applications. An example of this for infrastructure is network routing. Can an HTTPS connection be made from the public internet to the web servers? You may be able to test this kind of thing using a subset of the entire infrastructure. Security You can test security at a variety of levels, from code scanning to unit testing to integration testing and production monitoring. There are some tools specific to security testing, such as vulnerability scanners. It may also be useful to write security tests into standard test suites. For example, unit tests can make assertions about open ports, user account handling, or access permissions. Compliance
Systems may need to comply with laws, regulations, industry standards, contractual obligations, or organizational policies. Ensuring and proving compliance can be time-consuming for infrastructure and operations teams. Automated testing can be enormously useful with this, both to catch violations quickly and to provide evidence for auditors. As with security, you can do this at multiple levels of validation, from code-level to production testing. See “Governance in a Pipeline-based Workflow” for a broader look at doing this. Performance Automated tools can test how quickly specific actions complete. Testing the speed of a network connection from point A to point B can surface issues with the network configuration or the cloud platform if run before you even deploy an application. Finding performance issues on a subset of your system is another example of how you can get faster feedback. Scalability Automated tests can prove that scaling works correctly; for example, checking that an auto-scaled cluster adds nodes when it should. Tests can also check whether scaling gives you the outcomes that you expect. For example, perhaps adding nodes to the cluster doesn’t improve capacity, due to a bottleneck somewhere else in the system. Having these tests run frequently means you’ll discover quickly if a change to your infrastructure breaks your scaling. Availability Similarly, automated testing can prove that your system would be available in the face of potential outages. Your tests can destroy resources, such as nodes of a cluster, and verify that the cluster automatically replaces them. You can also test that scenarios that aren’t automatically resolved are handled gracefully; for example, showing an error page and avoiding data corruption. Operability You can automatically test any other system requirements needed for operations. Teams can test monitoring (inject errors and prove that monitoring detects and reports them), logging, and automated maintenance activities. Each of these types of validations can be applied at more than one level of scope, from server configuration to stack code to the fully integrated system. I’ll discuss this in “Progressive Testing”. But first I’d like to address the things that make infrastructure especially difficult to test.
インフラストラクチャで何をテストすべきですか？CIの本質は、誰かが行った変更をできるだけ早くテストすることです。CDの本質は、そのテストの範囲を最大限に広げることです。Jez Humble氏の言葉を借りれば、「コードがデプロイ可能な状態であることを常に確保することによって、これらすべてを達成します。」。品質保証は、コードをシステムに適用することのリスクを管理することです。コードは適用されたときに壊れるでしょうか？適切なインフラストラクチャを作成しますか？インフラストラクチャは正しく機能していますか？パフォーマンス、信頼性、セキュリティのための操作基準を満たしていますか？規制およびガバナンスのルールを順守していますか？CDは、コードベースに変更をプッシュするときに即座にテストされるリスクの範囲を広げることです。そのために、パイプラインはコードをリアルなテスト環境に適用し、包括的なテストを実行します。理想的には、コードがパイプラインの自動化されたステージを実行した後、それが本番用に完全に検証された状態になります。
チームは、インフラストラクチャコードを変更することから生じるリスクを特定し、それらのリスクに対してどのような変更もテストするための繰り返し可能なプロセスを作成する必要があります。このプロセスは、自動化されたテストスイートとマニュアルテストの形式を取ります。テストスイートは、グループとして実行される自動化テストの集合です。人々が自動化テストについて考えるとき、通常はユニットテストやUIドリブンのジャーニーテストなどの機能テストを思い浮かべます。しかし、リスクの範囲は機能的な欠陥よりも広範であるため、検証の範囲も広範です。純粋に機能的なもの以外の制約や要件は、非機能要件（NFR）またはクロス機能要件（CFR）などと呼ばれることがあります。自動化テストやマニュアルテストによって自動的にまたは手動で検証したいと思うものの例としては、以下があります。コードの品質。コードは読みやすく、保守可能ですか？コードの形式や構造にチームの基準に従っていますか？使用しているツールと言語によっては、ツールがコードを構文エラーや書式ルールの遵守、複雑性分析に対してスキャンできる場合もあります。使用されている期間や人気の程度によっては、インフラストラクチャ言語にはこれらのツールが少ない（またはまったくない！）場合もあります。手動のレビュー手法には、ゲート付きのコードレビュープロセス、コードのショーケースセッション、ペアプログラミングなどがあります。機能。それは望むように動作しますか？最終的には、アプリケーションをインフラストラクチャにデプロイし、正常に実行されるかどうかを確認することによって機能がテストされます。これによって、インフラストラクチャが正しいことが間接的にテストされますが、アプリケーションをデプロイする前に問題を見つけることもできます。インフラストラクチャの例として、ネットワークのルーティングがあります。パブリックインターネットからWebサーバーへのHTTPS接続が確立できるかどうかをテストすることができます。このようなテストは、インフラストラクチャ全体のサブセットを使用して実行することができるかもしれません。セキュリティ。セキュリティをさまざまなレベルでテストすることができます。コードスキャン、ユニットテスト、統合テスト、および本番監視などのセキュリティテストに特化したツールもあります。標準のテストスイートにセキュリティテストを組み込むことも役立つかもしれません。たとえば、ユニットテストではオープンポート、ユーザーアカウントの処理、アクセス許可などについてアサーションを行うことができます。コンプライアンス
システムは法律、規制、業界標準、契約上の義務、組織のポリシーに準拠する必要がある場合があります。コンプライアンスを確保し、証明することは、インフラストラクチャおよび運用チームにとって時間がかかる場合があります。自動化テストは、違反を迅速に検出するだけでなく、監査人に証拠を提供するために非常に役立ちます。セキュリティと同様に、これをコードレベルから本番テストまでの複数の検証レベルで実行することができます。これについては、より広範な視点で行うために、「パイプラインベースのワークフローにおけるガバナンス」を参照してください。パフォーマンス。自動化ツールは、特定のアクションがどれくらい速く完了するかをテストすることができます。例えば、アプリケーションをデプロイする前にネットワーク接続の速度をテストすることで、ネットワークの構成やクラウドプラットフォームの問題を発見することができます。システムのサブセットでパフォーマンスの問題を見つけることもできます。拡張性。自動化テストは、拡張性が正しく機能していることを証明できます。例えば、自動スケールされるクラスタが必要な時にノードを追加するかどうかを確認することができます。また、スケーリングが期待どおりの結果をもたらしているかをテストすることもできます。例えば、クラスタにノードを追加しても容量が向上しない場合、システムの別の部分にボトルネックがあるためです。これらのテストを頻繁に実行することにより、インフラストラクチャがスケーリングを破壊するかどうかをすぐに発見することができます。可用性。同様に、自動化テストは、潜在的な障害が発生した場合でもシステムが利用可能であることを証明できます。テストでは、クラスタのノードなどのリソースを破壊し、クラスタが自動的にそれを置き換えるかを検証することができます。また、自動的に解決されないシナリオが正しく処理されるかどうかもテストすることができます。たとえば、エラーページを表示し、データの破損を避けることができます。操作性。運用に必要な他のシステム要件を自動的にテストすることができます。チームは、モニタリング（エラーを注入してモニタリングがそれらを検出して報告することを確認）やログ記録、自動メンテナンス活動のテストを行うことができます。これらの検証の各タイプは、サーバーの構成からスタックコード、完全に統合されたシステムまで、複数のスコープレベルで適用することができます。これについては、「プログレッシブテスト」で詳しく説明します。しかし、まずは、インフラストラクチャをテストするのが特に困難な要素について述べたいと思います。