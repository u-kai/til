Infrastructure for FaaS Serverless Chapter 3 lists FaaS serverless as one of the ways a platform can provide compute resources to applications (see “Compute Resources”). The normal model for application code is to run it continuously in a container or server. FaaS executes application code on demand, in response to an event or schedule. FaaS code is useful for well-defined, short-lived actions where the code starts quickly. Typical examples are handling HTTP requests or responding to error events in a message queue. The platform launches multiple instances of the code in parallel when needed, for example, to handle multiple events coming in simultaneously. FaaS can be very efficient for workloads where the demand varies greatly, scaling up when there are peaks, and not running at all when not needed. “Serverless” isn’t the most accurate term for this, because of course, the code does run on a server. It’s just that the server is effectively invisible to you as a developer. The same is true with containers, so what is distinctive about so-called serverless isn’t the level of abstraction from servers. The real distinction with serverless is that it is a short-lived process rather than a long-running process. For this reason, many people prefer the term FaaS rather than serverless. This also disambiguates FaaS from other uses of the term serverless, which can also mean Backend as a Service (BaaS), which is an externally hosted service.5 FaaS runtimes follow the same models as application clusters — FaaS runtime provided as a service by your infrastructure platform, and packaged FaaS, which requires you to provision and configure infrastructure and management tools. Examples of FaaS runtime provided as a service include: AWS Lambda Azure Functions Google Cloud Functions Examples of packaged FaaS runtime solutions include: Fission Kubeless OpenFaaS
Apache OpenWhisk You can use the same strategies described earlier in this chapter for provisioning infrastructure for a packaged FaaS solution, such as server pools and management services. Be sure you understand how your FaaS solution works in depth, so you are aware of whether and how code may “leak” data. For example, it may leave temporary files and other remnants in locations that may be available to other FaaS code, which can create issues for security and compliance. How well the FaaS solution meets your needs for segregating data, and whether it can scale, should drive your decisions on whether to run multiple instances of your FaaS runtime. The FaaS services provided by cloud vendors usually don’t leave as much for you to configure as application clusters do. For example, you normally won’t need to specify the size and nature of the host servers the code executes on. This drastically reduces the amount of infrastructure you need to define and manage. However, most FaaS code does interact with other services and resources. You may need to define networking for inbound requests that trigger a FaaS application, and for outbound requests the code makes. FaaS code often reads and writes data and messages to storage devices, databases, and message queues. These all require you to define and test infrastructure resources. And of course, FaaS code should be delivered and tested using a pipeline, as with any other code. So you still need all of the practices around defining and promoting infrastructure code and integrating it with application testing processes.
FaaS Serverlessのインフラストラクチャ チャプター3では、FaaSサーバーレスがプラットフォームがアプリケーションに計算リソースを提供する方法の一つとしてリストされています（「計算リソース」を参照）。通常、アプリケーションコードはコンテナまたはサーバーで連続的に実行されますが、FaaSはイベントやスケジュールに応じてアプリケーションコードをオンデマンドで実行します。FaaSコードは、コードが迅速に起動する短期間のアクションに適しています。典型的な例は、HTTPリクエストの処理やメッセージキューでのエラーイベントへの応答です。プラットフォームは、同時に発生する複数のイベントを処理するために必要に応じてコードの複数のインスタンスを並列に起動します。FaaSは需要が大きく変動するワークロードに非常に効率的です。需要がピークになるとスケールアップし、必要ない場合は全く実行されません。これを「サーバーレス」と呼ぶのは最も正確な用語ではありません。当然、コードはサーバーで実行されますが、開発者としてはサーバーは事実上目に見えないものです。コンテナでも同様のことが当てはまりますので、「サーバーレス」という呼び方の特徴はサーバーからの抽象化のレベルではありません。サーバーレスの本質的な違いは、長時間実行されるプロセスではなく短期間実行されるプロセスであることです。そのため、多くの人々は「サーバーレス」よりも「FaaS」という用語を好みます。これにより、「サーバーレス」という用語が他のサーバーレスの用途（たとえば、Backend as a Service（BaaS）など）と区別されます。FaaSランタイムは、アプリケーションクラスタと同じモデルに従います。FaaSランタイムは、インフラストラクチャプラットフォームが提供するサービスとして提供され、パッケージ化されたFaaSは、インフラストラクチャと管理ツールのプロビジョニングと構成が必要です。サービスとして提供されるFaaSランタイムの例には、AWS Lambda、Azure Functions、Google Cloud Functionsがあります。パッケージ化されたFaaSランタイムソリューションの例には、Fission、Kubeless、OpenFaaS、Apache OpenWhiskがあります。パッケージ化されたFaaSソリューションのインフラストラクチャをプロビジョニングするために、サーバープールと管理サービスなどの前章で説明した戦略を使用することができます。ただし、コードがデータを「漏らす」可能性があるかどうかを正確に理解しておく必要があります。たとえば、一時ファイルや他の痕跡を他のFaaSコードが利用できる場所に残す可能性があり、セキュリティやコンプライアンスの問題を引き起こす可能性があります。FaaSソリューションがどれくらいデータをセグリゲートし、スケーラビリティを持っているかは、FaaSランタイムの複数のインスタンスを実行するかどうかの決定に影響を与えるべきです。クラウドベンダーが提供するFaaSサービスは、通常、アプリケーションクラスタよりも多くの設定が必要ありません。たとえば、コードが実行されるホストサーバーのサイズや性質を指定する必要はありません。これにより、定義と管理する必要のあるインフラストラクチャの量が大幅に削減されます。ただし、ほとんどのFaaSコードは他のサービスやリソースと連携します。トリガーとなる着信リクエストのネットワーキングや、コードが行うアウトバウンドリクエストを定義する必要があるかもしれません。FaaSコードはしばしばストレージデバイス、データベース、メッセージキューにデータやメッセージを読み書きします。これらはすべて、インフラストラクチャリソースを定義し、テストする必要があります。そしてもちろん、FaaSコードは他のコードと同様にパイプラインを使用して配信とテストを行う必要があります。したがって、インフラストラクチャコードの定義と展開、アプリケーションテストプロセスへの統合に関連するすべてのプラクティスが必要です。