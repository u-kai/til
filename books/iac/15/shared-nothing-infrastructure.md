Shared-Nothing Infrastructure In the distributed computing field, a shared-nothing architecture enables scaling by ensuring that new nodes can be added to a system without adding contention for any resources outside the node itself. The typical counter-example is a system architecture where processors share a single disk. Contention for the shared disk limits the scalability of the system when adding more processors. Removing the shared disk from the design means the system can scale closer to linearly by adding processors. A shared-nothing design with infrastructure code moves resources from a shared stack to each stack that requires them, removing the provider-consumer relationship. For example, the ShopSpinner team could combine the application-infrastructure-stack and shared-network-stack into a single stack. Each instance of the application infrastructure has its own full set of networking structures. Doing this duplicates networking structures, but keeps each application instance independent of the others. As with distributed system architecture, this removes limitations on scaling. For example, the ShopSpinner team can add as many instances of the application infrastructure as they need without using up the address space allocated with a single shared networking stack. But a more common driver for using a shared-nothing infrastructure code design is to make it easier to modify, rebuild, and recover the networking resources for an application stack. The shared networking stack design increases the blast radius and management overhead of working with the networking. Shared-nothing infrastructure also supports the zero-trust security model (see “Zero-Trust Security Model with SDN”), since each stack can be secured separately. A shared-nothing design doesn’t require putting everything into a single stack instance. For the ShopSpinner team, an alternative to combining the networking and application infrastructure in a single stack is to define the networking and application infrastructure in different stacks, as before, but create a separate instance of the networking stack for each instance of the application stack (see Figure 15-5). With this approach, application stack instances don’t share networking with other stacks, but the two parts can be independently managed. The limitation of doing this is that all network stack instances are still defined by the same code, so any change to the code needs extra work to ensure it doesn’t break any of the instances.
共有なしのインフラストラクチャ
分散コンピューティングの分野では、共有なしのアーキテクチャは、新しいノードをシステムに追加する際に、ノード自体の外部リソースに対する競合を追加せずにスケーリングを可能にします。典型的な反例は、プロセッサが単一のディスクを共有するシステムアーキテクチャです。共有ディスクへのアクセス競合は、より多くのプロセッサを追加するときにシステムのスケーラビリティを制限します。共有ディスクを設計から取り除くことで、プロセッサを追加することによってシステムを近似的に線形スケーリングできます。共有なしの設計では、インフラストラクチャコードは共有スタックからそれらが必要な各スタックにリソースを移動し、プロバイダーとコンシューマーの関係を解消します。たとえば、ShopSpinnerチームは、アプリケーションインフラストラクチャスタックと共有ネットワークスタックを1つのスタックに統合することができます。アプリケーションインフラストラクチャの各インスタンスには独自のネットワーキング構造の完全なセットがあります。これにより、ネットワーキング構造が複製されますが、各アプリケーションインスタンスが他のインスタンスと独立している状態を保ちます。分散システムアーキテクチャと同様に、これによりスケーリングの制限がなくなります。たとえば、ShopSpinnerチームは、1つの共有ネットワーキングスタックで割り当てられたアドレススペースを使い尽くすことなく、必要なだけのアプリケーションインフラストラクチャインスタンスを追加できます。しかし、共有なしのインフラストラクチャコード設計を使用する一般的な要因は、アプリケーションスタックのネットワーキングリソースを修正、再構築、回復しやすくするためです。共有ネットワーキングスタックの設計は、ネットワーキングとの作業における影響範囲と管理オーバーヘッドを増加させます。共有なしのインフラストラクチャは、ゼロトラストセキュリティモデル（「SDNにおけるゼロトラストセキュリティモデル」を参照）をサポートします。各スタックは個別にセキュリティを確保することができます。共有なしの設計では、すべてを1つのスタックインスタンスに入れる必要はありません。ShopSpinnerチームにとって、ネットワーキングとアプリケーションインフラストラクチャを1つのスタックに組み合わせる代わりに、以前と同様にネットワーキングとアプリケーションインフラストラクチャを別々のスタックに定義し、アプリケーションスタックの各インスタンスごとに独自のネットワーキングスタックのインスタンスを作成することもできます（図15-5を参照）。このアプローチでは、アプリケーションスタックインスタンスは他のスタックとネットワーキングを共有しませんが、2つのパーツは独立して管理できます。この方法の制限は、すべてのネットワークスタックインスタンスが同じコードで定義されるため、コードの変更によってインスタンスのいずれかが壊れないようにするために追加の作業が必要となることです。