Modularizing Infrastructure An infrastructure system involves different types of components, as described in Chapter 3, each of which can be composed of different parts. A server instance may be built from an image, using a server configuration role that references a set of server configuration modules, which in turn may import code libraries. An infrastructure stack may be composed of server instances, and may use stack code modules or libraries. And multiple stacks may combine to comprise a larger environment or estate. Stack Components Versus Stacks as Components The infrastructure stack, as defined in Chapter 5, is the core deployable unit of infrastructure. The stack is an example of an Architectural Quantum, which Ford, Parsons, and Kua define as, “an independently deployable component with high functional cohesion, which includes all the structural elements required for the system to function correctly.”4 In other words, a stack is a component that you can push into production on its own. As mentioned previously, a stack can be composed of components, and a stack may itself be a component. Servers are one potential component of a stack, which are involved enough to drill into later in this chapter. Most stack management tools also support putting stack code into modules, or using libraries to generate elements of the stack. Figure 15-1 shows two stacks, the imaginatively named StackA and StackB, which use a shared code module that defines a networking structure.
Chapter 16 describes some patterns and antipatterns for using stack code modules and libraries.
Stack modules and libraries are useful for reusing code. However, they are less helpful for making stacks easy to change. I’ve seen teams try to improve a monolithic stack (see “Antipattern: Monolithic Stack”) by breaking the code into modules. While modules made the code easier to follow, each stack instance was just as large and complex as before. Figure 15-2 shows that code separated into separate modules are combined into the stack instance.
In addition to adding to the elements with each stack instance, a module that is also used by other stacks creates coupling between those stacks. Changing the module to accommodate a requirement in one stack may affect other stacks that use the module. This coupling may add friction for making changes. A more fruitful approach to making a large stack more manageable is to break it into multiple stacks, each of which can be provisioned, managed, and changed independently of others. “Patterns and Antipatterns for Structuring Stacks” lists a few patterns for considering the size and contents of a stack. Chapter 17 goes into more detail of managing the dependencies between stacks. Using a Server in a Stack Servers are a common type of stack component. Chapter 11 explained the various components of a server and its life cycle. Stack code normally incorporates servers through some combination of server images (see Chapter 13) and server configuration modules (see “Server Configuration Code”), often by specifying a role (see “Server Roles”). The ShopSpinner team’s codebase includes an example of using a server image as a component of a stack. It has a stack called cluster_of_host_nodes, which builds a cluster of servers to act as container host nodes, as shown in Figure 15-3.
The code that defines the server cluster specifies the name of the server image, host_node_image: server_cluster:
name: "cluster_of_host_nodes"
min_size: 1
max_size: 3
each_server_node:
source_image: host_node_image
memory: 8GB
The team uses a pipeline to build and test changes to the server image. Another pipeline tests changes to cluster_of_host_nodes, integrating it with the latest version of host_node_image that has passed its tests (see Figure 15-4). Figure 15-4. Pipeline to integrate the server image and its consumer stack “Infrastructure Delivery Pipelines” explained how pipelines can work for infrastructure. This example has a slight issue, however. The first pipeline stage for the cluster_of_host_nodes stack doesn’t use the host_node_image. But the stack code example includes the name of the server image, so

it can’t be run as an online test stage (“Online Testing Stages for Stacks”). Testing the stack code without the image might be useful, so the team can find problems with the stack code without having to also provision the full host node servers, which are heavy. The ShopSpinner team addresses the problem by extracting the hardcoded host_node_image out of the stack code, using a stack parameter instead (Chapter 7). This code is more testable: server_cluster:
name: "cluster_of_host_nodes"
min_size: 1
max_size: 3
each_server_node:
source_image: ${HOST_NODE_SERVER_IMAGE}
memory: 8GB The online test stage for the cluster_of_host_nodes stack can set the HOST_NODE_SERVER_IMAGE parameter with the ID for a stripped-down server image. The team can run tests in this stage to validate that the server cluster works correctly, scaling up and down and recovering failed instances. The stripped-down server image is an example of a test double (see “Using Test Fixtures to Handle Dependencies”). The simple change of replacing the hardcoded reference to the server image with a parameter reduces coupling. It also follows the rule of composition (see “Rule of composition”). The team can easily create instances of cluster_of_host_nodes using a different server image, which would come in handy if people on the team want to test and incrementally roll out a different operating system for their clusters.
it can’t be run as an online test stage (“Online Testing Stages for Stacks”). Testing the stack code without the image might be useful, so the team can find problems with the stack code without having to also provision the full host node servers, which are heavy. The ShopSpinner team addresses the problem by extracting the hardcoded host_node_image out of the stack code, using a stack parameter instead (Chapter 7). This code is more testable: server_cluster:
name: "cluster_of_host_nodes"
min_size: 1
max_size: 3
each_server_node:
source_image: ${HOST_NODE_SERVER_IMAGE}
memory: 8GB The online test stage for the cluster_of_host_nodes stack can set the HOST_NODE_SERVER_IMAGE parameter with the ID for a stripped-down server image. The team can run tests in this stage to validate that the server cluster works correctly, scaling up and down and recovering failed instances. The stripped-down server image is an example of a test double (see “Using Test Fixtures to Handle Dependencies”). The simple change of replacing the hardcoded reference to the server image with a parameter reduces coupling. It also follows the rule of composition (see “Rule of composition”). The team can easily create instances of cluster_of_host_nodes using a different server image, which would come in handy if people on the team want to test and incrementally roll out a different operating system for their clusters.
it can’t be run as an online test stage (“Online Testing Stages for Stacks”). Testing the stack code without the image might be useful, so the team can find problems with the stack code without having to also provision the full host node servers, which are heavy. The ShopSpinner team addresses the problem by extracting the hardcoded host_node_image out of the stack code, using a stack parameter instead (Chapter 7). This code is more testable: server_cluster:
name: "cluster_of_host_nodes"
min_size: 1
max_size: 3
each_server_node:
source_image: ${HOST_NODE_SERVER_IMAGE}
memory: 8GB The online test stage for the cluster_of_host_nodes stack can set the HOST_NODE_SERVER_IMAGE parameter with the ID for a stripped-down server image. The team can run tests in this stage to validate that the server cluster works correctly, scaling up and down and recovering failed instances. The stripped-down server image is an example of a test double (see “Using Test Fixtures to Handle Dependencies”). The simple change of replacing the hardcoded reference to the server image with a parameter reduces coupling. It also follows the rule of composition (see “Rule of composition”). The team can easily create instances of cluster_of_host_nodes using a different server image, which would come in handy if people on the team want to test and incrementally roll out a different operating system for their clusters.
インフラストラクチャシステムは、第 3 章で説明されているように、さまざまなタイプのコンポーネントから構成されています。各コンポーネントはさまざまな部分で構成される可能性があります。サーバーインスタンスは、サーバーコンフィギュレーションモジュールを参照するサーバーコンフィギュレーションロールを使用して、イメージから構築されることがあります。サーバーコンフィギュレーションモジュールは、コードライブラリをインポートする場合があります。インフラストラクチャスタックは、サーバーインスタンスから構成されることがあり、スタックコードモジュールやライブラリを使用することがあります。複数のスタックは、より大きな環境や不動産を構成するために組み合わされる場合があります。スタックコンポーネントとしてのスタック スタックは、第 5 章で定義されているように、インフラストラクチャの核となるデプロイ可能なユニットです。スタックは、Ford、Parsons、および Kua が「独立してデプロイ可能な高い機能的連続性を持つコンポーネントであり、システムが正常に機能するために必要なすべての構造要素を含む」と定義しているアーキテクチャの量子の一例です。言い換えると、スタックは単独で本番環境にプッシュできるコンポーネントです。前述のように、スタックはコンポーネントで構成されることがあり、スタックそのものもコンポーネントである場合があります。サーバーはスタックの潜入に十分なコンポーネントの 1 つであり、この章では詳しく説明します。ほとんどのスタック管理ツールは、スタックの要素をモジュールに格納するか、ライブラリを使用してスタックの要素を生成することもサポートしています。図 15-1 は、2 つのスタック、想像力豊かな名前の StackA と StackB を示しています。これらのスタックは、ネットワーキング構造を定義する共有コードモジュールを使用しています。第 16 章では、スタックコードモジュールとライブラリの使用に関するいくつかのパターンとアンチパターンについて説明しています。スタックモジュールとライブラリはコードを再利用するために便利ですが、スタックの変更を容易にするためにはあまり役に立ちません。私はチームがコードをモジュールに分割してモノリシックなスタックを改善しようと試みるのを見てきました（「アンチパターン：モノリシックスタック」を参照）。モジュールにより、コードが追いやすくなりましたが、各スタックインスタンスは以前と同じくらい大きく複雑でした。図 15-2 は、別々のモジュールに分割されたコードがスタックインスタンスに組み合わされている様子を示しています。スタックインスタンスごとの要素の追加に加えて、他のスタックでも使用されるモジュールは、それらのスタック間の結合を作成します。特定のスタックでの要件に対応するためにモジュールを変更すると、モジュールを使用する他のスタックにも影響が出る可能性があります。この結合は変更を行うための摩擦を増加させる可能性があります。大きなスタックをより管理しやすくするためのより有効な方法は、複数のスタックに分割することであり、それぞれが他のスタックとは独立してプロビジョニング、管理、変更できるようにすることです。 「スタックの構造化に関するパターンとアンチパターン」では、スタックのサイズと内容を考慮するいくつかのパターンがリストされています。第 17 章では、スタック間の依存関係の管理の詳細について説明しています。 スタックでサーバーを使用する サーバーはよく使われるスタックのコンポーネントです。第 11 章では、サーバーとそのライフサイクルのさまざまなコンポーネントについて説明しました。スタックコードは通常、サーバーイメージ（第 13 章を参照）とサーバーコンフィギュレーションモジュール（「サーバーコンフィギュレーションコード」を参照）のいくつかの組み合わせを介してサーバーを組み込みます。ShopSpinner チームのコードベースには、サーバーイメージをスタックのコンポーネントとして使用する例が含まれています。それは cluster_of_host_nodes というスタックで、コンテナホストノードとして動作するサーバーのクラスタを構築します（図 15-3 を参照）。 サーバークラスタを定義するコードでは、サーバーイメージの名前、host_node_image を指定しています。 server_cluster:
name: "cluster_of_host_nodes"
min_size: 1
max_size: 3
each_server_node:
source_image: host_node_image
memory: 8GB チームはパイプラインを使用してサーバーイメージの変更をビルドおよびテストしています。別のパイプラインでは、cluster_of_host_nodes の変更をテストし、テストに合格した最新バージョンの host_node_image と統合します（図 15-4 を参照）。 図 15-4. サーバーイメージとそのコンシューマースタックを統合するためのパイプライン 「インフラストラクチャのデリバリーパイプライン」は、パイプラインがインフラストラクチャにどのように機能するかを説明しています。しかし、この例にはわずかな問題があります。cluster_of_host_nodes スタックの最初のパイプラインステージでは、host_node_image は使用されません。ただし、スタックコードの例にはサーバーイメージの名前が含まれているため、オンラインテストステージ（「スタックのオンラインテストステージ」）として実行することはできません。サーバーイメージなしでスタックコードをテストすることは役に立つかもしれません。チームはスタックコードの問題を見つけるために、フルホストノードサーバーをプロビジョニングすることなくスタックコードをテストできます。 ShopSpinner チームは、スタックコード内のハードコードされた host_node_image をスタックパラメーターを使用して取り出すことで、この問題に対処しています（第 7 章を参照）。このコードはよりテスト可能です。 server_cluster:
name: "cluster_of_host_nodes"
min_size: 1
max_size: 3
each_server_node:
source_image: ${HOST_NODE_SERVER_IMAGE}
memory: 8GB cluster_of_host_nodes スタックのオンラインテストステージは、HOST_NODE_SERVER_IMAGE パラメーターを切り抜かれたサーバーイメージの ID で設定できます。チームはこのステージでテストを実行し、サーバークラスタが正しく動作し、正しいインスタンスのスケールアップ、ダウン、および復旧が行われることを検証できます。切り抜かれたサーバーイメージはテストダブルの一例です（「依存関係
サーバーイメージへのハードコードされた参照をパラメーターで置き換えるという単純な変更は、結合度を低減します。また、それは構成のルールに従っています（「構成のルール」を参照）。チームは簡単に cluster_of_host_nodes のインスタンスを作成することができ、クラスターの異なるオペレーティングシステムをテストし、段階的に展開する場合に便利です。
