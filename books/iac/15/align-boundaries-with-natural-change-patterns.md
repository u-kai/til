Align Boundaries with Natural Change Patterns The most basic approach to optimizing component boundaries for change is to understand their natural patterns of change. This is the idea behind finding seams — a seam is a natural boundary. With an existing system, you may learn about which things typically change together by examining historical changes. Finer-grained changes, like code commits, give the most useful insight. The most effective teams optimize for frequent commits, fully integrating and testing each one. By understanding what components tend to change together as part of a single commit, or closely related commits across components, you can find patterns that suggest how to refactor your code for more cohesion and less coupling. Examining higher levels of work, such as tickets, stories, or projects, can help you to understand what parts of the system are often involved in a set of changes. But you should optimize for small, frequent changes. So be sure to drill down to understand what changes can be made independently of one another, to enable incremental changes within the context of larger change initiatives.
Align Boundaries with Component Life Cycles Different parts of an infrastructure may have different life cycles. For example, servers in a cluster (see “Compute Resources”) are created and destroyed dynamically, perhaps many times a day. A database storage volume changes less frequently. Organizing infrastructure resources into deployable components, particularly infrastructure stacks, according to their life cycle can simplify management. Consider a ShopSpinner application server infrastructure stack composed of networking routes, a server cluster, and a database instance. The servers in this stack are updated at least every week, rebuilt using new server images with the latest operating system patches (as discussed in Chapter 13). The database storage device is rarely changed, although new instances may be built to recover or replicate instances of the application. The team occasionally changes networking in other stacks, which requires updating the application-specific routing in this stack. Defining these elements in a single stack can create some risk. An update to the application server image may fail. Fixing the issue might require rebuilding the entire stack, including the database storage device, which in turn requires backing up the data to restore to the new instance (see “Data Continuity in a Changing System”). Although it’s possible to manage this within a single stack, it would be simpler if the database storage was defined in a separate stack, as shown in Figure 15-6.
Changes are made to any of these micro stacks (see “Pattern: Micro Stack”) without directly affecting the others. This approach can enable stack-specific management events. For instance, any change to the database storage stack might trigger a data backup, which would probably be too expensive to trigger with every change to the other elements of the first, combined stack. Optimizing stack boundaries for life cycles is particularly useful for automated testing in pipelines. Pipeline stages often run multiple times every day while people are working on infrastructure changes, so they need to be optimized to give fast feedback and keep a good working rhythm. Organizing infrastructure elements into separate stacks based on their life cycle can reduce the time taken to apply changes for testing. For example, when working on the infrastructure code for the application servers, some pipeline stages might rebuild the stack each time (see “Pattern: Ephemeral Test Stack”). Rebuilding networking structures or large data storage devices can be slow, and may not be needed for many of the changes involved in the work. In this case, the micro-stack design shown earlier (Figure 15-6) can streamline the testing and delivery process. A third use case for separating stacks by life cycle is cost management. Shutting down or destroying and rebuilding infrastructure that isn’t needed in quiet periods is a common way to manage public cloud costs. But some elements, such as data storage, may be more challenging to rebuild. You can split these into their own stacks and leave them running while other stacks are destroyed to reduce costs.
自然な変化パターンに基づいて境界を整える 変化に対してコンポーネントの境界を最適化する最も基本的なアプローチは、自然な変化パターンを理解することです。これは、シーム（継ぎ目）を見つけるという考え方です - シームは自然な境界です。既存のシステムでは、過去の変更を調査することで、通常どの要素が一緒に変更されるかを学ぶことができます。コードのコミットなどの細かい変更が最も有益な洞察を与えます。効果的なチームは、頻繁なコミットに最適化し、それぞれを完全に統合し、テストします。単一のコミットとして一緒に変更する傾向があるコンポーネントを理解することにより、コードの再構成方法を示唆するパターンを見つけることができます。チケットやストーリー、プロジェクトといった高いレベルの作業を調査することで、どのシステムの部分が変更セットに関与しているかを理解することができます。ただし、小さな頻繁な変更に最適化する必要があります。したがって、大きな変更のコンテキスト内での段階的な変更を可能にするために、それぞれ独立して行える変更を理解するために詳しく調査する必要があります。

コンポーネントのライフサイクルに合わせて境界を整える インフラストラクチャの異なる部分には異なるライフサイクルがある場合があります。たとえば、クラスター内のサーバー（「コンピューティングリソース」を参照）は動的に作成および破棄され、1日に何度も変更される場合があります。データベースのストレージボリュームはより頻繁に変更されません。インフラストラクチャのリソースをデプロイ可能なコンポーネント、特にインフラストラクチャスタックとして整理することで、管理を簡素化することができます。ShopSpinnerアプリケーションサーバーインフラストラクチャスタックは、ネットワーキングルート、サーバクラスタ、およびデータベースインスタンスで構成されています。このスタック内のサーバーは少なくとも毎週更新され、最新のオペレーティングシステムパッチが適用された新しいサーバイメージを使用して再構築されます（第13章で説明した内容です）。データベースストレージデバイスはあまり変更されませんが、アプリケーションのインスタンスを復元または複製するために新しいインスタンスを構築する場合があります。チームは他のスタックでネットワーキングを変更する場合があり、これによりこのスタックのアプリケーション固有のルーティングを更新する必要があります。これらの要素を単一のスタックで定義すると、いくつかのリスクが生じる可能性があります。アプリケーションサーバーイメージのアップデートが失敗する可能性があります。問題を修正するためには、データベースストレージデバイスを含むスタック全体を再構築する必要があります。そのためには、データをバックアップして新しいインスタンスに復元する必要があります（「変化するシステムにおけるデータの連続性」を参照）。単一のスタック内でこれを管理することは可能ですが、データベースストレージを別々のスタックに定義する方がシンプルです（図15-6参照）。

これらのマイクロスタック（「パターン：マイクロスタック」を参照）のいずれかに変更が加えられても、他のスタックには直接影響を与えません。このアプローチは、スタック固有の管理イベントを可能にすることができます。たとえば、データベースストレージスタックへの変更は、データバックアップをトリガーする可能性がありますが、これは最初の組み合わせスタックの他の要素の変更ごとにトリガーするには高すぎるコストがかかるでしょう。ライフサイクルに基づいてスタックの境界を最適化することは、パイプライン内の自動テストにとって特に役立ちます。パイプラインのステージは、インフラストラクチャの変更に取り組んでいる間に毎日複数回実行されることが多いため、迅速なフィードバックを提供し、良好な作業リズムを維持するために最適化する必要があります。インフラストラクチャ要素をライフサイクルに基づいて別々のスタックに整理することで、テスト用の変更を適用するのにかかる時間を短縮することができます。たとえば、アプリケーションサーバーのインフラストラクチャコードで作業している場合、一部のパイプラインステージでは毎回スタックを再構築するかもしれません（「パターン：エフェメラルテストスタック」を参照）。ネットワーキング構造や大容量データストレージの再構築は遅い場合があり、作業に関連する多くの変更には必要ないかもしれません。この場合、先に示したマイクロスタックの設計（図15-6）はテストおよびデリバリープロセスを合理化することができます。ライフサイクルによるスタックの分離の第三のユースケースは、コスト管理です。静かな時期に必要でないインフラストラクチャをシャットダウンしたり、破棄して再構築したりすることは、パブリッククラウドのコストを管理する一般的な方法です。ただし、データストレージなどの一部の要素は再構築が難しい場合があります。これらを独自のスタックに分割し、他のスタックを破棄しながら稼働し続けることで、コストを削減することができます。