Building an Abstraction Layer An abstraction layer provides a simplified interface to lower-level resources. A set of reusable, composable
stack components can act as an abstraction layer for infrastructure resources. Components can implement the knowledge of how to assemble low-level resources exposed by the infrastructure platform into entities that are useful for people focused on higher-level tasks. For example, an application team may need to define an environment that includes an application server, database instance, and access to message queues. The team can use components that abstract the details of assembling rules for routing and infrastructure resource permissions. Components can be useful even for a team that has the skills and experience to implement the low-level resources. An abstraction helps to separate different concerns, so that people can focus on the problem at a particular level of detail. They should also be able to drill down to understand and potentially improve or extend the underlying components as needed. You might be able to implement an abstraction layer for some systems using more static components like facade modules (see “Pattern: Facade Module”) or bundle modules (see “Pattern: Bundle Module”). But more often you need the components of the layer to be more flexible, so dynamic components like infrastructure domain entities (see “Pattern: Infrastructure Domain Entity”) are more useful. An abstraction layer might emerge organically as people build libraries and other components. But it’s useful to have a higher-level design and standards so that the components of the layer work well together and fit into a cohesive view of the system. The components of an abstraction layer are normally built using a low-level infrastructure language (“Low-Level Infrastructure Languages”). Many teams find it useful to build a higher-level language (“High-Level Infrastructure Languages”) for defining stacks with their abstraction layer. The result is often a higher-level, declarative language that specifies the requirements for part of the application runtime environment, which calls to dynamic components written in a low-level, imperative language.
Application Abstraction Models The Open Application Model is an example of an attempt to define a standard architecture that decouples application, runtime, and infrastructure. Conclusion Building stacks from components can be useful when you have multiple people and teams working on and using infrastructure. But be wary of the complexity that comes with abstraction layers and libraries of components, and be sure to tailor your use of these constructs to match the size and complexity of your system.
抽象化レイヤーの構築
抽象化レイヤーは、より低レベルのリソースに対する簡略化されたインターフェースを提供します。再利用可能な組み合わせ可能なスタックコンポーネントは、インフラストラクチャリソースの抽象化レイヤーとして機能することができます。コンポーネントは、インフラストラクチャプラットフォームが公開する低レベルのリソースを、より上位のタスクに焦点を当てた人々に有用なエンティティに組み立てる方法の知識を実装することができます。例えば、アプリケーションチームは、アプリケーションサーバー、データベースインスタンス、及びメッセージキューへのアクセスを含む環境を定義する必要があるかもしれません。チームは、ルーティングやインフラストラクチャリソースのパーミッションの組み立てに関する詳細を抽象化したコンポーネントを使用することができます。コンポーネントは、低レベルのリソースを実装するスキルと経験を持つチームにとっても有用です。抽象化は異なる関心事を分離するのに役立ち、人々が特定の詳細レベルの問題に集中することができます。また、必要に応じて基礎となるコンポーネントを理解し、改善や拡張を行うことも可能であるべきです。一部のシステムでは、ファサードモジュール（「パターン：ファサードモジュール」を参照）やバンドルモジュール（「パターン：バンドルモジュール」を参照）のようなより静的なコンポーネントを使用して、抽象化レイヤーを実装することができるかもしれません。しかし、より柔軟性のあるコンポーネントが必要な場合が多いため、インフラストラクチャドメインエンティティ（「パターン：インフラストラクチャドメインエンティティ」を参照）のような動的なコンポーネントがより有用です。抽象化レイヤーは、人々がライブラリや他のコンポーネントを構築するにつれて、自然に生み出される場合もあります。しかし、レイヤーのコンポーネントがうまく機能し、システムの総合的なビューに適合するようにするために、より上位レベルの設計と規格があると便利です。抽象化レイヤーのコンポーネントは通常、低レベルのインフラストラクチャ言語（「低レベルのインフラストラクチャ言語」）を使用して構築されます。多くのチームは、抽象化レイヤーと共にスタックを定義するためのより高レベルな言語（「高レベルのインフラストラクチャ言語」）を構築することが有用です。その結果、アプリケーションの実行環境の一部の要件を指定する高レベルな宣言的言語が生成されますが、これには低レベルの命令形式言語で記述された動的コンポーネントの呼び出しが含まれます。
アプリケーションの抽象化モデル
Open Application Modelは、アプリケーション、ランタイム、およびインフラストラクチャを分離するための標準アーキテクチャの試みの例です。
結論
複数の人やチームがインフラストラクチャを作業したり使用したりする場合、コンポーネントからスタックを構築することは有用です。ただし、抽象化レイヤーやコンポーネントのライブラリと共に生じる複雑さには注意が必要であり、これらの構造物の使用方法をシステムのサイズと複雑さに合わせるように調整することが重要です。