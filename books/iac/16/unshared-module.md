Antipattern: Unshared Module An unshared module is only used once in a codebase, rather than being reused by multiple stacks. Motivation People usually create unshared modules as a way to organize the code within a stack project. Applicability As a stack project’s code grows, you may be tempted to divide the code into modules. If you divide the code so that you can write tests for each module, this can make it easier to work with the code. Otherwise, there may be better ways to improve the codebase. Consequences Organizing a single stack’s code into modules adds overhead to the codebase, probably including
versioning and other moving parts. Building a reusable module when you don’t need to reuse it is an example of YAGNI (“You Aren’t Gonna Need It”), investing effort now for a benefit that you may or may not need in the future. Implementation When a stack project becomes too large, there are several alternatives to moving its code into modules. It’s often better to split the stack into multiple stacks, using an appropriate stack structural pattern (see Chapter 17). If the stack is fairly cohesive (see “Characteristics of Well-Designed Components”), you could instead simply organize the code into different files and, if necessary, different folders. Doing this can make the code easier to navigate and understand without the overhead of the other options. The rule of three for software reuse suggests that you should turn something into a reusable component when you find three places that you need to use it.2 Related patterns An unshared module may map closely to lower-level infrastructure elements, like a facade module (“Pattern: Facade Module”), or to a higher-level entity, like an infrastructure domain entity (“Pattern: Infrastructure Domain Entity”).
アンチパターン：非共有モジュール
非共有モジュールとは、コードベースで一度だけ使用されるモジュールであり、複数のスタックで再利用されることはありません。動機人々は通常、スタックプロジェクト内のコードを整理するための手段として非共有モジュールを作成します。適用可能性スタックプロジェクトのコードが成長すると、コードをモジュールに分割することに誘惑されるかもしれません。各モジュールに対してテストを書くためにコードを分割すると、コードを扱いやすくすることができます。そうでない場合、コードベースを改善するためのより良い方法があるかもしれません。結果特定のスタックのコードをモジュールに組織することは、おそらくバージョニングや他の動作部品を含むオーバーヘッドをコードベースに追加します。再利用する必要がない場合に再利用可能なモジュールを作成することは、将来必要とするかどうかわからない利益のために現在努力をするYAGNI（「You Aren't Gonna Need It」）の例です。実装スタックプロジェクトが大きくなりすぎると、そのコードをモジュールに移動するためのいくつかの代替手段があります。スタックを複数のスタックに分割し、適切なスタック構造パターン（第17章参照）を使用することがより良い場合があります。スタックがかなり統一的である場合（「よく設計されたコンポーネントの特性」を参照）、単にコードを異なるファイルや必要に応じて異なるフォルダに整理することもできます。これにより、他のオプションのオーバーヘッドなしにコードをナビゲートおよび理解しやすくすることができます。ソフトウェアの再利用のための3つのルールは、それを使用する必要がある場所が3つ見つかったら、何かを再利用可能なコンポーネントに変える必要があることを示唆しています。2関連するパターン非共有モジュールは、ファサードモジュール（「パターン：ファサードモジュール」）など、より低レベルのインフラストラクチャ要素、またはインフラストラクチャドメインエンティティ（「パターン：インフラストラクチャドメインエンティティ」）など、より高レベルのエンティティに密接に関連する場合があります。