データ製品は長期間使用されるため、その状態を管理し、監査、デバッグ、およびこれらの製品を一生涯にわたって監督する必要があります
本章では、データ製品アーキテクチャの設計を締めくくり、データ製品を寿命全体で管理するための最後の 3 つの機能について説明します
この章では、データ製品が提供する以下の設計について説明します：データ製品の開始から変更、修正、進化を繰り返し行うためのライフサイクルの管理、グローバルポリシーに準拠したガバナンス、監視、デバッグ、および監査
ライフサイクルの管理を行いましょう
人々にやり方を教えるのではなく、やるべきことを伝え、彼らの創造性に驚かれることでしょう -ジョージ S. パットン
データメッシュのスケーリングの約束は、データ製品のライフサイクルを自律的に管理できる場合にのみ実現できます
データ製品が他のデータ製品にほとんど影響を与えずに、摩擦なく構築、テスト、デプロイ、および実行できるときです
この約束は、データ製品間の相互接続性があるときにも保たれなければなりません
相互接続性とは、データ製品の入力および出力データポートを介してデータを共有したり、スキーマを共有したりすることです
第 10 章では、データ製品のライフサイクルを管理するためのプラットフォームサービスの使用に焦点を当てて、データ製品開発者の旅路を見ました
その時点で、プロビジョニングやインフラリソースの管理、変更やリビジョンの管理など、多くの作業は、基盤となるプラットフォームであるデータ製品エクスペリエンスプレーンによって行われることが明らかになりました
ここで議論する残りの部分は、データ製品の作成と進化を提供する機能です
ライフサイクルを管理するデザイン
データ製品のライフサイクル管理におけるキーとなる機能の 1 つは、ターゲット状態の仕様を定義することです
つまり、必要なリソースと構成です
私はこれをデータ製品のマニフェストと呼んでいます
データ製品の開発者は、データ製品のマニフェストを構成し、メタデータやデータ製品の変換コード、テスト、セマンティック定義などの他のアーティファクトと共にプラットフォームに提示します
図 14-1 は、データ製品のライフサイクルを管理するための相互作用と、データ製品から期待される機能に焦点を当てて表示されています
データ製品チームは、変換コードやセマンティック定義などのソースアーティファクトと、データ製品の実行時の状態と必要なリソースを宣言するデータ量のマニフェストという 2 つのグループのアーティファクトを開発します
プラットフォームはこれらのアーティファクトを使用してビルドおよびランタイムアーティファクトを生成し、必要なリソースを提供してデータ製品コンテナを実行します
第 4 章で討論したように、データ製品の宣言モデリング（「宣言的モデリングによる複雑さの抽象化」）は、複雑さを隠すためのものです
データ製品は、マニフェストで望ましいターゲット状態を宣言します
マニフェストは変更および進化することができます
マニフェストの宣言を使用することで、データ製品開発者は、標準的な方法でデータ製品のさまざまな側面や特性を伝えることができます
また、これは物理的な実装に対して不可知論的です
開発者は時間の経過とともに宣言を変更し、新しいリビジョンを作成し、古いものを削除することができます
注：データ製品マニフェストという名前は、Kubernetes や Istio などの他の宣言的なインフラストラクチャのプロビジョニングおよびオーケストレーションシステムに触発されています
図 14-1
データ製品のライフサイクルを管理するための高レベルな相互作用

次に、データ製品マニフェストが含む内容について詳しく見てみましょう
データ製品マニフェストのコンポーネント
データメッシュは、マニフェストの定義において開発者体験を中心に据えたアプローチを採用しています
つまり、データ製品開発者は、プラットフォームの内部やプラットフォームがデータ製品をどのように物理的に提供するかに関してではなく、データ製品の側面に焦点を当てます
さらに、マニフェストはデータ製品を物理的な実装に固定するものではなく、基盤となるプラットフォームに対して無差別であり、したがって移植可能であることが理想です
表 14-1 には、マニフェストが定義するいくつかのコンポーネントの例がリストされています
表 14-1 データ製品のマニフェストコンポーネント
マニフェストコンポーネント 説明
データ製品の URI データ製品のグローバルに一意な識別子
これは、データ製品を見つけてアクセスするために Chapter 13 で最初に導入されました
出力ポート 各出力ポート、サポートされるアクセスモード、および必要な保証の宣言
この宣言に基づいて、プラットフォームはストレージやストリームトピックなどのリソースを提供します
出力ポート SLO 出力ポートごとのサービスレベル契約に関する宣言
入力ポート 各入力ポートとその構造的特性、データの出所、取得方法の宣言
ローカルポリシー ローカリティ、機密性、プライバシー、保持期間などのローカルポリシーの設定
ソースアーティファクト データ製品の一部となる他のソースアーティファクトの説明
これには変換コードや入力ポートのクエリなどが含まれます
マニフェスト言語の設計は、プラットフォームが新しいリソースの種類やデータ製品の依存関係や機能をサポートするために進化するにつれ、時間の経過とともに拡張性と新しい側面の追加が可能であるべきです
ここでは、コードで最もよく定義されるデータ製品の側面（命令的に）は含まれていません
たとえば、データ変換ロジック、入力ポートのクエリ、出力ポートのカスタムアダプター、およびポリシーのカスタム側面を強制するコードは、コードとして実装し、データ製品のソースアーティファクトとしてメンテナンスするのが最良です
データガバナンス
「コンピューテーションは、私たちの未来の定義的なアイデアであると思われる」- Stephen Wolfram
データメッシュのガバナンスと方針への適合性に関する立場は、第 5 章で紹介されたとおり、データ製品をコードとして実装し、各データ製品に埋め込むことによってデータ製品を統治する方針を実現することです
埋め込まれたポリシーは、データ製品のライフサイクル中の適切なタイミングで検証され、強制されます
たとえば、特定のタイプのデータのインメモリ暗号化がポリシーとして要求される場合、データ製品に埋め込まれたコードとしてこのポリシーを表現することで、データ製品はそのライフサイクルのさまざまな段階でこのポリシーをテストし、強制することができます
ビルドおよびデプロイ時にポリシーを強制するために、データ製品がセキュアなエンクレーブにアクセスできることを検証すること、データのアクセスと変換時にセキュアエンクレーブを使用することなどです
ポリシーをコードとして扱うという考え方は、ポリシーが、データやデータスキーマと同様に、時系列的に変化し、時間とともに変更されることを意味します
データを統治する設計
第 9 章では、各データ製品に埋め込まれたポリシーの設定と実行を可能にするデータ製品のアーキテクチャコンポーネントを紹介しました
コントロールポートの概念("コントロールポート")を導入し、データ製品の設定（たとえば、データ製品のアクセス制御ルールの設定）や高特権のガバナンス機能の呼び出し（たとえば、忘れられる権利の実行やその他のデータ修正の実行）を許可するインターフェースのセットとして紹介しました
データ製品のサイドカー("データ製品のサイドカー")の概念は、すべてのデータ製品に付随する均質な実行エンジンとして導入され、ポリシーの実行などすべてのデータ製品のクロスファンクショナルなニーズを実現します
サイドカーは、異なるポリシーに対して異なる実行メカニズムを可能にするための論理的なプレースホルダーであり、時間の経過に従ってデータ製品を段階的に装飾します
最後に、データ製品コンテナ("データ製品の計算コンテナ")の概念は、データ製品のリソースのランタイムインスタンス化をカプセル化する手段として導入されました
ガバナンスはグローバルな懸念事項であり、政策はデータ製品に一貫して適用される必要があるため、私はプラットフォームがこれらのコンポーネント、コンテナ、サイドカーなどを提供することを提案しました
これらのコンポーネントはメッシュのエクスペリエンスプレーンと協調して動作します
メッシュのエクスペリエンスプレーンは、政策の設定やメッシュ全体での忘れられる権利などのガバナンスプロセスの機能を提供します
これは図 14-2 に示されています
構成と実行に加えて、ポリシーのガバナンスには採用状況の観察が必要です
次のセクションでは、可観測性の側面について説明します
ポリシーはドメイン固有のものまたはドメインに依存しないものになり得ます
たとえば、医療ドメインデータを提供するデータ製品は、患者の健康記録のセキュリティとプライバシーを保証するために、アメリカの「健康保険移植可能性および説明責任法（HIPAA）」に準拠する必要があります
ドメインに依存しない場合、すべてのデータ製品は保証されたデータの正確さに従う必要があります
ポリシーがドメイン固有のものであるかドメインに依存しないかにかかわらず、データメッシュのガバナンスの成功に基づくいくつかの設計特性があります
図 14-2
ポリシーは、ドメイン固有のものまたはドメインに依存しないものになります
ドメイン固有のかどうかにかかわらず、データメッシュのガバナンスの成功には、次のようないくつかの設計特性が必要です
ポリシーの標準化は、メッシュ全体のすべてのデータ製品に対して一貫した方法でポリシーを表現、設定、適用することが重要です
ポリシーはすべてのデータ製品の要素であり、そのインターフェースの一部です（たとえば、コントロールポートなど）
したがって、何であるか、どのように表現され、適用されるかを標準化することで、不必要な複雑さを排除することができます
例として、アクセス制御という単純なポリシーを見てみましょう
データにアクセスできる人やシステムをどのように定義し、適用するかを示します
アクセス制御を動作させるために必要な基本の構造は、データユーザーのアイデンティティの概念です
これにより、メッシュ内外のユーザー（人間やシステム）を確実に識別できるようになります
アイデンティティを指定し、認識するための標準化された方法がなければ、複数のデータ製品間でデータ共有を行うことはほぼ不可能です
アイデンティティの設計方法が多様化すればするほど、データ共有の摩擦とコストが増すことになります
この単純な例は明らかで直感的なもののように思えるかもしれませんが、データ管理システムはまだ標準化されたアイデンティティとアクセス制御に合意していないことに驚かれるかもしれません
多くのストレージとデータ管理技術は、独自の方法で消費者のアカウントを識別し、アクセス制御を定義し適用しています
次に、標準化に大きくメリットのあるいくつかのポリシーの例を挙げます
暗号化
データ製品のセキュリティポリシーに応じて、データは転送中、静止中、最近では機密コンピューティングの進展によりメモリ上でも暗号化されます
現在、暗号化方法はかなり標準化されています
なぜなら、暗号化と復号化に関与する 2 つ以上の当事者がいるため、プロトコルについて合意する必要があるからです
データメッシュデザインでは、データ製品の検出インターフェースやスキーマに何を暗号化するか、どのレベルで、どの方法で暗号化するかといった表現を含めることで、この標準化を拡張することができます
アクセス制御とアイデンティティ
データメッシュのような分散アーキテクチャでは、単一のプラットフォームや組織の境界を越えてデータを共有するために、アイデンティティとアクセス制御の規則をどのように定義し、検証するかについて、普遍的な合意が必要です
さらに重要なのは、どのように技術に依存しない方法でこれを行うのかということです
データがどこに保存されているのか、どのクラウドプロバイダが管理しているのかに関係なく、データユーザーを識別し、アクセスを管理するための標準化された方法が必要です
運用 API やサービスへのアクセス時のアイデンティティについて合意が得られている一方で、分析的データアクセスに関してはまだまだです
運用の世界では、分散 API への移行により、エンドユーザーアプリケーションやその他のサービスとのアイデンティティの標準化が進み、OpenID Connect プロトコル、JSON Web Token（JWT）の検証、サービス向けの X.509 証明書、より最近の標準化プロトコルである SPIFFE の使用が行われています
API 共有の動機は、アイデンティティの標準を確立するための大きな推進力となっています
分析データの領域では、データはテクノロジーベンダーによってロックされています
ベンダー間でデータを共有するためのインセンティブがほとんどないため、アクセス制御の標準化に対する関心が不足しています
私は、データメッシュの主な動機であるテクノロジーシーロにとらわれないデータ共有が、これを変革するための触媒になることを期待しています

プライバシーと同意個人識別情報を保護することを目的とした地域のプライバシー法は、データを収集および管理する組織によって確率される個人の個人識別情報を守ることを目的としています（法律 3）
これらの法律は、主にデータの管理モデルとプロセスの標準化（標準化 4）をもたらしました
しかし、データ共有の標準化とインセンティブの欠如により、プライバシーと同意の標準化にはごくわずかな努力が見られます
私たちは、どのデータが個人情報として保護される必要があり、データ所有者の同意がデータと共にどのように表明および共有されるのか、彼らがデータの使用に対して同意を一貫して付与または撤回できるのか、そして最も重要なのは、データの使用状況を透明に表示できるかということについて一貫した方法を認識する方法から遠ざかっています
データメッシュは、分散型のデータ共有および管理アーキテクチャであり、すべてのデータ製品でプライバシーと同意を一貫して管理する方法を要求しています
同意は、各データ製品が組み込むことができる一種の計算ポリシーです
データとポリシーの統合データ製品は、データ、コード、およびポリシーを 1 つの保守可能な単位として統合しようとするアーキテクチャのコンセプトです
この自己完結型の単位により、特定の技術的なストレージの境界の外でプライバシーや同意を管理することが困難になります
たとえば、同意ポリシーをデータから分離すると、ユーザーの同意を追跡したり尊重したりすることが難しくなります
データメッシュは、ポリシーとその設定を、それを統治しようとするデータとリンクします
ポリシーのリンキング
データ製品のポリシーは、異なるデータ製品間でデータのセマンティクスやデータエンティティにリンクするように、章 13 で議論されたように、お互いにリンクすることができます
したがって、データが特定のデータ製品を超えて共有されると、元のデータを統治する元のポリシーへのリンクを維持します
データの変換によってリンクが失われ、元のデータとスキーマへのリンクがなくなる場合、ポリシーリンクも自然に破れます
ポリシーリンクは、複数のデータ製品にとって、ソースデータ製品が維持するポリシーの最新の状態へのアクセスを維持するのに役立ちます
これはさらなる開発が必要な分野ですが、データメッシュは、データと共に常に存在するポリシー共有の基盤を実現します
観測、デバッグ、監査制御ではなく、観察しましょう -グレゴール・ホープ
データ製品の最終で不可欠な能力である観測力について見てみましょう
データ製品の観測力とは、外部出力を観察することによってデータ製品およびそれによって形成されるメッ API 共有の動機は、アイデンティティの標準を確立する大きな要因となっています
データの分析領域では、データはテクノロジーベンダーによってロックされています
ベンダー間でデータを共有するためのインセンティブがほとんどないため、アクセス制御の標準化に関心がない状況が生じています
データメッシュの主な動機である技術シロにとらわれないデータの共有が、この状況を変えるきっかけとなることを期待しています

プライバシーと同意に関して、最近の 10 年間の地域のプライバシー法は、個人の個人情報を保護することを目的としています
これらの法律は、データをキャプチャし管理する組織における操作モデルやプロセスの標準化をある程度実現してきました
しかし、データ共有の標準化やインセンティブの不足のため、プライバシーと同意の標準化にはほとんど取り組まれていないことが分かります
どのデータが個人情報として保護されなければならないのか、データオーナーの同意がどのように表明され共有されるのか、彼らが一貫して同意を与えたり取り消したりする方法、そして何よりも彼らが自分のデータの使用を透明に確認できる方法において、一貫した方法がまだ遠いところにあります
分散データ共有と管理アーキテクチャであるデータメッシュは、すべてのデータ製品にわたるプライバシーと同意の一貫した管理方法を求めます
同意は、各データ製品に埋め込まれるコンピューテーショナルポリシーの一種です

データプロダクトというアーキテクチャの量子としてのデータ製品の概念は、データ、コード、およびポリシーを 1 つの保守可能な単位として統合しようとします
この一体化されたユニットにより、特定の技術的ストレージの枠外でプライバシーや同意を管理することを含む、多くのガバナンスの問題から解放されます
例えば、同意ポリシーをデータから分離することは、データが同意が管理されている特定の技術システムの境界を超えて共有された場合、ユーザーの同意を追跡したり尊重することが困難になります
データメッシュは、ポリシーとその設定をデータと結びつけてガバナンスしようとします
ポリシーのリンク化は、異なるデータ製品間でデータの意味やデータエンティティにリンクするのと同様に、データ製品のポリシーをデータ製品間でリンクさせることができます
これにより、データが特定のデータ製品から他の製品で処理される際に、それが管理する元のポリシーへのリンクを保持します
データの変換によって元のデータとスキーマへのリンクがなくなるような場合、ポリシーリンクも自然に切れます
ポリシーリンクは、複数のデータ製品が、ソースデータ製品が管理する最新のポリシーの状態にアクセスし続けるのに役立ちます
これは更なる開発を必要とする領域ですが、データメッシュはデータと共に分散されて常に存在するポリシーの共有の基盤を提供します

「制御するのではなく、観察する」ということを考えてみましょう
データプロダクトの最終的で不可欠な機能である観測性について見ていきましょう
データプロダクトの観測性とは、それらの外部出力を観察することで、データプロダクトとメッシュの内部状態を推測する能力のことです
観測性は、以下のような質問に答えることを目的としています：データプロダクトはその仕事を成功裏に遂行していますか？彼らの保証を果たしていますか？データプロダクトはポリシーに準拠していますか？処理されたデータは統計的特性、ボリューム、頻度、範囲、分布などを満たしていますか？データプロダクトへの不正なアクセスはありましたか？データプロダクトに問題はありましたか？もしそうなら、その原因は何ですか？将来の予想される問題はありますか？観測性は、個々のデータ製品とそのメッシュのレベルでこれらの質問に答えます
データメッシュの分散アーキテクチャは、データ製品を結びつけてデータ、データモデル、ポリシーを共有するため、観測性において複雑さを生み出します
移動部品は多くの個別の故障が起こり得ますし、監視する必要があるデータ製品と相互接続も多いため、障害が見逃されることもあります
モノリシックで緊密に結合されたシステムでは、単一の障害が全体のシステムの障害につながることがよくあり、それは容易に検出できます
データメッシュでは、データ製品の緩い結合によって障害をできるだけ局所化するため、自動化された包括的な観測性が必要です
データ製品の観測性の使用例は次の通りです：メッシュの操作的健全性を監視する - データ製品は、予期しているデータを受け取り、正常に変換を行い、SLO の保証および予想される統計的特性に準拠してデータを提供しているかを監視します
観測性は、これらのプロセスに何らかの中断があるかどうかを検出し、自動的に自己修復し、問題を修正し、関係者に通知します
デバッグとポストモーテム分析 - 何かがうまくいかない、データが予想と一致しない、またはデータの受信、変換、または提供にエラーがある場合、データ製品の観測性は、データ製品の開発者や所有者が障害の影響を評価し、原因を見つけるのを支援します
監査を実施する - データ製品は、監査（規制、リスク、コンプライアンス、セキュリティなど）をサードパーティが実施できるようにします
たとえば、サービスはセキュリティの保証のためにアクセスログを連続的に自動監査できます-誰がいつ、どのようにデータにアクセスしているか
データの系譜を理解する - データの出所やその経過した変換を理解することは、データを理解し信頼するための要素であり、データの問題をデバッグするために必要です
モデルの品質が大きくトレーニングデータの品質に依存する機械学習では、データの系譜を評価するためにデータサイエンティストがより深い理解と信頼を求めることがよくあります
系譜は、実行時のデータおよびモデルに関連するコンテキストメトリクスと組み合わせて、ML モデルの偏差の根本的な問題を理解し把握するために必須です
観測性の設計
データメッシュの観測性は、各データ製品がデザイン上、外部の出力を共有し、その状態を報告することから始まります
各データ製品は、データを消費し、変換し、共有する際にログ、トレース、メトリクスを共有します
これらの出力を基に、メッシュ体験面はメッシュレベルの状態を観測および監視することができます
データ製品の観測性の役割は、既存のデータの観測性とデータメッシュの主な違いです
従来の手法では、データチームがデータの状態を検査し、レイクやデータウェアハウスで後でデータを確認することによってデータの状態を監視します
データメッシュでは、こうした事後のデータチェックの多くが、データ製品の変換、テスト、制御の実装の一部として、データの計算的な期待値として表現されます
データ製品が観測可能な出力を持つことによって実現される数つの特徴的な設計について話しましょう
観測可能な出力 - マイクロサービスなどの分散アーキテクチャでは、次の 3 つの種類の外部出力が観測性を可能にするために収束しています：ログ、トレース、メトリクスとしてよく言われる観測性の柱です
ログ - ログは、特定のタスクの処理と実行の結果として生成される、変更不可能でタイムスタンプが付いた、しばしば構造化されたイベントです
データ製品の場合、データの消費、検証、変換、提供の過程でログが生成されることがあります
たとえば、アーティストプロファイルデータ製品のログは、入力ポートからアーティストオンボーディングサービスから新しいデータが受信された時点、データを一連の変換を経て本番環境に展開するためのステップの概要、および特定の処理時間のデータがデータユーザーに提供可能になった時点などをキャプチャすることができます
ログが有用で安全に利用されるためには、構造を標準化し、ログが一貫して提供する必須要素を定義し、ログ内の情報を過度に公開しない適切なプライバシー対策を実施することが重要です
これにより、メッシュの運用状態に関する洞察を得るためにログを自動化および機械学習ベースで分析できるようになります
自動化された分析を行わずにログを収集することは、それを分析する能力を持たない他の大容量データの収集と同様に無駄な試みです
トレース
トレースは、因果関係がある分散イベントの記録です
トレースレコードは、アクションとイベントのエンドツーエンドのフローを符号化できるように構造化されています
ログと同様に、トレースも不変、タイムスタンプが付けられ、構造化されたイベントです
解析データプレーンでは、トレースの主な使用法はデータの起源からデータ製品を介してデータがどのようにフローするか、各製品でデータがどのように変換されるかを示すデータラインエージを作成することです
ログと同様に、データ製品は自分たちのトレースの構造をモデル化するために単一の標準を採用します
なお、操作プレーンのトレースでは、しばしば要求の結果として実行される呼び出しとトランザクションのツリーをキャプチャします
例えば、アーティストのリストを取得するための Web リクエストは、さまざまなマイクロサービスへの呼び出しを結果としてもたらすことがあります
データメッシュのトレースは、データまたはデータリクエストが入力ポートと出力ポートのグラフを介してフローすることを表します - データ製品のソースからデータの出所、最終的なデータ消費者まで
メトリクス
メトリクスは、データ製品のビルド時およびランタイムの特性を継続的に伝える客観的に数量化可能なパラメータです
第 13 章の「データの保証を確立する」で、タイムライン、完全性、正確性などのメトリクスのいくつかのカテゴリを紹介しました
ログおよびトレースと同様に、メトリクスも不変でタイムスタンプが付けられた（数値であることが多い）イベントであり、一定期間追跡できます
これらの要素は、データ製品に分散観測モデルを適応するための素晴らしい出発点です
第 9 章では、データ製品が外部の観測性の出力を共有するための標準インターフェースとして観測性 API（「データの発見と観測性 API」）を紹介しました（図 14-3 参照）
図 14-3
観測性 API によって共有される 3 種類のデータ製品の出力 メトリックス、ログ、トレースのトレース 操作プレーンから多くのデータ製品が発生しています
具体的には、ソースに合わせたデータ製品は、共同作業中の操作システムからデータを取得します
たとえば、アーティストプロフィールデータ製品はアーティストオンボーディングマイクロサービスアプリケーションを使用してアーティストが登録することにより存在を開始します
したがって、データのラインエージ全体の完全な画像を提供したり、問題のデバッグや原因分析を行うためには、データの観測性をデータ製品から操作システムまで広げる必要があります
観測性データは操作システムに追跡可能でなければなりません
構造化および標準化された観測性データ
データ製品の観測性データから高次のインテリジェンスと洞察を創造するために、メトリクス、ログ、トレースは構造化された形式であり、理想的には標準化されている必要があります
データ製品のグローバル URI、実際のおよび処理のタイムスタンプ、出力ポートの URI など、特定のフィールドをモデル化する必要があります
任意の構造化情報には、フリーフォーマットのメッセージ用のプレーンテキストなど、非構造化要素が含まれる場合があります
執筆時点では、データ製品のメトリクス、ログ、トレースに対する業界標準の作成の必要性があります
ドメイン指向の観測性データ
観測性を時間をかけてスケーリングおよび拡張する方法の 1 つは、観測性自体にドメイン指向の設計を適用することです
たとえば、データの品質、データの形状、データの整合性などの観測性のドメインを作成することができます
メッシュレベルの観測性情報自体もデータ製品として管理できると想像できます
たとえば、データ品質データ製品は、メッシュのデータ品質に関するメトリクスと補完的な洞察のセットを提供できます
注意：私は常に、すべてのデータについてのデータを一つのメタデータのバケツに一般化することに不安を感じていました
このアプローチは、異なるクラスのメタデータを設計する意図を排除します
実際、私の文章では、できるだけメタデータという言葉を使用しないようにしてきました
私の個人的な信念は、すべてのデータはデータであり、異なる種類のデータ間には相関関係や関連性があり、すべてのデータはドメインのコンセプトとして設計することができます
例えば、ビジネスドメイン（例：アーティストのプロフィール）から可観測性ドメイン（例：データ品質の指標）まで
データ製品の再利用可能なコンセプトは、すべての分析データに対応します
要約すると常に逆を行う必要があります -カール・ヤコビ
もし私がこの章から一つの要点を残すことができるなら、それはデータの管理、統治、観察の責任を誰に持っていくかについての視点を逆にすることです
事後に関与する外部の当事者からデータ製品自体に責任を移すことです
データ製品の量子においてデータと計算能力とポリシーがペアになり、基本的な機能を提供できます
例えば、マニフェストの助けを借りて寿命を管理し、埋め込まれたポリシーの実行によってデータを統治し、ログ、メトリクス、トレースの出力によって状態を観察することです
この章で紹介されたすべてのデータ製品の機能の設計特性には共通のテーマがあります
標準化、メッシュレベルの相互運用性のためのデータ製品のインターフェースの標準化、例えばログの共通構造の採用
エマージェンス、個々のデータ製品からのメッシュレベルの機能の出現、例えば、各データ製品の入力、変換、出力のトレースを観察することによる起源の発見
エージェンシー、各データ製品が可観測性の出力、エラーログ、メトリクスなどを共有する機能
拡張性、新しい能力を時間的に有効にする機能、例えば新しいポリシーに適合すること
この章では、データ製品の機能と利点に関するデータメッシュの議論を終了します
次に、戦略、実行、組織変革におけるデータメッシュの大局的な見方について見ていきます

## 感想とまとめ

- データマニフェストを使って宣言的にデータ製品を定義するのは面白いしそうするべき
- ポリシーもコードとして宣言することが大事なので、全てがコードで宣言することが大事そう
- これによって、全てのメタ的なデータを吸い取ることができてデータの発見性とかを保証するのかな
- ログとかも標準化した方が良いってのはわかるけど、Open な企画がないものも標準化していくのは骨が折れそう

  - SaaS とかに飛びつきたくなるが、本当にそれで良いのか？ってのは気になる
    - 今は様々ななプラットフォームと連携する必要があるので、今回のような側のプラットフォームはある程度中立的かつ汎用的なものが良いと思う
  - ただ、自分たちでスクラッチでやっていくとなると、覚悟は必要そう

- 最終的には全てマニフェストで宣言して、プラットフォームが作成される様にしたい
- ただプラットフォームを作って、それが成功かどうかは多くの人に使ってもらわないとわからないので、この進め方は結構大事
  - いつものウォーターフォール的な進め方だと破綻する気がする
  - ただし、どの様なことができる基盤なのかはしっかり定義しないとそれはそれで何をしていいのかわからなかったり、使ってもらう人のデータなどに依存したプラットフォームができてしまいそうなので難しいところ

### 抜粋

アイデンティティを指定し、認識するための標準化された方法がなければ、複数のデータ製品間でデータ共有を行うことはほぼ不可能です

アイデンティティの設計方法が多様化すればするほど、データ共有の摩擦とコストが増すことになります

データメッシュは、ポリシーとその設定をデータと結びつけてガバナンスしようとします

事後に関与する外部の当事者からデータ製品自体に責任を移すことです

