理論の最も重要な目標は、経験の基本的な要素をできるだけ単純かつ少なくすることでありながら、十分な表現を失わずに目的を果たすことです
ー アルベルト・アインシュタイン
本書のこの部分では、データメッシュアーキテクチャの技術的なデザインについては想像力に任せてきました
これは必要でした
まず、データメッシュとは何か（第 I 章）を共有し、なぜそれにシフトする必要があるのか（第 II 章）について共通理解を持つ必要がありました
そして、データメッシュの技術的な実装を可能にするアーキテクチャをモデル化する時期です
範囲この執筆時点では、データメッシュは開発初期の段階にあります
最適な設計について学ぶにはまだまだ時間がかかります
したがって、この部分の範囲は、データメッシュの設計と実装が引き続き進化することに対して敬意を表しています
それでも、どこかから始めなければなりません
そのため、この章では、今日重要な要素に焦点を当てることにしました
私が今日重要だと考えるアーキテクチャの側面です
重要なのは何ですか？論理的なアーキテクチャに関する共通理解を持つことが重要です

第 9 章「論理的なアーキテクチャ」では、ドメイン、アーキテクチャの量子としてのデータ製品、複数のデータプラットフォームのレイヤーがどのように相互作用するかなど、データメッシュアーキテクチャの主要な論理的な構成要素を定義します
第 10 章「マルチプレーンデータプラットフォームアーキテクチャ」では、データメッシュの実装を構築、実行、運用するためにインフラストラクチャプラットフォームが提供する必要がある機能を定義します
本書には、アーキテクチャの物理的なレイヤーや具体的な技術は含まれておらず、現在の技術を使用してアーキテクチャのコンポーネントを実装するためのものではありません
たとえば、データ製品の変換フローを管理するために Apache Airflow、Prefect、または Azure Data Factory を使用するかどうかは、この範囲外です
このセクションの意図は、データメッシュの誤解や誤用の余地をなくし、創造的な思考と新しいテクノロジーやツールの創出を許すことです
図 III-1 は、この本の範囲内および範囲外のいくつかの例を示しています
図 III-1. この本の範囲はアーキテクチャに焦点を当てており、実装の設計にはそれほど重点を置いていない成熟度本書のこの部分は、データメッシュアーキテクチャを実装する経験に基づいており、個人的な意見も含まれています
一部の概念は実装され、テストされ、一部は未来に向けた実験やテストがさらに必要です
本書のこの部分に含まれているのは、利用可能な技術に基づいて、データメッシュアーキテクチャをどのように実装できるかに関する私の提案です
これはデータメッシュの原則を具体化する方法の一つです
これは、類似のスケールアウトされたアーキテクチャで成功を収めたアプローチに影響を受け、データの問題領域に適応されました
トピックが実験的でさらなる探求や洗練を必要とする場合、明確に示します
1 ラルフ・ジョンソンの影響を受けたアーキテクチャに関するマーティン・ファウラーの要約定義

第 9 章 論理的なアーキテクチャ
形は常に機能に従うー ルイス・サリバン

この章では、データメッシュの論理的なアーキテクチャを紹介します
高レベルの構造的な構成要素とそれらの関係を含みます
アーキテクチャに至るまで、データメッシュの原則を説明し、それぞれの原則が新しいコンポーネントと統合によって全体のアーキテクチャにどのように影響を与えるかを示します
形を作るための機能と意図に従って進めます
以下に、この章で詳しく説明するアーキテクチャの概念の要約を示します
データ共有インターフェースを持つ分野所有は、分析データのドメイン所有につながるデータ所有権は、分析データのドメインセントリックな組織化をもたらします
これにより、ドメインのインターフェースは、その解析データの共有に拡張されなければならないことを意味しています
図 9-1 は、この拡張を表記的に示しています
図 9-1
解析データ共有インターフェースを拡張したドメインインターフェース
データが製品として導入されると、新しいアーキテクチャの量子、つまりデータの量子が導入されます
データメッシュでは、各データ製品をアーキテクチャの量子として表現します
アーキテクチャの量子として、データ製品は、その使用性の特性と安全な解析データの共有の振る舞いを実装するために必要なすべてのコンポーネントをカプセル化します
データ量子はデータメッシュアーキテクチャの基礎的な単位です
これには、ドメイン指向のデータ、必要なデータ変換を実行し、データとデータを共有するポリシーを定めるためのコードが含まれます
図 9-2 は、データ量子の主要な構成要素を示しています
図 9-2
アーキテクチャの新しい単位、データ（製品）量子
自己サーブデータプラットフォームは、マルチプレーンプラットフォームアーキテクチャを推進します
自己サーブプラットフォームは、データメッシュのユーザーが様々なジョブを行うためのさまざまなサービスを提供します：データプロデューサー（データ製品開発者、データ製品オーナー）、データコンシューマー（データアナリスト、データサイエンティスト）、データガバナンス機能のメンバー
データメッシュは、このプラットフォームを 3 つのプレーンとして設計します -データメッシュユーザーの経験に基づいて配置された共同サービスのグループ
図 9-3 は、プラットフォームのプレーンを示しています
図 9-3
宣言型インターフェースを備えたマルチプレーンデータプラットフォーム
フェデレーテッドコンピューテーショナルガバナンスは、各データ製品に計算ポリシーを埋め込みます
フェデレーテッドコンピューテーショナルガバナンスの原則に基づいて、各データ製品は計算ポリシーを埋め込むことができる計算コンテナで拡張されます
この計算コンテナには、データ製品ごとに計算ポリシーを埋め込み、データの流れの中で正しいタイミングでそれらを実行するサイドカー処理をホストすることができます
データ製品サイドカーは、データ製品の実行コンテキストを共有し、ポリシーの実行などのドメインに依存しない共通の関心事に責任を持つプロセスです
ポリシーの実行に加えて、サイドカープロセスはディスカバリなどのデータ製品の他の標準化された機能を実装するために拡張することができます
サイドカーの実装は、すべてのデータ製品で共通です
図 9-4 は、データ製品が計算コンテナ（コンテキスト）を共有するデータ製品サイドカーの概念を示しています
図 9-4
設定とポリシーの実行を埋め込むために拡張されたデータ製品
現時点では、私はクライアントとの取引で関わっているこれらのアーキテクチャコンポーネントの複数の非公開の実装があります
これらの実装のそれぞれは異なっていました
したがって、公開で通用する標準またはリファレンス実装はまだ存在しません
私は来年以降に状況が変わることを願っています
これらの各アーキテクチャコンポーネントをもう少し詳しく見てみましょう
ドメイン指向の解析データ共有インターフェース
データの所有権のドメイン指向の分解を促進するために、解析データをドメインごとに配置するアーキテクチャをモデル化する必要があります
このアーキテクチャでは、ドメインの他の部門とのインターフェースは、運用能力だけでなく、ドメインが生成し所有する解析データも共有します
たとえば、ポッドキャストのドメインは、意味的に新しいポッドキャストエピソードを作成するための操作 API だけでなく、長期間のすべてのポッドキャストエピソードデータとその使用統計を取得するための解析データインターフェースも提供します
各ドメインは、自分のデータ-運用的および解析的データを制御します
私の仮定は、ドメインには既に運用インターフェース、アプリケーション API があるということです
これはデータメッシュが導入するものではありませんが、データメッシュは運用 API と統合します
運用 API に加えて、ドメインは自分の解析データ共有 API を制御および管理します
スケーリングするためには、アーキテクチャはドメインチームが運用アプリケーションと分析データ製品のリリースと展開を自律的に行えるようにサポートする必要があります
図 9-5 は、各ドメインが 1 つまたは複数の運用および分析インターフェースを公開できることを示す私の図式表記の例です
図 9-5
表記法：ドメインとその分析および運用インターフェース
これらのインターフェースとその依存関係について詳しく見てみましょう
運用インターフェースの設計
今日、ドメインはさまざまなソリューションを使用して運用能力を実装しています
たとえば、ドメインには、顧客向けの GUI アプリケーション、ヘッドレスアプリケーション、レガシーシステム、SaaS 製品、マイクロサービス、またはイベント駆動型の Function as a Service が含まれることがあります
ソリューションの種類に関係なく、論理的には、各ドメインがユーザー（組織内または組織外のシステムまたは人）にインターフェースセットを通じて提供されます
たとえば、ドメイン関数を実装するマイクロサービスの場合、ドメインインターフェースには、マイクロサービスが公開する API（GraphQL、REST、gRPC など）が含まれます
これらのドメインインターフェースは、前の図で「O」の棒付きキャンディで示されています
運用インターフェースは、関数（たとえば、アーティストへの支払いまたはリスナーの登録）を意味論的に実装します
構文的には、これらの関数は、CRUD 操作で修正される宣言的リソース上の操作として実装できます
たとえば、リスナー登録サービスの運用 API は、ページネーションと共に、北米の登録リスナーのリストを取得する機能が提供されることがあります（例：HTTP GET/listeners-subscriptions?region=NA）
データメッシュは、エンタープライズアーキテクチャの既存の側面を変えるわけではありません
それは単にその存在を認めるだけです
一部の場合では、データメッシュは運用インターフェースを使用してデータ製品を作成します
分析データインターフェースの設計
分析データの共有の責任がドメインに拡張されると、新しい一連のインターフェースが導入されます
これらのインターフェースは図 9-5 の「A」としてマークされています
分析インターフェースは、データ製品がデータを発見、理解、観察し、共有するために公開する API です
この時点では、これらの機能をカプセル化する高レベルの API については広く受け入れられた規則はありません
分析データの共有には、アクセスポリシーが適用されると、クライアントをデータの基礎的なストレージにリダイレクトする選択肢があります
データ製品の実装に応じて、データ共有インターフェースは、blob ストレージ（たとえば AWS S3 の Parquet ファイル）、イベントストリーム（たとえば Kafka トピック）、テーブル（たとえば BigQuery テーブル）など、あるいはまったく異なるものにアクセスをリダイレクトできます
ドメイン間の分析データ依存関係
各ドメインは、他のドメインの運用および分析データインターフェースに依存する場合があります
次の例（図 9-6）では、各ドメインがいくつかの運用および分析インターフェースを提供しています
たとえば、ポッドキャストドメインは、ポッドキャストエピソードの作成やリリースなどのいくつかの運用 API を提供します
また、リスナーの人口統計情報の取得やトップデイリーポッドキャストなどの分析データも提供します
各ドメイン間には依存関係があります
たとえば、ポッドキャストドメインは、ポッドキャストリスナーの人口統計情報に関する情報をリスナードメインから取得し、ポッドキャストリスナーの人口統計の概要を提供します
依存関係を確立するメカニズム（イベントを非同期に使用するか同期的にプルするか）は、実装に関する問題です
しかし、重要な点は、データ製品がソースへの依存関係を明示的に定義することです
データメッシュアーキテクチャでは、データの依存関係はデータ製品が上流のソースに対して定義および制御されます
データ製品は、自身のソースとそれらから消費するデータ、およびその方法を完全に制御します
図 9-6. 例：ドメイン指向のデータ依存関係
注釈：この例では、私がインターフェースに使用したラベルは、そのインターフェースの構文ではなく、意味を定義しています
例えば、構文的には、芸術家に支払うという意味は、芸術家の支払いなどの宣言的なリソース（RESTful リソースや GraphQL クエリなど）として実装される場合があります
データプロダクトとはアーキテクチャの量子です
データ製品とは、ビルディングエボリューショナリーアーキテクチャ（O'Reilly）で定義されるアーキテクチャの最小単位であり、独立して展開でき、高い機能的結束性を持ち、「機能に必要な構造要素がすべて含まれている」という特徴があります
データメッシュの場合、データ製品はアーキテクチャの最小単位です
独立して展開および管理できます
高い機能的結束性を持ち、特定の分析変換を実行し、ドメイン指向の分析データとして結果を安全に共有します
機能を遂行するために必要なすべての構造コンポーネントを有しています：変換コード、データ、メタデータ、データを管理するポリシー、およびインフラストラクチャへの依存関係
厳密にアーキテクチャに関する議論の場合、この章のように、データ製品（アーキテクチャの最小単位）を省略し、データ製品量子という用語を使用して、または手抜かり的にデータ量子という用語を使用することがあります
これらはすべて互換性があります
Data quantum は、データメッシュのデータ製品のアーキテクチャを設計するための意見形成の方法です
多くの人には馴染みがないと思われるフレーズ「データ量子」を選んだ理由を知ると役に立つかもしれません
なぜ「データサービス」「データアクター」「データエージェント」「データオペレーター」「データトランスフォーマー」などではないのでしょうか
これらのほとんどの名前は、オペレーターやトランスフォーマーなど、データ量子の単一の側面、すなわちタスクと変換の実行に重点を置いています
同様に、データサービスは別の側面、つまりデータの提供に重点を置いています
ビルディングエボリューショナリーアーキテクチャで最初に紹介され、後に書籍「ソフトウェアアーキテクチャ: ハードパート」（O'Reilly）で詳述された量子は、データ量子の意図を完璧に具現化しています
つまり、その仕事を自律的に行うために必要なすべて
私は、ここで重要な技術用語に新たに作られた造語を使用する理由をご理解いただければと思います
アーキテクチャの量子は、システムがスケーリングアウトできる軸です
データメッシュは、データ製品を追加し接続することでスケーリングアウトします
アーキテクチャの量子は、静的結合（ビルド時のライブラリなど）または動的結合（非同期ランタイム API など）を介して他のコンポーネントと統合します
データ製品は、データ共有インタフェースの動的結合を通じて他のデータ製品と統合します
パート IV では、データ製品をアーキテクチャの量子として掘り下げています
データ製品の構造コンポーネント
データ製品には、データ以上のものが含まれています
データのみでなく、その基本的な使いやすさの特性（発見可能性、理解可能性、アドレス可能性など）を自律的に表現するために必要なすべての構造コンポーネントを含める必要がありますが、データの準拠および安全な共有を続けます
高レベルでは、データ製品には 3 つのタイプの構造要素があります：コード、データ（およびメタデータと設定）、およびインフラストラクチャ依存関係の仕様（図 9-7）
コード
データ製品が分析データのライフサイクルを独立して制御し、生成するビジネスロジックを維持し、リビジョンを管理し、アクセスを制御し、コンテンツを共有するためには、コードを含め、それを計算コンテキスト内で実行する必要があります
これはデータメッシュがデータ製品と他のデータアーティファクトとの基本的な違いです
データ製品はアクティブであり、ファイルやテーブルなどの他のデータアーティファクトは受動的です
データ製品が制御するさまざまなタイプのコードを見てみましょう
コードとしてのデータ変換
データ製品は、上流のソースから受信したデータ（隣接する操作システムからなど）を変換するか、データ自体を生成します
いずれの場合でも、データを生成して共有するために解析的な計算が必要です
例えば、ポッドキャストのデモグラフィックスは、リスナーのデモグラフィックスとリスナーが再生したポッドキャストに基づいています
その解析変換コードは、2 つを集約し、リスナーのポッドキャストのカテゴリなどのポッドキャストのリスニング行動に基づいて、リスナーのデモグラフィックスに関する他の情報を導出し追加し、結果をポッドキャストのデモグラフィックスとして共有します
このコードは、新しいポッドキャストが再生されるたびに継続的に実行されます
従来のアーキテクチャでは、このコードはデータ製品の外部に存在し、データパイプラインとして管理されます
パイプラインは独立したアーティファクトとして管理され、たとえば DAG の設定として使用されます
出力データは独立して管理され、たとえばデータウェアハウスのテーブルとして扱われます
データメッシュでは、外部パイプラインのコンセプトが削除され、内部変換コードが導入されます
このコードはパイプラインとして実装される場合もありますが、そうでない場合もあります
重要な違いは、このコードがデータ製品の内部実装としてカプセル化されていることです
そのライフサイクルはデータ製品によって制御され、データ製品に割り当てられた実行コンテキストで実行されます
変換コードはドメイン固有であり、ドメインのビジネスロジックやデータの集約およびモデリングなどのタスクをカプセル化します
これはデータ製品の開発者が大部分の時間と注意を費やすコードです
図 9-8 は、データ製品の変換コードを示すために、この書籍で使用している表記方法を示しています
このコードには、実装とそれを検証する自動テストが含まれます
なお、データインジェスチョンやデータクレンジングなどの伝統的なデータパイプラインのステップは、変換コードから省いています
これは、データメッシュと伝統的なパイプラインの違いをさらに明示するためです
データクレンジングはほとんどの場合、上流のソース（例：データ製品）の責任です
データの整合性を提供します
したがって、通常のクレンジング処理は、データ製品のコードではほとんど必要ありません
伝統的なパイプラインの場合、データクレンジングの作業には、不完全なデータ、不正確なデータ、誤ったデータ、関係のないデータなどの処理が含まれます
データが汚れていることを想定することは普通です
データメッシュの場合、上流のデータ製品は、データの完全性、データの整合性、データのタイムリネスに関して一定の品質を保証します
データの共有インタフェースはこれらの保証を指定し、伝えます
汚れたデータが届くということは、エラーであり、例外であり、普通ではありません
このデータはポッドキャストのデモグラフィックスにとって十分な保証かもしれませんので、さらなるクレンジングは不要です
保証のレベルが下流のデータ製品のニーズよりも低い場合、変換コードにクレンジングを含めることもあります
例えば、リスナーのサブスクリプションデータ製品は、実際の支払いから非同期にサブスクリプションのイベントを生成しますが、支払い情報は含まれません
この場合、完全なサブスクリプションの全体像を作成するために、支払い情報とイベントを統合する必要がある下流のサブスクリプション支払いデータ製品が想定されます
しかし、この場合でも、リスナーのサブスクリプションを汚れたデータとは呼びません
不足している情報を含んだままであっても、他の多くのユースケースでは合理的なデータ製品です
欠落している支払い情報はそのコントラクトの一部です
クレンジングタスクを構築する必要がある場合、上流で何か修正する必要があるサインです
インジェスチョンについては、これはデータ製品の入力機能の一部であり、変換コードではありません
この章の後半でさらに詳しく説明します
コードとしてのインターフェース
データ製品は、データへのアクセス、検出可能性情報、利用可能性ドキュメント、観測可能性メトリクス、SLO などを提供します
データプロダクトは、インターフェース（API）を介して情報を提供します
これらの API は定義された契約に従っており、データプロダクトがどのような情報を通信し、どのようにするかについての合意があります
このようなインターフェースを実装するためには、必要な情報を提供し、それらを提供するためのコードが関与しています
ロリポップ記法は、インターフェースとそのサポートコードをカプセル化します
図 9-9 は、これらのインターフェースのリストを示しています

出力データ API
データプロダクトの出力データを理解し信頼できる方法で共有する、協調 API セットが存在します
出力データ API は、データ上でリモートクエリを受け取り実行することができます
例えば、データを保持する基礎テーブル上で SQL クエリを実行するためのインターフェースです
出力 API は、データを複数の形式で共有します
たとえば、API はブロブストレージからセミストラクチャ化されたファイルを読み取るか、イベントストリームにサブスクライブすることができます

入力データ API
これらの API は、データプロダクト内部で使用され、上流のソースからのデータの設定と読み取りに使用されます
これらは上流の出力データ API へのサブスクリプションとして実装することができ、データが利用可能になったときに非同期でデータを受信することができます
これらは上流ソースで実行されるクエリとして実装することもでき、データフレームとして読み取ることができます
入力データの到着は、変換コードをトリガーします

ディスカバリーと監視 API
これらの API は、データプロダクトに関する追加の情報を提供し、ディスカバリーやデバッグに役立ちます
たとえば、ディスカバリー API は、データプロダクトを管理するチームに関する情報、検索に役立つタグ、意味に関する説明などを提供できます
ガバナンスは、これらのインターフェースの定義をデータプロダクト全体で標準化し、プラットフォームはそれらを実装するメカニズムを提供します
データメッシュでは、インターフェース API のための用語としてポートという言葉を使います
これらの API の実装は、同期的な方法（たとえば、REST）または非同期的な方法（理想的にはパブ/サブメッセージングを使用することが望ましい）で行われることがあります

伝統的には、集中型で共有のサービスがこれらのインターフェースを実装します
API のライフサイクルは、ドメインのデータやパイプラインとは独立しています
例えば、データをアクセスするためには、データのコンシューマーは中央のカタログにアクセスし、データセットを検索し、その後プラットフォームのストレージシステムの奥深くにアクセスします
対照的に、データメッシュでは、各データプロダクトがコードとして提供する意図的に設計されたインターフェースを使用してデータを発見しアクセスします
これらのインターフェースは、最終的には基礎となるストレージへの直接アクセスになる場合がありますが、データプロダクトが実行時にそれをどこでどのように行うかを制御できるようになっています
これらのインターフェースは、データプロダクトのコードとデータと同期してバージョン管理されます

コードポリシー
データプロダクトの実装によってカプセル化されるコードの最後のカテゴリは、暗号化、アクセス制御、品質、コンプライアンスなど、さまざまな振る舞いや構造的なポリシーを設定し実行するためのコードです
例えば、データプロダクトがプライバシーの分類を保護と設定すると、データは書き込み時に暗号化され、読み取り時には必要な権限を持っていることを確認した後でのみ復号化されます
プライバシークラスの解釈と検証、読み取り者の権限の確認、データの暗号化と復号化などに関与するコードは、データフローとデータプロダクトの計算コンテキスト内で実行されます
このコードはプラットフォームによって提供されますが、データプロダクトの読み取りおよび書き込み機能のフローで呼び出されます
これについては、「埋め込み型計算ポリシー」のセクションで詳しく説明します

データとメタデータ
データプロダクトが存在する理由は、分析データへのアクセスです
データプロダクトは、そのドメインデータのライフサイクルを管理します
データプロダクトは、データの性質とデータユーザーのニーズに応じて、複数のモード（ファイル、表形式、列形式など）でアクセスを提供します
データプロダクトの変換コードは、データを最新の状態に保ちます
データ共有 API は、このデータを共有します
分析データは、事業の事実、観察されるトレンド、将来の予測や推奨などを反映しています
データを利用可能にするためには、データ製品はデータに関する関連情報、通常はメタデータと呼ばれるものを維持し、提供します
たとえば、これにはデータの文書化、意味論や構文の宣言、そして SLO（Service Level Objective）が含まれます
メタデータのライフサイクルと変更頻度は、そのタイプによって異なります
たとえば、データモデル（意味論または構文）は変更が少なく、ビルド時に変更されます
しかし、ほとんどのメタデータは、データ製品が新しいデータを生成する際に変更されます
これには、データの統計的特性や現在の SLO メトリック値が含まれます
私はデータメッシュの用語集ではメタデータという言葉をほとんど使用しません
この一般的な受け皿的な用語は混乱を招き、時には有害です
これにより、意味的に異なる多くの概念がメタデータという名前のバケットにまとめられ、意図的な設計とシステムのサポートを受けるべきものが混乱します
この混同は、時間の経過とともに複雑さを増す壊れやすく集中化されたアーキテクチャにつながります
データメッシュアーキテクチャでは、メタデータとそのカテゴリやタイプがデータ製品のインターフェースの契約の一部であることが期待されています
従来のデータアーキテクチャとの大きな違いは、データ製品自体がメタデータを生成する責任を持っているという点です
これに対して、従来のシステムではメタデータは、データが生成された後に外部システムによって抽出、推測、投影されます
従来の世界では、中央のデータカタログなどの外部システムがすべてのデータセットからメタデータを抽出、収集、提供しようとします
プラットフォームの依存関係
このプラットフォームは、データ製品の構築、展開、実行を可能にします
プラットフォームはインフラリソースを一元的に管理しますが、データ製品ごとに分離されたリソースを割り当て、提供して、自律的な動作をサポートします
1 つのデータ製品の展開や更新が他のデータ製品に影響を与えないことが重要です
たとえば、ホスティングインフラストラクチャへの 1 つのデータ製品の展開が、共有インフラストラクチャ上で他のデータ製品の操作に影響を与えるべきではありません
データ製品は、期待される目標状態とプラットフォームへの依存関係を定義し、制御します
たとえば、データの保持期間や出力データへのアクセスのモードの種類などの期待値は、プラットフォームの依存関係として表現され、適切なストレージのタイプをプロビジョニングおよび管理するためにプラットフォームによって使用されます
データ製品のデータ共有の相互作用
データ製品の大部分の相互作用は、データの共有に関するものです
図 9-10 は、前のセクションで紹介したドメインおよび分析インターフェースを拡大表示しています
データ製品がその協力ソースの運用システムまたは他のデータ製品とどのように統合するかを示しています
図 9-10
データ共有の相互作用の例
各ドメインには複数のデータ製品が存在することがあります
この例では、リスナードメインには 2 つのデータ製品があります: 「サブスクリプション」と「リスナーの人口統計」
これらのデータ製品とそのデータ共有インターフェース（出力データポートとも呼ばれます）は、ドメインが公開する分析インターフェースとなります
データ製品は、協力する運用システムまたは上流のデータ製品からデータを消費することができます
この例では、ポッドキャスト人口統計データ製品は、協力する運用アプリケーションであるポッドキャストサービスと上流のデータ製品であるリスナードメジャフィックスからポッドキャストイベントを消費します
その入力インターフェース（入力データポートとも呼ばれます）は、ソースとの統合を実装し、それらからデータを受け取ります
データ製品の入力データポートと出力データポートを実装する基盤となる技術は、データメッシュの異なる実装によって異なる場合がありますが、次の共通の特性を共有しています
入力データポート: データ製品が 1 つまたは複数のソースからデータを消費するために実装する内部統合メカニズムです
たとえば、データ製品は、協力するマイクロサービスからほぼリアルタイムのドメインイベントを消費し、それらを長期保存の分析データに変換することがあります
もしくは、入力データポートは、データの集計結果を受け取り、それを集計データに変換するために、データプロダクトが上流のデータプロダクトに対して呼び出すクエリのトリガーとなることもあります
図 9-10 では、ポッドキャストのデモグラフィックスは、リスナーの人口特性の統計的な要約を提供する集計データプロダクトです
これは、ポッドキャストのプロデューサーと Daff の両方にとって、ポッドキャストをリスナーに適切にマッチングするための有益な分析情報です
ポッドキャストのデモグラフィックスデータプロダクトは、協力するマイクロサービスであるポッドキャストサービスとリスナードメインのデータプロダクトであるリスナーデモグラフィックスからデータを連続的に受け取るために、入力データポートを使用します
出力データポート
これらは、データプロダクトの基礎データを共有する外部アドレス可能な API です
各データプロダクトは、1 つまたは複数の出力データポートを持つことができます
データメッシュでは、データにアクセスする前に、すべての消費者が呼び出す出力データポートの標準化された API を持つことを提案しています
これらの API は、データへのアクセス制御などのポリシーを強制し、消費者を基礎データにリダイレクトする前に実行されます
図 9-10 では、ポッドキャストのデモグラフィックスは、リスナーに基づいてポッドキャストを分類し拡張します
その出力データポートを介して、新たに分類されたポッドキャストのデモグラフィックスを連続的に提供します
データの発見と観測可能性の API
データプロダクトは、一連のインタフェース（同期または非同期）を介して検出、理解、デバッグ、監査に必要な情報を提供します
例えば、発見 API は、データプロダクトの識別子、所有チーム、データの意味論、ドキュメント、検索に役立つタグなどを共有します
観測可能性の API は、データ共有に関するアクセスログ、ラインナップ、およびメトリックスを提供します
Part IV では、これらの API のコンテンツと機能について詳しく説明します
マルチプレーンデータプラットフォーム
データメッシュで議論されているように、データプラットフォームがデータメッシュの約束を果たすために提供する必要がある機能とサービスのリストは長くなると想像できます
つまり、クロスファンクションのドメインチームがデータプロダクトを自律的に管理し、データユーザーが複数のデータプロダクトを発見し、学習し、利用できるようにするためのものであり、それらを安全に管理し、メッシュポリシーに準拠させることです
このようなプラットフォームを設計するための一般的なアプローチには、1 つの統合されたプラットフォームを採用する方法（通常はメインベンダーから購入する方法）と、標準的かつオープンなインターフェースを公開する一連の緩く統合されたサービスを使用する方法（異なるベンダーからのビルドとバイの組み合わせとして実装されることが多い）の 2 つがあります
データメッシュプラットフォームの設計は、後者のグループに属しています
これは、複雑なプラットフォームをその機能ごとに分割し、オープンなインターフェースを介して他の連携機能と統合することを重視しています
1 つのプラットフォームのアイデアは魅力的ですが、1 つのベンダーとやり取りする方が簡単ですが、スケールに制限があります
例えば、1 つのプラットフォームでは、サービスとデータをホストできる場所が限定され、ベンダーへのロックインが生じます
それにもかかわらず、時間の経過とともに、組織の複雑さは複数のプラットフォームの採用につながります
しかし、これらのプラットフォームはお互いにうまく連携しません
それぞれがデータまたはアプリケーションの唯一のコントローラであることを想定しています
これにより、臨時の高価な統合やプラットフォーム間でのデータのコピーが発生します
デフォルトでは、データメッシュは組織の複雑さがマルチプラットフォーム、マルチホスティング環境につながることを受け入れています
このモデルをサポートするために、データメッシュは、標準的なインターフェースを備えたサービスの構成に向けたプラットフォームのアーキテクチャのアプローチを提供します
したがって、データは異なるサービスとホスティング環境間で共有できます
例えば、データプロダクトのライフサイクルを管理するには、データプロダクトの初期化、データプロダクトの構築、データプロダクトのテスト、データプロダクトの展開、データプロダクトのモニタリングなど、一連の機能のコレクションが必要です
データメッシュプラットフォームでは、これらの機能を抽象化する（オープンな）インターフェースの設計を強調しています
API 駆動のアプローチによって、成長する複雑さに柔軟性をもたらすことができます
これにより、データ製品管理のエクスペリエンスを時間の経過と共に新しい機能で拡張したり、データ製品管理を異なるインフラストラクチャに移行したりすることができます
なお、私は意図的にプラットフォームのプレーンに対するレイヤーという用語を使用していません
レイヤーはしばしば厳密な階層的アクセスとして想像され、情報と制御が一つのレイヤーから次のレイヤーに移動するものとされます
例えば、レイヤードアプリケーションアーキテクチャの概念では、最も低いレイヤーでのデータベースアクセスを隠し、上位のレイヤーのマップされたオブジェクトを介してのみデータへのアクセスを許可します
プラットフォームのプレーンの場合、メッシュのユーザーは必要に応じて高い抽象化プレーンサービスまたは低いプレーンサービスを選択することができます
データメッシュプラットフォームの論理設計では、プレーンという概念を使用しています
プレーンは、相補的な目標を持ちながら、エンドツーエンドの結果を満たすための高い機能的な結びつきを持つ能力の論理的な集まりです
各プレーンは、サーフェスのようにインフラストラクチャの複雑さを抽象化し、実装された能力のための一連のインターフェース（API）を提供します
プレーンの能力は、そのインターフェースを通じてアクセスされます
データ製品開発者のようなエンドユーザーは、プラットフォームの複数のプレーンと直接やり取りすることができます
プレーン間には緩やかな依存関係がありますが、厳密なレイヤリングや階層アクセスモデルという強い概念はありません
プレーンは強いレイヤリングの制約なしに関心事の分離を受け入れます
データメッシュプラットフォームの論理アーキテクチャでは、プラットフォームの能力にアクセスするためのプロトコル設計に焦点を当てています
特定の結果を達成するためにデータ製品の開発、展開、管理、使用においてプラットフォームの能力をアクセスするためのものです
アーキテクチャモデリングでは、論理的なインターフェースのみを指定します
インターフェースの物理的な実装（コマンドラインインターフェース（CLI）、API、GUI など）や、論理インターフェースごとの物理的な呼び出しの実際の数は、設計の範囲外です
図 9-11 は、基盤プラットフォームの特定のプレーンを説明するために使用する表記方法を示しており、特にそのプレーンが提供する論理的なインターフェースに焦点を当てています
プレーンの利用者（システムまたは人間、データ製品、他のプレーンまたはユーザー）は、インターフェースを自己サービスの方法で使用し、インターフェースを発見し、理解し、アクセスし、呼び出すことができるはずです
データメッシュプラットフォームの複雑さと多岐にわたる機能を考慮すると、その論理アーキテクチャは複数のプレーンで構成されています
これまでにデータメッシュインフラストラクチャ向けに 3 つの異なるプレーンを特定しました
データインフラストラクチャ（ユーティリティ）プレーン
このプレーンは、メッシュを構築および実行するための低レベルのインフラストラクチャリソースの管理を担当します
たとえば、ストレージ、コンピューティング、アイデンティティシステムなどです
これは、デジタルアプリケーションインフラストラクチャと統合し、重複する部分もあります
例えば、データインフラストラクチャは、ドメインチームがアプリケーションを開発するために使用するデータ製品の CI/CD エンジンと共有することができます
別の例として、分析システムと運用システムの両方に対するオブジェクトストアのような共通のストレージタイプの管理が挙げられます
データ製品エクスペリエンスプレーン
これは、インフラストラクチャプレーンを使用してデータ製品を構築、維持、消費するための高レベル抽象化です
このプレーンのインターフェースは、データ製品と直接連携します
たとえば、データ製品開発者がデータ製品のライフサイクルを管理するのに役立ちます-データ製品の構築、データ製品の展開など
また、データ製品の消費者がデータ製品を使用するのにも役立ちます-データ製品の出力に対してサブスクライブしたりデータを読み取ったりするなど
メッシュエクスペリエンスプレーン
このプレーンは、複数のデータ製品で動作するメッシュレベルの機能を抽象化します
例えば、メッシュ上でのデータ製品の検索や、入力と出力のデータ製品の間の関連（リニアジュ）を横断して複数のデータ製品を処理するなどの操作をサポートしています
図 9-12 はプラットフォームプレーンの鳥瞰図と、それぞれが提供できる論理インターフェースのサンプルを示しています
プレーン間に厳格なレイヤリングはなく、つまり、任意の認証されたユーザー（プログラムまたは人）が任意のプレーンのインターフェースにアクセスできることを意味していますが、プレーン間には依存関係があります
図 9-12
自己サービスデータプラットフォームの複数のプレーン
メッシュエクスペリエンスプレーンは、データ製品プレーンのインターフェースに依存しており（これらを集約しています）、データ製品エクスペリエンスプレーンは、下位レベルのインフラストラクチャユーティリティプレーンのインターフェースに依存しています（これらを抽象化しています）
注意 図 9-12 で言及されているインターフェースは例であり、網羅的ではありません
明確にするために、私は命令形の言語を使用しており、実際には宣言的なリソース指向の設計が使用されるでしょう
例えば、インターフェースの意図を明示するために、データ製品の展開能力を示すために/deploy dp を使用しましたが、実際には宣言的な API（たとえば、HTTP POST/data-product-deployments）を設計することができます
サービスメッシュなどの既存のプラットフォームでは、ネットワークルーティングから 2 つの別々の連携プレーン、コントロールプレーンとデータプレーンの概念が借用されています
この関心の分離は、データメッシュプラットフォームにも適用することができます（データ製品がデータプレーンを構成し、プラットフォームがコントロールプレーンを構成すると想像できます）、ただし、私はわざとこの設計を避けています
私は経験のコンセプトを使用して、プラットフォームが異なるレベルで提供する機能と経験に焦点を当てています、個々のデータ製品のレベルとそれらをメッシュとして収集するレベルで
例えば、プラットフォームはサービスの発見とアドレス指定の経験を提供します：他のデータ製品が名前で他のデータ製品をプログラム的に見つけ、そのデータを消費するためにアドレス指定できる能力
これはもちろん、動的な登録、アドレス指定、ルーティングなどを実装する制御様なプレーンを想像することができます
これらは、経験に続く実装の詳細と考えています
基本的に、データメッシュアーキテクチャは、ユーザーに提供する経験の契約によってプラットフォームを設計します
第 10 章では、プラットフォームの機能について詳しく説明します
埋め込みコンピュータポリシーカバー
第 5 章では、データメッシュガバナンスをサポートするいくつかの種類の計算を紹介しました：計算ポリシー、データ製品の標準化プロトコル、自動テスト、自動モニタリング
アーキテクチャをどのようにモデル化してポリシーを設定し、実行し、標準を適用し、データ製品が品質の期待に準拠していることを維持するかは、ガバナンス機能の効果に直接影響を与えます
アーキテクチャは、ガバナンスを効果的に実行するためのコンジットです
データクォンタムは、分散的な形式で計算ポリシーを埋め込むための強力で拡張可能な構造です
コードとしてポリシーを定義し、実行することができます
コードとして表現されたポリシーは、メッシュ全体で一貫して利用できるようになり、それぞれのデータ製品が適切なタイミングで評価し適用できるようになります
データメッシュアーキテクチャでは、データ製品ポリシーをコードとして管理するためのいくつかの論理コンポーネントが導入されます：データ製品のサイドカーサイドカーは、メッシュ全体で標準化が必要なポリシー実行などのデータ製品の他の側面を実装するプロセスです
プラットフォームから提供されます
データ製品とともに展開および実行されます
データ製品計算コンテナプラットフォームがデータ製品とともに展開可能な単位として実行ポリシーをカプセル化する方法
省略して、これをデータコンテナと呼ぶことがあります
制御ポート制御ポートは、データ製品のポリシーを管理および制御するための一連の標準インターフェースを提供します
図 9-13 はこれらの論理的なコンポーネントを示しています
理想的には、プラットフォームはサイドカー、制御ポートの実装、および入力および出力ポートなどのドメインに依存しないコンポーネントを提供および標準化します
図 9-13
埋め込み計算ポリシーの論理的なアーキテクチャコンポーネント 注意：これらの論理コンポーネントは、1 つまたは複数の物理コンポーネントとして実装することができます
制御ポートは、データ製品のポリシーを管理および制御するための一連の標準インターフェースを提供します
データ製品のサイドカーは、各データ製品の実行コンテキストをデコレートし、メッシュ全体で標準化されると予想されるクロスカッティングの関心ごとを実行する論理コンポーネントです
サイドカーは、データ製品との動的で緩やかなカップリングを作成するために通常は別のプロセスとして実装されます
データ製品のコンテナにデプロイメント時に注入されることもあります
時間の経過とともに、複数のサイドカーを持つことがあるか、サイドカーに追加のクロスファンクショナルな機能を拡張することがあります
ただし、その設計は時間の経過とともにより多くのポリシーを含めるために拡張可能でなければなりません
データ製品間の一貫性をサポートするためにサイドカーを拡張する方法のいくつかを見てみましょう

ポリシーの実行
データ製品のサイドカーの責任の一つは、ポリシーの実行です
データメッシュガバナンスは、データモデリングなどの多様な次元でデータ製品の多様性を受け入れる一方で、一部のポリシーをすべてのデータ製品に一貫して適用する必要があります
データメッシュのような分散アーキテクチャでは、偶発的な競合やボトルネックを排除することが目的です
そのため、集中型のゲートウェイではなく、各データ製品のローカライズされた実行コンテキスト内でポリシーを設定および実行することが最適です
これを実現するための一般的な戦略は、ポリシーの実行をローカルコンテキストに注入することです
この場合、各データ製品に付随するデータ製品のサイドカーは、出力ポートへのアクセス時にアクセス制御ポリシーを評価および適用したり、データ製品が新しいデータを書き込む際に暗号化を適用したりすることができます
この戦略は、サイドカーパターンを使用してオペレーショナルシステムアーキテクチャで実装されています
サイドカーは、クロスカッティングの関心事をアプリケーションの動作に追加するプロセスです
たとえば、このパターンは、サービスメッシュがサービスのインバウンドおよびアウトバウンド呼び出しにルーティング、セキュリティ、回復性などのポリシーを実装するために使用されます

標準化されたプロトコルとインターフェース
ガバナンスの重要な目標の一つは、データ製品の相互運用可能なエコシステムを作成することです
データ製品のデータと動作を表面化するデータ製品インターフェース（入力データポート、発見ポート、出力データポート、制御ポートなど）は、データ製品間の相互運用性にとって基本的です
すべてのデータ製品のすべての入出力通信のフローに配置されるサイドカーは、標準化された API を提供することができます
例えば、サイドカーは、各データ製品から SLO メトリクスを公開するための標準化された API を提供できます
データ製品の実装は、これらの API の標準実装を使用して独自のコンテンツを公開します

データ製品の計算容器
図 9-13 で見るように、自律的に使用可能なデータ製品を作成するために、かなりの数の構造コンポーネントが束ねられています
サイドカー、ポリシーコンフィグレーション、データ製品変換コード、データ製品のデータ、データ共有インターフェースなどです
連邦ガバナンスを効果的にするためのもう一つの要素は、データ製品のすべての構造要素をアーキテクチャの一部として包括するコンテナです
データ製品の実装によってコンテナの実装が提供され、データ製品ごとに一貫して実装されます

制御ポート
計算ガバナンスは、すべてのデータ製品に新しいインターフェース、制御ポートを導入します
制御ポートは、各データ製品のポリシーを設定し、ガバナンス要件を満たすために一部の特権操作を実行するための一連の API を公開します
ポリシーの設定を構成する
制御ポートは、データ製品のコンテキスト内で実行される必要のあるポリシーを構成するためのインタフェースです
これらのポリシーは、データ製品自体によってローカルに作成および制御されることも、メッシュエクスペリエンスプレーンによって中央で作成および制御されることもあります
たとえば、データの匿名化に関するポリシーは、データ製品の個人を特定する属性（PII）を宣言することで、ローカルに作成するのが最適です
ドメインのデータ製品所有者は、データ製品に PII が含まれているかどうかを知り、設定するための最も関連性の高い情報を持っています
一方、役割の定義とアクセス制御は、しばしば中央で作成され、各データ製品でローカルに強制されます
ローカルに設定されたポリシーと中央に設定されたポリシーの両方が、1 つのデータ製品で共存することができます
制御ポートの設計は、メッシュに導入される新しいタイプのポリシーをサポートするために拡張可能である必要があります
特権操作
ガバナンス機能は、すべてのデータ製品に対して少数の特権操作を実行する手段が必要です
たとえば、GDPR の忘れられる権利（組織が集めた個人のデータをすべて消去する権利）を実行するための操作です
もし、Daff の例でリスナーの 1 人が自分の情報を消去することを決定した場合、グローバルなガバナンス機能はメッシュ上のすべてのデータ製品にこれをフラグ付けする方法を持つ必要があります
制御ポートは、個人の忘れる権利を実装する特定の高度な特権インタフェースを公開することができます
プラットフォームは、すべてのデータ製品に対して制御ポートを標準化します
レビュー
この章では、データメッシュ原則をより具体的で実装に近いものにするための論理アーキテクチャを提供しました
執筆時点では、論理アーキテクチャのさまざまな側面は成熟の異なる段階にあります
いくつかは実装およびテスト済みであり、いくつかは実験的です
表 9-1 は、それらの成熟度を明確に示しています
これらのコンポーネントは論理的であり、物理的な実装は異なる形式を取る場合があります
たとえば、サイドカーオペレーションを介したポリシーの実行のアイデアは、データクォンタムに対する随伴プロセス（サービス）として物理的に実装されるか、または共有ライブラリ（静的に結合された）として実装されることがあります
私の希望は、技術が進化し、論理的なアーキテクチャとその物理的な実装をできるだけ近づけることです
表 9-1 は、この章で紹介したデータメッシュの論理的なアーキテクチャコンポーネントを総括しています
表 9-1. データメッシュの論理的なアーキテクチャコンポーネントとその成熟度の説明 論理的なアーキテクチャ設定ポリシー コントロールポートは、データ製品のコンテキスト内で実行される必要のあるポリシーを設定するためのインターフェースです
データメッシュの論理アーキテクチャコンポーネントとその成熟度の説明 アーキテクチャコンポーネント 説明 ドメインシステム、データ製品、およびビジネスドメイン機能と結果を提供し、分析的および運用的な能力を広範なビジネスと顧客と共有するために調整されたクロスファンクショナルチーム
これは確立されたコンセプトです
ドメイン分析データインターフェース（「分析データインターフェースの設計」を参照） ドメイン指向のデータ製品を発見、アクセス、共有するための標準化されたインターフェース
執筆時点では、これらの API の実装はカスタムまたはプラットフォーム固有です
プライベートプラットフォームでは、データ共有をより便利で他のホスティングプラットフォームと互換性のあるものにするために、オープンなインターフェースを提供する必要があります
ドメイン運用インターフェース（「運用インターフェースの設計」を参照） ビジネスドメインがトランザクションの能力と状態を広範な組織と共有するための API およびアプリケーション
このコンセプトは、成熟した実装があります
REST、GraphQL、gRPC などのデファクトスタンダードによってサポートされています
データ（製品）クォンタム（「データ製品としてのアーキテクチャクォンタム」を参照） コード、データ、インフラ仕様、およびポリシーが必要なすべての構造コンポーネントをカプセル化したアーキテクチャクォンタムとして実装されたデータ製品
アーキテクチャの議論で参照されます
データ製品と同義です
執筆時点では、これはカスタムの実験的なコンセプトです
データ（製品）コンテナ（「データ製品計算コンテナ」を参照）：データ製品のすべての構造的なコンポーネントを一つにまとめ、それと連動して展開および単一のユニットとして実行するための仕組みです

この時点では、このコンセプトは実験的な概念であり、カスタムの実装が行われています
データ製品サイドカー（「データ製品サイドカー」を参照）：データ製品への補助的なプロセスです
データ製品コンテナのコンテキストで実行され、グローバルポリシーの実行などのクロスファンクションと標準化された振る舞いを実装します

この時点では、このコンセプトは実験的な概念であり、カスタムの実装が行われています
入力データポート（「入力データポート」を参照）：データ製品が 1 つまたは複数の上流ソースから連続的にデータを受け取るためのメカニズムです

この時点では、既存のイベントストリーミングとパイプライン管理技術を使用したカスタムの実装があります
出力データポート（「出力データポート」を参照）：データ製品が連続的にデータを共有するための標準化された API です

この時点では、ベンダー固有のカスタムの実装があります

このコンセプトの成熟した実装には、時系列データへの複数のアクセスモードをサポートするオープンなデータ共有の標準が必要です
ディスカバリーと可観測性の API（「データディスカバリーおよび可観測性の API」を参照）：データ製品がデータ製品の発見情報（データ製品を見つける、アドレスを付ける、学ぶ、探索するための情報）や系統、メトリック、ログなどの可観測性情報を提供するための標準化された API です

この時点では、これらの API のカスタムの実装が行われています

このコンセプトの成熟した実装には、発見情報と可観測性情報モデリングおよび共有のためのオープンな標準が必要です
いくつかの標準は現在開発中です
コントロールポート（「コントロールポート」を参照）：ポリシーの設定または高度な特権付きガバナンス操作を実行するためのデータ製品の標準 API です

このコンセプトは実験的なものです
プラットフォームプレーン（「プラットフォームプレーン」を参照）：API を介して表面化される高い機能的結束性を持つ、セルフサーブのプラットフォーム機能のグループです

これは一般的な概念であり、確立されています
データインフラストラクチャユーティリティプレーン（「データインフラストラクチャ（ユーティリティ）プレーン」を参照）：低レベルのインフラストラクチャリソース管理（計算、ストレージ、アイデンティティなど）を提供するプラットフォームプレーンです

この時点では、インフラストラクチャプレーンを構成するサービスは成熟しており、多くのベンダーが自動プロビジョニングをサポートしています
データ製品エクスペリエンスプレーン（「データ製品エクスペリエンスプレーン」を参照）：データ製品上での操作を提供するプラットフォームプレーンです

この時点では、データ製品エクスペリエンスプレーンを構成するサービスのカスタム実装が行われています
公開された参照実装はありません
メッシュエクスペリエンスプレーン（「メッシュエクスペリエンスプレーン」を参照）：連結されたデータ製品のメッシュ上での操作を提供するプラットフォームプレーンです

この時点では、ディスカバリーと検索サービスなど、メッシュエクスペリエンスプレーンを構成する一部のサービスのカスタム実装が行われています
公開された参照実装はありません
オープンリネージは、データ製品が採用できる可観測性のオープンな標準の例です

## 感想とまとめ

- どのような API を実装するべきかわかった
- プラットフォームには 3 つのプレーンがある

  - データインフラ (ユーティリティ) プレーン
    ストレージ、パイプラインのオーケストレーション、計算などの物理リソースを供給し管理するためのアトミックサービス
  - データ製品エクスペリエンスプレーン
    データ製品と直接操作する高レベルの抽象化サービスで、データ製品のプロデューサーとコンシューマーがデータ製品の作成、アクセス、保護などの操作を行うためのもの
  - メッシュエクスペリエンスプレーン
    データ製品のメッシュ上で操作を行うサービス、例えばデータ製品の検索やデータ製品間のデータリネージの観察

- 生データにリダイレクトするような API も必要なんだなと思った
- また、input 用の API っていう考えもなるほどって感じ
- 結構実験的なソリューションしかなくて、今はカスタム実装しないといけない感じか
- プラットフォーム側として何を実装すべきなのかはわかったが、多いし、どの様にして実装すれば良いかは自分でよく考える必要がありそう
- gcp とかがここら辺を解決していないかは確認したい
- 分散させる強みはコンテキストの強化と独立した成長
- デメリットは開発工数と、データがバラバラになることや、データがサイロ化すること
- 上のデメリットをプラットフォーム提供によって払拭しないといけない
