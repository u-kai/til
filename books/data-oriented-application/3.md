# ストレージと抽出

## データベースを駆動するデータ構造

- データをただファイルに追記するのをログとよび、これはシンプルだが優れたパフォーマンス
- 多くのデータベースの内部でログの仕組みは使われている

  - この本でのログは、追記だけが行われるレコードの並びを指しているらしい

- データベースから特定のキーの値を効率的に見つけるにはインデックスが必要
- インデックスは主たるデータから導出される追加のデータ構造
  - 多くのデータベースではインデックスの追加と削除が可能で、データベースの内容には影響しない
  - 影響があるのはクエリのパフォーマンスのみ
- 追加のデータ構造を管理しなければいけないので、オーバーヘッドが生じる

  - これは特に書き込みの時に生じる

- これはストレージシステムにおける重要なトレードオフ

### ハッシュインデックス

- インメモリのハッシュマップの中にはすべてのキーに対してデータファイル中のバイトオフセットをマッピングする
- 値をルックアップしたい場合にはハッシュマップを使えばデータファイル中のオフセットがわかるのでその場所までシークして値を読み出す
- Bitcask はハッシュマップを完全にメモリに置いておき、データはすべて追記する様にしている

  - 各キーに対する値が頻繁に更新される様な状況にあっている
  - 大量に書き込みは生じるが、各キーの多さは少なければ、すべてので参照データをインメモリに格納しておける

- ファイルの追記だけだと、容量が溢れることがあるので、それらにはコンパクション処理を行う
- コンパクションは、ログ中で重複しているキーを捨てて、それぞれのキーに対する最新の情報だけを残す処理
- 詳細項目の検討

  - ファイルフォーマット
    - CSV はログにとって最善のフォーマットではない
    - 最初に文字列の長さをバイトとしてエンコードして、生の文字列を続けるようなバイナリフォーマットの方が高速かつシンプル
      - なぜかはわからん
  - レコードの削除
    - キーおよびキーに関連づいた値を削除したいなら、データファイルに特別な削除のレコードを追加する必要がある(墓石と呼ばれる)
    - ログのセグメントをマージするプロセスはこの墓石を見れば削除されたキーに対するそれ以前の値を捨てることができる
  - クラッシュのリカバリ
    - インメモリのハッシュマップは再起動などで消えてしまう
    - そのため、インメモリハッシュマップを保存するようのディスクが必要
  - 部分的に書き込まれたレコード
    - ファイルにチェックサムが含まれているのでログの壊れた部分を削除したり無視したりできる
  - 並行性の制御
    - ログへの書き込みの追加はシーケンシャルな順序で行われるので、一般的にはライターのスレッドは 1 つだけにするという実装を選択することになる
    - データファイルのセグメントは追記のみが行われ、それ以外はイミュータブルなので読み取りは複数のスレッドから行える

- 追記のみのログは一見無駄が多く見え、ファイルの一部をそのまま更新し、古い値を新しい値で書き換えれば良いと思うが、追記のみを行う設計はいくつかの理由で優れていることがわかっている

  - セグメントの追記とマージはシーケンシャルな書き込み処理であり、ランダムな書き込みよりもはるかに高速
  - 並行処理とクラッシュリカバリはセグメントファイルが追記のみ、あるいはイミュータブルであれば非常にシンプルになる
  - 古いセグメントをマージすることでデータファイルが時間と共にフラグメンテーションを起こすと言う問題を避けられる

- とはいえ、ハッシュテーブルのインデックスにも制約はある
  - ハッシュテーブルはメモリ内に収まらないといけないので、キーの数が非常に多いとダメ
    - ディスク上のハッシュテーブルは高パフォーマンスを出せない
  - 範囲に対するクエリの効率が良くない
    - ハッシュマップの各キーをルックアップする必要がある

### SSTable と LSM ツリー

- Sorted String Table はキーでソートされている(ちょいと難しかった...また読んでみる)
  - 追加でそれぞれのキーは一度しか現れないという制約もある
  - 仮にファイルが利用可能なメモリ量よりも大きくなってもセグメントのマージをシンプルに効率的に行える様になる
  - ファイル中の特定のキーを探す際にすべてのキーをメモリに保存しておく必要はない

### SSTable の構築と管理

- red-black ツリーや AVL ツリーなどを使ってキーを任意の順序で挿入し、ソートされた順序で読み出す様にする
- データベースがクラッシュしてしまうと直近の書き込みが失われてしまうので、ディスク上に別個のログを持っておき、すべての書き込みを即座に追記している
- このログはソート順になっていないが、クラッシュ後のリストアだけを目的にしているため、問題にはならない

### SSTable から LSM ツリーの作成

- Elasticsearch の全文検索も key-value インデックスと似ている
- 検索クエリ中の語に対してその語を使っているすべてのドキュメントを見つける

### パフォーマンスの最適化

- データベースに存在しないものを検索すると、何もしなければ時間がかかる
  - すべての key をルックアップして、また、古いセグメントに対しても同じことをする必要があるので
- これを最適化するにはストレージエンジンではブルームフィルターが追加される
- ブルームフィルタは集合の内容についての概要を保持するメモリ効率の良いデータ構造
- ブルームフィルタを使うとあるキーがデータベース中に存在しないことがわかるので存在しないキーのために不要なディスクの読み取りが多発することを防ぐことができる
