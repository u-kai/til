# 2 データモデルとクエリ言語

- データモデルはソフトウェアにできること、できないことに関して大きな影響を及ぼすのでアプリケーションに適したデータモデルを選択することは重要

## リレーショナルデータモデルとドキュメントモデル

- リレーションは順列無しのタプル
- リレーショナルモデルは理論として提唱されたもの
- RDB は 25 年から 30 年にわかって支配的だった(IT の時間で言うと永遠な時間)
- RDB の起源はビジネスデータ処理にある

  - トランザクション処理
  - バッチ処理

- リレーショナルモデルが目標としていたのはクリーンなインターフェイスによって背後の実装の詳細を隠蔽すること
- いろんな対抗馬が出てきたが RDB は勝ち上がっていた
  - ビジネスデータの処理以外にも使えることがわかってきた
- 今でも多くの用途に RDB は使われている

### NoSQL の誕生

- NoSQL データベースの採用が広がった要因は以下の様なことがある
  - 極めて巨大なデータセットや優れた書き込みスループットを含むリレーショナルデータベースで容易に実現できる以上のスケーラビリティが求められる様になったこと
  - 商用のデータベース製品よりも、フリーでオープンなソフトウェアが好まれることが多くなったこと
  - リレーショナルモデルではうまくサポートされない特殊なクエリ操作
  - リレーショナルなスキーマ制約に対するフラストレーションと、もっと動的で表現力に富んだデータモデルに対する欲求

### オブジェクトとリレーションのミスマッチ

- RDB を使うと,プログラム内のオブジェクトと RDB からのデータに変換のレイヤーができてしまう、インピーダンスミスマッチがあった
- ドキュメントモデルの DB を使えば解決できるかもしれないが、スキーマがないことなどの問題もある

### 多対一と多対多の関係

- ID を保存するか文字列を保存するかは複製の問題
- ID をつかえば人間にとって意味のある文字列は 1 箇所のみに保存され、この情報を参照する全てで ID が使われることになる

- テキストを直接使う場合、人間にとって意味のある情報をそれが使われるすべてのレコードで複製しなくてはいけない
  - どこかに更新がされると全てに更新をしなくてはいけなくなる
- このような複製を排除する考え方が正規化の鍵となる考え方

- ドキュメントモデルには結合がサポートされていないので、アプリケーションが成長して新しいデータの概念などが増えたときに大変

  - 一対多の関係には向いているが、多対多には向いていない
  - アプリケーション内で結合処理などを適切に行う必要がある

- RDB であれば結合は簡単

### ドキュメントデータベースは歴史を繰り返すのか

- ドキュメントデータベースに似ている階層型モデル制約を解決するために、リレーショナルモデルとネットワークモデルが提唱されていた

### ネットワークモデル

- 改装モデルではすべてのレコードは必ず 1 つの親を持つが、ネットワークモデルではレコードは複数の親を持つこともできる
  - これによって多対多も表現できる
- しかし、ネットワークモデルを扱う場合、同じレコードに辿り着くためのパスは複数ある可能性がある

  - アプリケーションは様々な関係をすべて追従しないといけない

- 階層モデルとネットワークモデルでは求めるデータへのパスがわかっていないという状況は厄介だった

### リレーショナルモデル

- リレーショナルモデルではすべてのデータはオープンに配置されていた
- リレーションは単なるタプルでありそれだけ

  - 複雑にいれこんだ構造もなくアクセスパスをたどる必要もない

- リレーショナルデータベースでは最適化の責任が開発者ではなくクエリオプティマイザであったことが大きい

### ドキュメントデータベースとの比較

- 多対一や多対多の関係の表現と言う点ではリレーショナルデータベースとドキュメントデータベースに基本的な違いはない
- どちらの場合でも、関連性のあるアイテムはユニークな識別子で参照される
  - リレーショナルモデルでは外部キー
  - ドキュメントモデルではドキュメント参照と呼ばれる

## 今日のリレーショナルデータベースとドキュメントデータベース

### アプリケーションのコードをシンプルにしてくれるデータモデルは？

- アプリケーションのデータがドキュメントの様な構造をしているのであればドキュメントモデルが良い
  - 一対多の関係からなるツリー構造を持ち、通常はそのツリー全体が一度にロードされる
- リレーショナルな手法である細分化はスキーマが込み入ったものになりアプリケーションのコードが不必要に複雑になることがある

- ドキュメントモデルはネストされたアイテムへは直接参照しないといけないので、ネストが深いと少し厄介
- アプリケーションが多対多をサポートする必要があるのであればドキュメントモデルの魅力が薄れる
- 非正規化によって結合の必要性を下げることができるが、データの整合性を保つためのコードが必要になる
- 結合はアプリケーション側でエミュレートできるが、アプリケーションコードを複雑にする
- パフォーマンスも悪い
- データ間の関係性が強い場合、ドキュメントモデルは扱いにくく、リレーショナルモデルは許容範囲であり、グラフモデルが最も自然

### ドキュメントモデルにおけるスキーマの柔軟性

- ドキュメントモデルはスキーマレスなのではなく、スキーマオンリーど
- リレーショナルモデルはスキーマオンライと
- スキーマオンリーどは動的型付けみたいな感じで、スキーマオンライとは静的型付けみたいな位置付け
- アプリケーションのデータ構造を変更するとき、ドキュメントモデルでは、新しいフィールドを作って以降のドキュメントを描き始め、古いドキュメントを選んだ場合の処理をアプリケーション側で持たせること

- リレーショナルデータベースではマイグレーションすることが多い

  - ただし、一切マイグレーションを行なわず,変換ロジックをアプリケーション側で持たせてもいい気はしている
  - ただそれだと、リレーショナルデータベースの静的さを生かしきれないってことかな？

- スキーマオンリードのアプローチはアイテムの構造が統一されていない(データがヘテロジニアス)場合にメリットがある

  - 数多くの種類のオブジェクトがあり、それぞれの種類のオブジェクトを個別のテーブルに保存することが現実的ではない場合
  - データの構造が外部のシステムによって決定され、その外部システムはアプリケーション側からは制御できず、いつ変更されるかもわからないような場合

- 上記の様な状況ではスキーマの存在はメリットよりもデメリットのほうが大きいかもしれない
- しかしすべてのレコードが同じ構造を持つことが期待される場合にはドキュメント化と構造の強制においてスキーマは有益な仕組みになる

### クエリーのためのデータローカリティ

- ローカリティのメリットが生じるのは一度にドキュメントの大部分が必要になる場合に限られる
- 通常ドキュメントの一部にしかアクセスしない場合でも、データベースはドキュメント全体をロードしないといけず、無駄が多くなる場合がある
- ドキュメントを更新する場合には通常ドキュメント全体を書き直さなければならず、変更の処理をその場所でデータを上書きして済まされるのはエンコード後のドキュメントのサイズが変わらない場合だけ

  - こんなことがありうるのか？

- そのためドキュメントは小さく保ち、ドキュメントのサイズを大きくするような書き込みは避けることが望ましい

  - でもドキュメントが小さいと、アプリケーションで使うデータ構造が一つのドキュメントで住むことがなくなるのでは？
  - なんかジレンマが生じている気がする

- このようなパフォーマンスの制約があるため、ドキュメントデータベースが有効になる状況はかなり減っている
- ローカリティを高められるのはドキュメントデータベースのみではない

### ドキュメントおよびリレーショナルデータベースの融合

- RDS が JSON や XML をサポートしてきている
- RDS とドキュメントデータベースは時間の経過とともに類似性が高まっている様に見える

  - これは良いこと

- データベースがドキュメント的なデータを扱うことができ、そのデータに対してリレーショナルなクエリを実行できるなら、アプリケーションは必要に応じて最も適した機能の組み合わせを利用できる
- リレーショナルとドキュメントのハイブリッドモデルはデータベイスにとって将来に向けた良い方針

## データのためのクエリ言語

- 命令的と宣言的の話
- SQL は宣言的で、クエリを書く人の指定が少ないので、エンジン側での自動的な最適化の余地が大きい
- また、宣言的の方が並列化しやすく、現代のコンピュータに適している

### Web 上での宣言的クエリ

- CSS と DOM 操作の話
- CSS で宣言的にできるならそっちの方が良いよね

### MapReduce でのクエリ

- 大量のデータを多くのマシンに跨ってまとめて処理するためのプログラミングモデル
- MonogoDB や CouchDB では大量のドキュメントに対して読み取りのみのクエリを実行する仕組みとして MapReduce が利用できる
- MapReduce は宣言的と命令的の中間
- 関数型の map,reduce を基盤としている
- 表現力が高まったり、分散システムで使いやすい感じ？
- ただ、これらの特徴は SQL でもちゃんと用意されている感じらしい
- 詳しくは 10 章らしいのでそこをしっかり読みたい
- 今の所どう言うものかはわかるが意義がわからん

## グラフ型のデータモデル

- 多対多の関係が一般的なデータモデルでは、データをグラフとしてモデル化するのが自然
  - ソーシャルグラフ
  - Web グラフ
  - 道路や鉄道のネットワーク
- グラフが表現できるのは均一なデータだけではなく、異なる種類のオブジェクトを単一のデータストアに保存する方法としてもグラフは協力

### プロパティグラフ

- プロパティグラフモデルではそれぞれの頂点は以下の内容から構成される

  - ユニークな識別子
  - 外向きの辺の集合
  - 内向きの辺の集合
  - プロパティのコレクション

- それぞれの辺は以下の内容から構成される

  - ユニークな識別子
  - 始点
  - 終点
  - 2 つの頂点間の関係の種類を示すラベル
  - プロパティのコレクション

- グラフによるデータモデリングは非常に柔軟
  - グラフの関係を追加/削除すれば良い
- リレーショナルなスキーマでは表現しにくいこともできる
- グラフは進化性にも優れており、アプリケーションに機能を追加する際にグラフを拡張してアプリケーションデータ構造の変化を受け入れるのは容易

### Cypher クエリ言語

- プロパティグラフ用の宣言的なクエリ言語でグラフデータベースの Neo4j 用に作成された
- めっちゃ宣言的にグラフを辿れる感じで、あまりデータの構造を気にしていなくても目的のデータが取れる感じがしている
- 探し出すロジックをアプリケーションではなく、DB のクエリに持っていけるのは相当ありがたい

### SQL でのグラフクエリ

- グラフのデータをリレーショナルな構造に格納してそのクエリを SQL で書くことは多少の困難が伴う
- リレーショナルデータベースでは通常事前にクエリに必要な結合がわかっているが、グラフクエリでは求める頂点を見つけるまでにたどらなければいけない辺の数は変動するかもしれない

  - つまり結合の数は事前に決まらない

- 一応 SQL でも WITH RECURSIVE 式を使って同じ様なことはできるがなかなか厄介
- 例では Cypher であれば 4 行、SQL だと 29 行
- ユースケースが異なれば適切な設計のデータモデルも異なる

### トリプルストアと SPARQL

- トリプルストアはプロパティグラフモデルとほとんど同じだが、価値のあるさまざまなツールや言語がある
- トリプルストアはすべての情報は非常にシンプルな 3 つの部分からなる言明(主語、述語、目的語)で保存される

  - (Jim,likes, bananas)

- トリプルの主語はグラフにおける頂点に相当する
- 目的語は以下の 2 つのいずれか

  - 文字列や数値といったプリミティブなデータ型の値で、この場合、トリプルの述語や目的語は主語の頂点のプロパティにおけるキーと値に相当する
    - (lucy,age,33)は{"age":33}というプロパティを持つ lucy と言う頂点
  - グラフ中の別の頂点で、この場合述語はグラフの辺であり、主語は始点、目的語は終点を表す
    - (lucy,marriedTo,alain)の場合、lucy と alain はどちらも頂点であり、述語の marriedTo はそれらをつなぐ辺のラベル

- こんなデータ構造を設計および利用できるのか？実際使われてるの？だいぶ高次元な考え方な気がする

### セマンティック Web

### SPARQL

### グラフデータベースのネットワークモデルとの比較

- ネットワークモデルでは、データベースはどのレコード型がどのレコード型とネストできるかを決めるスキーマを持つ

  - グラフデータベースにはそういった制約はない
  - どの頂点も他の頂点への辺をいくつでも持つことができる
  - そのため、アプリケーション要求の変化に対応させる際に大きな柔軟性がえられる

- ネットワークモデルでは特定のレコードに到達するにはそのレコードに至るパスをたどるしかなかったが、グラフデータモデルでは任意の頂点をユニークな ID で直接参照することも、あるいはインデックスを使って特定の値を持つ頂点を見つけ出すこともできる
- ネットワークモデルではレコードの子は順序付けられた集合なので、データベースはその順序を保たなければいけず、データベースに新いレコードを挿入するアプリケーションはそれらの集合内での新しいレコードの位置に気をつけなければいけなかった
  - グラフデータベースでは頂点と辺は順序づけられていない
- ネットワークモデルではすべてのクエリは命令的であり、書くことは難しく、スキーマを変更すればすぐに動作しなくなっていたが、グラフデータベースでは宣言的にデータをとってこれる

### 礎となったもの:Datalog

- そいうものもあるのね

## まとめ
