# はじめに

- この 10 年の間にデータベースや分散システム、そしてそレラの上でアプリケーションを構築する手法において数多くの発展があったらしい

  - 大規模でも効率的に処理を行える新しいツールを創造されてきた
  - 仮説の検証を低コストで行い、開発のサイクルを短く、データモデルを柔軟に保つことでマーケットに素早く対応しないといけない
  - フリーソフトが勝ち上がってきている

    - 確かにクラウドベンダーも OSS をラップしたものが多い

  - マルチコアプロセッサが標準的になってきたので並列処理が進んできている
  - IaaS などのおかげで分散システムが簡単に作成できるようになっている
  - 高可用性が求められている
    - ここら辺がサービスをやっていないといまいちわからん。。。

- この本では、CPU のサイクルがボトルネックになる演算指向のアプリケーションに対して、データの量や複雑さ、変化の速度が主な課題であるアプリケーションのことをデータ指向と呼ぶ
- 優れたアプリケーションを構築しようとするならさまざまな技術とそのトレードオフを正確に理解しておく必要がある
  - そのためにバズワードの先へと深く掘り下げなければならない
- 本書を読み終えればある目的のためにはどう言った種類の技術を用いるのが適切なのかを的確に判断し、優れたアプリケーションのアーキテクチャの基盤を構築するためのツール群の組み合わせを理解できるようになる

# 1 章 信頼性／スケーラビリティ／メンテナンス性に優れたアプリケーション

- 現代のアプリケーションのボトルネックは演算思考ではなく、データ指向
- データ量や複雑さデータの変化する速度のほうが大きな問題
- 多くのアプリケーションでは以下のような機能が必要になる
  - データベース
  - キャッシュ
  - 検索インデックス
  - ストリーム処理
  - バッチ処理

## データシステムに関する考察

- ツールの分類境界線が曖昧になってきている
- 単一のツールで全てを処理するのではなく、処理を複数のタスクに分割してそれぞれに適したツールで効率よく処理できるようにすることが大事
  - それらのツール群をアプリケーションのコードで結びつける
- 本書ではソフトウェアシステムにおける重要な 3 つの課題に焦点を当てる
  - 信頼性
  - スケーラビリティ
    - これはアクセスやデータの量、複雑性に対してらしい
  - メンテナンス性

## 信頼性

- アプリケーションがユーザーの期待通りに動くこと
- ユーザーが間違いを犯したり、予想外の使い方をしても耐えられること
- 対応が必要なケースにおいて、予想される負荷とデータ量の下で十分に優れたパフォーマンスを発揮できること
- 認可されてないアクセスや攻撃を回避できること
- つまり、何か問題が生じたとしても正しく動作し続けることと言える
- 問題を起こしうるのはフォールト、耐障害性があるのがレジリエント
- 全てのフォールトについて議論することはできないので、ある種のフォールトについて議論すること
- フォールトは障害ではない
  - フォールトは仕様を満たしていないコンポーネント
  - 障害はシステムが全体として必要なサービスのユーザーへの提供を止めてしまった場合
    - 日本語変じゃね？
  - 障害の可能性を 0 にするのは無理
    - フォールトが障害を引き起こさないような耐障害性の仕組みを設計するのにとどまる
- セキュリティなどはフォールト回復よりも回避が重要

### ハードウェアの障害

- ハードウェアトラブルは常にある
- ハードディスクの平均故障時間は 10 年から 50 年なので 10000 台あれば 1 日に一台壊れることを想定するべき
- ハードウェアの冗長性が大事
- 前と違って、今はクラウドでバンバンリソースを使うので、フォールトの発生率も高くなった

### ソフトウェアのエラー

- ハードウェア同志は相関性を持った障害はしにくいがソフトウェアははるかに相関したフォールトになりやすい
  - ソフトウェアバグ
    - 閏年の際に多くのアプリケーションがハングした
  - プロセスの暴走
    - 他のプロセスによって、プロセスが動かなくなる
  - システムが依存しているサービスの問題
  - カスケード障害
    - 1 つのコンポーネント中の小さなフォールトが他のコンポーネントのフォールトを引き起こし、そしてそのフォールトがさらなるフォールトを引き起こすようなもの
- これらは長い間潜伏することもある
- 手っ取り早い解決策はない
  - 役に立つのはちょっとした積み重ね
  - システムが何かを保証することが期待されるなら、システム地震が動作中にチェックをして異常があればアラートを出させる

### ヒューマンエラー

- サービス障害の最も多いのはオペレーターによる設定エラーという結果もある
- 人間が信頼できないことを踏まえた上で、最も優れたシステムは複数のアプローチを組み合わせるもの
  - エラーの可能性が最小限になるようにシステムを設計する
    - ただしあまりにも最小限だと、それを迂回するようになってしまうので注意
  - 人々が最もミスを犯しやすい部分を間違いがあれば障害に繋がりやすいところから分離する
    - サンドボックスと本番は分けよう
  - ユニットテストから手動テストまで全てのレベルで徹底的にテストを行う
  - ヒューマンエラーから迅速かつ容易にリカバリできるようにして障害が発生した場合のインパクトを最小化できるようにしよう
    - ロールバックできれば怖くない
  - パフォーマンスメトリクスやエラー発生など詳細で明確なモニタリングをしよう
    - 計測するの大事！

### 信頼性の重要度

- アプリケーションがクリティカルでなくとも信頼性は重要

  - ユーザーに対する責任は存在する

- 信頼性を落として何かをあげるのであれば信頼性を落としている意識を持っているべき

## スケーラビリティ

### 負荷の表現

- システムごとの不可のパラメータの選択が重要
  - 見る切り口が重要だよね

### パフォーマンスの表現

- システムの負荷がわかれば負荷が増加した時に起こることを調査できるようになる
- そのために 2 つの調べ方がある

  - 不可のパラメータを増やしながらシステムのリソース(CPU,メモリ,ネットワーの帯域など)は一定に保つとシステムのパフォーマンスにどのような影響が出るのか？
  - 不可のパラーメータを増やした時にパフォーマンスを一定に保つにはリソースをどれほど増やさないといけないのか？

- バッチ処理システムに必要なのはスループット
  - 1 秒あたりに処理できるデータ数
- オンラインシステムの場合はレスポンスタイム
  - クライアントがリクエストしてからレスポンスを受信するまでの時間
  - レスポンスタイムは単一の数値ではなく、分布として考えること
  - 平均を取ることが多いが、あまりいいケースでないこともある
  - パーセンタイルを使うと良い
  - ユーザーの典型的な待ち時間を知りたいなら中央値(p50)が良い
  - 外れ値がどれほど悪いか知るには大きなパーセンタいるを見るべき
    - p95,p99,p999,テイルレイテンシと呼ばれるもの
  - 大きなパーセンタいるのレスポンス値はその大部分がキューイングの遅延によるものであることがよくある
  - サーバが同時に並列処理できる数は少ないので低速なリクエストが少数あるだけでそれ以降のリクエストの処理が待たされることになる
    - この現象はヘッドオブラインブロッキングと呼ぶらしい(HOL ブロッキング)
  - ほとんどのサービスが高速でも、ユーザーが一つのリクエストに必要などれかのサービスが遅かったら、ユーザーからしたら一番遅いサービスのレスポンスに依存する
    - なので、クライアント側での測定が重要

### 負荷への対処アプローチ

- 複数のマシンに負荷を分散させることはシェアードナッシングアーキテクチャとも呼ばれるらしい
  - 依存せずに動くやつを複数動かすから？
- ステートフルなデータシステムを分散させるのはむずい
- 前までは単一ノードのスペックを上げてきたが、分散させる技術が発展してきた

## メンテナンス性

- レガシーシステムを生み出さないために以下をしっかりやること
  - 運用性
  - 単純性
  - 進化性

### 運用性: 運用担当者への配慮

- 運用チームは以下のことに責任を持つがその責任はこれだけに限定されるわけではない

  - システムの健全性をモニタリングし、その状態が悪くなれば素早くサービスを回復させる
  - システムの障害やパフォーマンスの低下と言った問題の原因を発見する
  - ソフトウェアやプラットフォームを最新の状態に保つ(セキュリティパッチなど)
  - さまざまなシステムの相互作用に注目し、問題がありそうな変更があれば、それがダメージを生じさせる前に回避する
  - 将来の問題を予想し、それらを発生前に解決する
  - デプロイメント、、設定管理などのために優れたプラクティスやツールを確定する
  - プラットフォーム間でのアプリケーションの移動など、複雑なメンテナンスタスクを実行する
  - 設定変更の際にシステムのセキュリティのメンテナンスを行う
  - 運用で予想外のことが怒らないようにプロセスを定義し、プロダクション環境の安定を保つ
  - 個人の出入りがあってもシステムに関する組織の知識が保たれるようにする

- 優れた運用性は定型のタスクを容易にし、運用チームが価値の大きな活動に集中して力をつげるようにしてくれる
  - ランタイムの挙動やシステム内部の可視化の機能を優れたモニタリングと共に提供する
  - 自動化と標準的なツールとの統合を十分にサポートする
  - 個々のマシンにた対する依存性を持たせない
  - 優れたドキュメンテーションと理解しやすい運用モデルを提供する
  - デフォルトの挙動を優れたものにする.ただし、管理者が上書きできるように
  - 適切な場合には自己回復できるようにする。ただし必要な場合は、管理者が手動でシステムの状態を制御できるようにする
  - 挙動を予想しやすいようにして、予想外のことができる限り起きないようにする

### 単純さ:複雑さの管理

- システムを単純にするということは必ずしも機能を減らすことではない
- 単純にするということは、偶発的な複雑さを取り除くこと

  - ソフトウェアが解決しようとしている問題とは違い、実装からのみ生じている複雑さのこと

- 偶発さを取り除くための最も優れた手段の 1 つが抽象化
- ただし、優れた抽象化を見出すのは極めて難しい

### 進化性:変更への配慮

- データシステムの修正、そして変化する要求への対応が容易になるかは、その単純性と抽象化に密接に関係する

## まとめ
