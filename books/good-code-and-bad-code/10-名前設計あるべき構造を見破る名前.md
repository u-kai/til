# 10: 名前設計

## 悪魔を呼び寄せる名前

-   商品クラスと言ったように汎用的な名前をつけてしまうと責務が密集してしまい，蜜結合してしまう可能性が高くなる

## 関心の分離

-   密結合を解消して疎結合高凝縮にするためにはユースケースや目的，役割などの関心事別に分離することが大事

## 大雑把で意味が不明な名前

-   名前が大きすぎて目的不明になる
-   目的不明オブジェクトはあっという間に巨大化する
-   関心ごとの分離にはビジネス目的を名前として表現することがポイント

## 名前を設計するー目的駆動名前設計

-   筆者はクラスやメソッドに名付けることを命名ではなく，名前設計と呼んでいる
-   目的駆動名前設計は目的ベースに名前を設計する
-   重要なポイント
    -   可能な限り具体的で意味範囲が狭い，特化した名前を選ぶ
    -   存在ベースではなく，目的ベースで名前を考える
    -   どんな関心ごとがあるかを分析する
    -   声に出して話してみる
    -   利用規約を読んでみる
    -   違う名前に置き換えられないかを検討する
    -   疎結合高凝縮担っているか検討する

## 可能な限り具体的で意味範囲が狭い，特化した名前を選ぶ

-   特定の目的の達成に特化した極めて意味範囲の狭い名前をクラスに付与する
-   ビジネス目的(会社の事業的にどういう目的を達成したいのか)に特化することで以下の効果が生まれ
    -   名前とは無関係なロジックを排除しやすくなる
    -   クラスが小さくなる
    -   関係するクラスの個数が少なくなる.結合度が低減する
    -   関係クラス個数が少ないので，仕様変更時に考慮を要する影響範囲が小さく済む
    -   目的に特化した名前なので，どこを変更すれば良いかすぐ探し出せる
    -   開発生産性が向上する

## 存在ベースではなく，目的ベースで名前を考える

-   人やユーザーと言った人物がただ存在しているだけのような存在ベースの名前だと，意味が多重になりがち(ユーザーは個人以外にも法人向けなどもある)でロジックが混乱する可能性がある

| 存在ベース | 目的ベース                                         |
| ---------- | -------------------------------------------------- |
| 住所       | 配送元，配送先，勤務先，本籍地                     |
| 金額       | 請求金額，消費税，延滞保障料，キャンペーン割引料金 |
| ユーザー   | アカウント，個人プロフィール，職務経歴             |
| ユーザー名 | アカウント名，表示名，本名，法人名                 |
| 商品       | 入庫品，予約品，注文品，配送品                     |

## どんなビジネス目的があるか分析する

-   ビジネス目的に特化した命名をするには，どんなビジネス目的があるか把握する必要がある
-   そのためにソフトウェアが対象とする目的や事柄を分析する必要がある
-   登場人物や事柄を列挙したり，関係性を整理したり分析するのが大事
-   チームで集まってホワイトボードや模造紙に書いたりすることや，関係し合うものをグルーピングするなど考えの整理がより捗る

## 声に出して話してみる

-   どんな目的を達成したいのか，どう使われるのか，何と関係するのか，その理由など，背景と糸の認識が整理され，チームと一致していることが重要
-   目的や意図の認識がお互いに違っていると，なまえが十分にブラッシュアップされない
-   この課題の解決にはやはり声に出して話してみることが重要
-   ビジネス側の人と話すと良いフィードバックが得られる
-   ラバーダッキングと似ている
-   声に出して話す分析活動は DDD のユビキタス言語を由来としている
    -   ユビキタス言語はチーム全体で意図を共有するための言葉
-   チームでユビキタス言語を作る時，会話し続け，継続的にブラッシュアップすることの重要さを DDD では説いている

## 利用規約を読んでみる

-   利用規約には厳密ななまえがよく定義されているので，それをそのままクラスやメソッドとして切り出すことができる
-   この命名をすればビジネスルールとクラスが一致しているおかげで正確に素早く変更できる

## 違う名前に置き換えられないか検討する

-   違う名前に置き換えてみて意味をもっと狭くできないか，違和感がないかなど検討すること
-   違う名前をさがすには類語辞典が役に立つ

## 疎結合高凝縮になっているか点検する

-   目的以外のロジックが混入しそうならば，名前を見直すべき

## 設計時の注意すべきリスク

-   名前に無頓着になるな

    -   チーム開発においては命名は重要であり，名前とロジックが対応する前提であること，なまえがプログラム構造を大きく左右することをチーム内で約束する

-   仕様変更時の意味範囲の変化に警戒

    -   異なる意味が混入しそうな場合はなまえが意味するところを見直したり，名前を変えたり，クラスを別々に分けるなどするのが肝心

-   会話には登場するのにコード上に登場しない名前に注意
    -   会話に登場する重要な概念がソースコード上で名前をつけられず，雑多なロジックの中に埋没していることが多い
    -   これだとそのシステムに詳しい人に聞かないと理解が難しくなる
    -   このような名無しのロジックはソースコードのあちこちに無秩序に書き殴られる傾向がある
        -   なぜならなまえがついていないと，メソッドとしてもクラスとしても設計されていないから
        -   そして既存のソースコードないに単に仕様書通りに動作するようにロジックが下手書きされることになる
        -   このようになってしまうと，どこからどこまでが関係するロジックなのか探し回らなくてはいけなくなる
    -   上記の苦しみから逃れるためには，会話に登場する名前にもっと神経質になる必要がある

## 形容詞で区別が必要な時はクラス化のチャンス

-   違いの見分けが難しいコードを口頭でひたすら形容詞をつけて同僚に説明する状況がシステム開発では頻繁に生じる
-   チームメンバーがしきりに，もともとの〜，補正された〜などと形容詞を使って違いを説明する，という状況が実際に頻繁にある
-   こうした事態を防止するには曖昧な命名をせず，意味の違いがわかる命名が大事
-   形容詞をつけてまで違いを表したい場合はそれぞれをクラスとして設計することで関係性を構造かできたり型安全にすることができる

## 意図がわからない名前

-   名前の意図がわからないと，コードの翻訳作業や仕様変更時に読み取るコストが高くなってしまう
-   以下から名前の意図がわかりにくくなってしまう命名方法を記述する

### 技術駆動命名

-   命名の仕方がプログラミング用語やコンピューター用語のものになってしまうこと
    -   memory ,cache,thread,register,int,str,flag

## ロジック構造をなぞった名前

-   本の例
    -   ヒットポイントが 0 より大きくて生存していること，行動可能であること，魔法利欲がぞんざいしていることを以下の名前にしている
        -   isMemberHpMoreThanZeroAndIsMemberCanActAndIsMemberMpMoreThanMagicCostMp
-   上記はロジック構造そのままで意図や目的ではない
-   canChant(呪文を唱えることができるか)に変更

## 驚き最小の原則

-   本の例では itemCount のなかで count を返しつつ中でギフトポイントを 100 追加しており，驚きがある
-   ロジックの意図と名前は一致するべき

## 構造を大きく歪ませてしまう名前

### データクラスに陥る名前

-   ~Info や~Data と命名されたクラスはデータだけ持たせるクラス，ロジックを実装してはいけないと読み手に印象付けてしまい，低凝集に陥りやすい
-   ~Info,~Data など行ったデータのみを想起させる名前は避けるべき
    -   ProductInfo は Product へ改善すべき
    -   そしてオブジェクト指向に基づきインスタンス変数に強く関係するロジックを Product クラスにカプセル化する

### DTO(Data Transfer Object)

-   一部例外的にデータクラスを用いる場合がある
-   CQRS の参照系はデータベースから値を取得するだけの処理型で，もっぱら画面表示に用いられる
-   単に取得して表示するだけなので計算やデータの変更は伴わない
-   この場合データベースの値を格納して表示側に転送するだけのクラスとして設計する
-   これは DTO といって，データ転送用途に使われる設計パターン
-   参照型のみの用途であるため更新型で使ってはいけない
    -   更新型で用いると低凝集に陥る

### クラスが肥大化する名前

-   Manager,Contoller などの汎用的な名前をつけてしまうと，責務がわかりづらくなる
    -   その結果一つのクラスに数千行という神クラスが誕生してしまう
-   目的単位でクラスをわけること，具体的で意味範囲が小さく，目的がわかる命名をすること

### 状況によって意味や扱いが異なる名前

-   状況(コンテキスト)によって扱いやなまえが変わるものは多い
-   コンテキストが異なるものを一つのクラスに追いやるとクラスが巨大化，複雑化してしまう
-   コンテキストが違うものは疎結合になるように設計する
-   各コンテキストはそれぞれ異なるパッケージとして宣言する

    -   そして各パッケージに同じクラス名を用意して，それぞれのパッケージに登場する概念をクラス化する

-   コンテキストごとに境界をつけてコンテキストに応じたクラス設計をすること

### 連番命名

## なまえ的に居場所が不自然なメソッド

-   メソッドには居場所がふさわしくない，別のクラスに移動させるべきものがある
    -   居場所が不相応か名前でわかるものがある

### 動詞 + 目的後のメソッド名に注意

-   以下はゲーム内の敵を表現する Enemy クラス

```python
class Enemy():
    def __init__(self,is_appeared,magic_point,drop_item):
        self.is_appeared = is_appeared
        self.magic_point = magic_point
        self.drop_item = drop_item

    def escape(self):
        self.is_appeared = False

    def consume_magic_point(self,cost_magic_point):
        self.magic_point -= cost_magic_point
        if self.magic_point < 0 :
            self.magic_point = 0

    def add_item_to_party(self,items):
        if len(items) < 99 :
                items.add(self.drop_item)
                return true
        return false
```

-   Enemy クラスの関心ごとは敵であるはずが，add_item_to_party メソッドは主人公の所持品を取り扱っている
-   敵の関心ごととは明確に異なっている
-   アイテム取得は敵を倒した時だけに限らず，ダンジョンの宝箱や重要イベントで入手する場合がある

    -   その時にこの Enemy.add_item_to_party と同じロジックをダンジョンを取り扱うクラスに実装すると重複コードが生じる

-   様々なアプリケーションで関心ごとに無関係なメソッドが使いされることがよくある

    -   実装を急いでいる時や，既存のクラスだけでなんとか動くように無理に実装しよとした時など

-   そして関心ごとが異なるメソッドは add_item_to_party のように動詞＋目的語形式の名前になる傾向がある
-   動詞＋目的語の命名は無関係な責務のメソッドを追加しやすくなる

## 可能な限り動詞 1 語で済む名前にする

-   add_item_to_party をどうするのか考える
-   まずはパーティの所持品という概念をそのままクラスにする
-   そして所持品にアイテムを追加する add メソッドを定義する
-   このように動詞一語で表現された add メソッドを持つ PartyItems クラスができる
-   これによって敵のドロップアイテムを入手する場合でも宝箱からアイテムを入手する場合でも PartyItems クラスを利用すれば良くなる

-   疑問
    -   そもそもアイテムを一般化してクラスとしてもいいのか？
    -   敵を倒した時とダンジョンで取得するというのはコンテキストが違う気もする
    -   PartyItems クラスにそれらの概念を閉じ込めていいのかな？
    -   ただ，どこから取得するとかの文脈は PartyItems にはなく，Party の Item というコンテキストしかないから，そこまで悪くないのか
    -   Item クラスだけ，柔軟性を持つようにすべしな気がする
        -   むしろ Item interface の方がいい気もする

### 不適切な居場所の boolean メソッド

-   動詞＋目的語メソッドと同様に，boolean 型を返すメソッドも適切でないクラスに定義されることがよくある
-   関心ごとに注意を払わずにいると，boolean 型を返すタイプの判定メソッドは責務外のクラスに実装されがち
-   メソッドを定義するクラスが適切かどうかを簡単に見分ける方法
    -   クラス名 is 状態
    -   上のがしっくりくれば OK

## 名前の省略

### 意図がわからなくなる省略

### 基本的には名前は省略しないこと

-   IDE が賢いので省略しなくてもタイピングが増えることが少ない
-   SNS や VIP など，幅広く省略されていることが周知なものは OK
-   考察: go の考え

### そのほか省略をどう判断するか

-   省略する場合は意味が失われたり，問題が生じたりしないか確かめること
-   たとえばカウンタ変数 i や j についてはスコープが極めて小さく意味混乱のリスクが小さければ用いも良い「
-   プログラミング言語ごとの習慣もあるので，そう言った点も踏まえて命名方法をチームで決めておくことが良い
