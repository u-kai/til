# 9 データの所有権と分散トランザクション

## BASE

-   分散トランザクションでは ACID の代わりに BASE という性質をサポートとする
-   BA(Basically Available)
    -   基本的に利用可能
-   S(Soft state)

    -   柔軟な状態

-   E(Eventual consistency)
    -   結果整合性

## 結果整合性

-   分散アーキテクチャではパフォーマンス，スケーラビリティ，弾力性，耐障害性，可用性などのアーキテクチャ特性をよりよく運用するトレードオフとして，結果整合性に大きく依存する
-   3 つのパターンがある

## バックグランド同期パターン

-   別の外部サービスやプロセスを使用してデータソースを定期的にチェックしてデータソース間の同期を維持する
-   3 つのパターンの中で結果整合するのに一番時間がかかる
-   応答性は良い
-   このパターンの難題は，全てのデータを同期させるためのバックグランドプロセスがどのデータが変更されたか知る必要がある
-   バックグランドプロセスではトランザクションに関わる全てのテーブルとデータソースの知識を持っていないといけない
-   全てのデータソースを結合してしまうため，データとサービス間の境界づけられたコンテキストが全壊してしまうこと
-   つまり全てのテーブルはサービスとバックグランド同期プロセス間で事実上共有されることになる
-   アーキテクチャが密なので，変更が難しいことと，ビジネスロジックも重複する
    -   なぜなら各サービスのドメイン知識を持ってバックグランド処理が走る必要があるから
-   バックグランド同期による結果整合性パターンはマイクロサービスのような境界づけられたコンテキストを必要とする分散アーキテクチャには適していない
-   このパターンが有効なのは，相互に通信したり，データを共有したりしない，自己完結した異なるシステムなど

## リクエストベースのオーケストレーションパターン

-   このパターンではビジネス要求の間に分散トランザクション全体を処理するため，分散トランザクションを管理するオーケストレーターが必要となる
-   オーケストレータービジネスプロセスの知識，関係する参加者の知識，マルチキャストロジック，エラー処理，コントラクトの所有といった要求を処理するのに必要な全てを管理する責任がある

-   やり方の一つに，既存のサービスにオーケストレーターの責務を新たに加えるものがある
-   ただし，これでは責務が課題になったり，サービス間の密結合や，同期的な依存関係が生じやすいという欠点もある
-   そのため，このパターンでは，ビジネス要求用に専用オーケストレーションサービスを用意するのが一般的
-   このパターンは応答性よりも整合性を重視している
-   また複雑なエラー処理というトレードオフもある
-   もし，補償中にエラーが起きると人の手が必要になる

## イベントベースパターン

-   非同期のメッセージ処理は並列かつ分離されているので，通常データが結果的に整合するまでの時間は短い
-   またサービスごとに高度に分離されているため，結果整合性のイベントをトリガーしたサービスがデータの同期を待たずに情報を顧客に返すため，応答性は悪くない
-   標準的なトピックベースの pub/sub メッセージングを使用した実装では，イベントに応答するサービスを永続的サブスクライバーとして設定し，メッセージブローカーやメッセージを受信するサービスに障害が発生しても，メッセージが失われないようにする
-   永続的サブスクライバーとは永続的なキューと同様の概念であり，サブスクライバーはメッセージが公開された時点で利用可能である必要はなく，サブスクライバーは利用可能になった時点でメッセージを受け取れる
-   イベントベースパターンの利点は応答性，適時的なデータ整合性，サービスの分離
-   ただしエラー処理は複雑
-   永続的サブスクライバーに障害が発生した場合，最終的にそのサービスが利用可能になった段階でイベントは受信され処理されるが，サービスがイベントを処理している最中に失敗すると，事態は急速に悪化する
-   ほとんどのメッセージブローカーはメッセージの配信を一定回数試み，受信者が何度も失敗すると，メッセージをデッドレターキューに送る
-   デッドレターキューは自動化されたプロセスがメッセージを読み込んで問題の修復を試みるまでイベントが保存されるように設定が可能なメッセージの送信先
    -   プログラムで修復できない場合，メッセージは通常人に送られて手動で修復される
