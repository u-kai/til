# 8 再利用パターン

## コードレプリケーション

-   機能を必要としているサービスに同じコードをコピペする方法
-   境界づけられたコンテキストを守ることができるが，変更に弱い
-   一度書かれたらそれっきりのクラスだったり，不具合や機能変更のために変更される可能性が低いものに関しては適したアプローチ

## 共有ライブラリ

-   コンパイル時にバインドされるのが普通
-   一見シンプルでわかりやすいが，共有ライブラリの粒度やバージョニングなど，複雑な問題やトレードオフがある

## 依存関係の管理と変更の制御

-   共有ライブラリのトレードオフを形成する 2 つの相反する力は，依存関係の管理と変更の制御
-   共有ライブラリの粒度が大きいと依存関係の管理は楽であるが，変更した際，共有ライブラリを利用している全てのサービスを再デプロイする必要が出てくるため，変更時のコストが高い
-   逆に粒度を小さくすると，再デプロイの範囲は狭まるが，依存関係管理の面では混乱を招く
-   基本的にこのトレードオフは依存関係管理よりも変更制御を優先すべし
    -   細かい共有ライブラリを作成する方が良いということ

## バージョニング戦略

-   共有ライブラリでは常にバージョニングを使用すべし
-   バージョニングを使うことで変更が必要になったサービスにのみ新しいバージョンのライブラリを個別に共有することができるようになる
-   こうすることで，アジリティの確保ができる
-   しかしバージョニングは結構複雑
-   まず最初にバージョン変更の伝達が複雑になる

    -   高度に分散されていると，共有ライブラリのバージョン変更を伝えるのが困難な場合がある
    -   開発者に知らせる必要がある
    -   疑問
        -   ここら辺ってものリポで解決しそうだけど，そもそもものリポであるライブラリだけバージョニングするみたいなことってできるんかな？
        -   それともコード自体は新しいけど，デプロイされているものは古いみたいな感じ？
        -   上のやつだとコードとデプロイされているものが違うので GitOps の思想とは離れる気もする

-   もう一つの複雑な問題は，共有ライブラリの古いバージョンの非推奨化，すなわち，ある日付移行にサポートされなくなるバージョンを削除すること
-   非推奨に対する戦略は共有ライブラリごとに適用するカスタムなものから，全ての共有ライブラリに一律で適用する包括的なものまで様々ある
-   ライブラリはそれぞれ異なる速度で変更されるため，各共有ライブラリにカスタム非推奨戦略を割り当てるのが通常好ましい
-   しかしそうなると，共有ライブラリごとに非推奨情報を誰かが管理し，追従しないといけないというトレードオフがある
-   一方包括的にする場合，管理は楽になるが，変更頻度が高いものがあると，そのライブラリを利用しているシステムは頻繁にデプロイしなくてはいけなくなる
-   バージョニングに関するアドバイスとして，サービスが必要とするライブラリのバージョンを指定する際に LATEST バージョンを使用するのは避けるべし

## 共有サービス

-   共有サービスの特徴はコードを継承ではなく，コンポジションによって共有する点にある

## 変更リスク

-   共有サービスはコンパイルによるリンクではなく，ランタイムの変更みたいなもの
-   共有サービスの単純な変更がシステム全体を事実上ダウンしてしまうことも起こりうる
-   共有ライブラリではバージョニングはコンパイル時のバインディングにて行われ，共有ライブラリの変更に伴うリスクを大幅に軽減する
-   共有サービスでは API エンドポイントのバージョニングが考えられる
-   ただし，この場合，いかなる変更理由によるバージョニングの変更であれ，正しいエンドポイントを刺すように変更する必要がある
-   また，もう一つの問題に，API エンドポイントの変更は，REST でのアクセスが前提となっている
    -   他のプロトコルなどによる複数プロトコルによるアクセスがある場合はずっと複雑になる
-   共有サービスは実行時に変更が適用されるものなので，共有ライブラリよりもはるかに多くのリスクを伴う

## パフォーマンス

-   ネットワーク越しのアクセスになるので，共有ライブラリよりもパフォーマンスは落ちる

## スケーラビリティ

-   共有サービスを利用するサービスに合わせてスケールする必要がある

## 耐障害性

-   耐障害性も，共有ライブラリより悪いのは明らか

## 使い所

-   共有サービスは複数の言語やプラットフォームを使用する環境や共有機能が頻繁に変更される場合に適したテクニック
-   共有サービスの変更は共有ライブラリ方式よりも全体的にアジャイルに行える傾向があるが，ランタイムの副作用や，共有機能を必要とするサービスへのリスクがある

## サイドカーとサービスメッシュ

-   全てのサービスがサイドカーコンポーネントを含んでいるとみなせるなら，サービスメッシュを形成できる
-   メッシュを持つことで，アーキテクトや DevOps はダッシュボードを作成したりスケールなどの運用特性を制御したりその他多くの機能を手に入れられる
-   統制を担うエンタープライズアーキテクトのグループなどはサイドカーパターンを用いることでたくさんの言語やプラットフォームを使用する環境を合理的に制限できる
-   マイクロサービスは共通のプラットフォームでなく，統合によって成り立っている
-   サービスメッシュによる一貫性を原動力にして複数の異なるプラットフォーム間でインフラやその他の横断的な関心ごとをサポートすることが多い
-   サイドカーパターンは運用機能をドメインから切り離すだけでなく，特定の種類の統合に対応する直行再利用パターンでもある
-   これにより，ドメイン横断や運用上の横断を可能に s，アーキテクチャの層を分離できる

## 使い所

-   ある種の横断的な関心事を分散アーキテクチャの中で扱うための巧な方法であり，運用上の結合以外にも活用できる

## 再利用について

-   変わりにくいものに関しては再利用をすることでメリットがある
    -   例として PC や OS，組織のプラットフォームが挙げられていた
