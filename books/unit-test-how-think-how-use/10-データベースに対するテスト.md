# 10 データベースに対するテスト

- 管理下にあるプロセス外依存でよくあるのが，テスト対象のアプリケーションだけがアクセスするデータベース
- 統合テストを行う際にデータベースをテストダブルに置き換えずに直接利用することで，非常に強力な退行に対する保護を得られるようになる

## データベースをテストするのに必要な事前準備

- 統合テストで依存をそのまま使おうとすると，事前準備が必要になる
  - スキーマを Git などのソースコード管理システムを用いて管理する
  - 開発者ごとに個別のデータベースインタスタンスを用意する
  - データベースに対する変更を本番環境に反映する際は移行ベースを用いる
- テストを行いやすくするためのプラクティスがコードベースの改善に繋がるのと同じように，統合テストに関するプラクティスはデータベース全体の健全性を改善することにもなる
  - その為，利がある

## ソースコード管理システムを用いたスキーマの管理

- 変更履歴を辿れたりするのが利点で，スキーマに対してソースコード管理システムで管理されない変更が決して行われないように徹底しなければいけない

## スキーマに参照データを含めること

- 他のデータベースから参照されたり，参照されるためにデプロイの順序依存が生まれるようなデーた
- 対象のデータが参照データかそれとも通常のデータなのかを見極めるテクニックに，そのデータを変更してもアプリケーションが適切に機能するかどうかで判断する
- もしそのデータを変更してもアプリケーションが問題なく機能するのであればそのデータは通常のデータと判断でき，その逆に，変更すると機能しなくなるのであればそのデータは参照データと判断できる

## 開発者ごとに個別のデータベースインスタンスを用意する

- 複数人でデータベースを共有すると以下のような問題が起きる
  - 複数人の開発者が同時にテストを実施すると，お互いのテストに影響が出てしまう
  - 後方互換のない変更を加えた時に他の開発者の作業を止めてしまう
- その為各開発者に対して好きなように扱えるデータベースインスタンスを提供するようにする

  - 理想なのは各開発者が所有するマシーンにデータベースインスタンスを持たせること

- このようにすることでテストに必要な時間を最小限に抑えられるようになる

## データベースに対する変更の本番環境への反映：状態ベース Vs 移行ベース

- 移行ベースの方は変更を本番環境に反映したり，データベースを保守したりすることが開発の初期段階だと難しいいが，時間の経過とともに状態ベースよりも負担が少なくなっていく

### 状態ベースによる本番環境への変更の反映

- 開発用のモデルデータベースを用意し，そのモデルデータベースに対して変更を行うというもの
- そして本番環境に新しくなったアプリケーションをデプロイするときにモデルデータベースに対して行われた変更を本番環境のデータベースに反映する
- この時，開発で使用するモデルデータベースと本番環境のデータベースとを比較するツールを用いて，モデルデータベースに対して行われた変更を本番環境のデータベースに反映する SQL スクリプトを作成する
- 物理的なモデルデータベースを真の情報源として見るのではなくその更新に使われる SQL スクリプトを真の情報源として扱い，この SQL スクリプトをソースコード管理システムで管理する
- このように状態ベースを用いてデータベースへの変更を本番環境に反映すれば面倒なことを全て比較ツールに任せられるようになる
- つまり，モデルデータベースに対して行った変更を反映するのに必要なことは全て比較ツールが行ってくれる

### 移行ベースによる本番環境への変更の反映

- 移行ベースで重視されることはデータベースの構造を現時点のものから開発によって新しくなったものにどのように移行するかということになる
- 移行ベースを用いる場合，開発者自身が本番環境に変更を反映する SQL スクリプトを作成する
- このように移行ベースを用いた場合，データベースがどのような状態に変わったのかではなく，データベースに対して何を行ったのかがソースコード管理システムで管理されることになる

### 状態ベースよりも移行ベースの方が優れている点

- データベースに対する変更を本番環境に反映する方法に関して，状態ベースと移行ベースの違いはそれらの名前が示すように状態を意識するのか，それともいこを意識するのかというところからきている
- 状態ベースを用いると，データベースがどのような状態なるのかが明確になる

  - ただし，どのように移行するのかについては比較ツールによって暗黙的に決められることになる

- 移行ベースを用いるとどのように移行するのかが明確になる一方，どのような状態になるかは明確ではない

  - その為，データベースの状態を直接的に知ることはできず，移行によってどのような状態なるのかを組み立てていかなくてはならない

- データベースの状態が明らかであればマージ強豪への対処が行いやすくなる
- 一方，移行の方法が明確であればデータモーションに取り組みやすくなる
- ほとんどのプロジェクトにおいて，データモーションの取り組みの方がマージ競合の対処よりも遥かに重要
- なぜならアプリケーションが本番環境にリリースされてしまうと，本番環境のデータベースは簡単には破棄できないデータを常に持つことになるから
- 適切な変換を行うにはドメイン知識が必要でテーブル比較ツールでは難しい
- アプリケーションがまだ本番環境にリリースされていないのであれば状態ベースは十分に利用可能なテクニック
- なぜなら開発時に扱っているデータはそこまで重要ではないため，データベースを変更するたびにデータを再作成しても何も問題はないから
- しかし，アプリケーションを本番環境にリリースしてしまうとデータモーションを適切に行わなければいけない為，移行ベースを用いる必要がある
- スキーマに対する変更は全て移行ベースで行い，その際に使ったスクリプトのファイルをソースコード管理システムで管理するようにする
- もし移行後に何らかの修正が必要であることが発覚した場合，決してそのデータを直接データベース上で変更してはいけない
- 仮に移行時に間違いが含まれていたとしても，その間違った移行結果を直接直すのではなく，まずは間違った移行を取り消す意向を行い，それから正しい移行を行うようにする
- ただし，その間違った移行によってデータが失われるのであればその時だけ，このルールは従わないような例外的な対処を行うようにする

## データベーストランザクションの管理

- データ不整合を避けるためにはデータベースを更新する際に行われる次の 2 つの決定を明確に分けなくてはいけない
  - どのデータを変更するのか
  - 変更したデータをデータベースに反映するのか(コミットするのか)それとも何も反映せずに元に戻すのか?(ロールバックするのか)
- この分離は重要
  - なぜならコントローラはこれらの決定を同時に下すことはできないから
- そこでビジネスオペレーションが終わった時にそのオペレーション中に起こったすべてのデータの変更をデータベースに反映するのか否かを決定するだけの責務と実際にデータベースのデータを変更するだけの責務との分ける
- このような責務の分割は Database クラスをリポジトリと呼ばれるクラスと，トランザクションと呼ばれるクラスに分けることで実現できる
- リポジトリ

  - データベースにアクセスし，そのデータを変更するクラス
  - テーブルごとに作ることが多いのかも

- トランザクション

  - データに対して行われたすべての変更をデータベーすに反映する，もしくは反映せずに元に戻すクラス
  - このクラスはデータベースが提供するトランザクション機能に依存した独自に作成したクラスになることが多く，アトミックな更新を可能にする

- トランザクションにコントローラーとデータベースのやりとりを仲介させることでアトミックなデータの更新が可能になる

- Commit の指示をする責務はコントローラにある

  - どの作業までが一つのトランザクションかわかるのはコントローラだけのため

- リポジトリクラスはコンストラクタの引数でトランザクションのクラスを受け取っており，そのトランザクション中でしかリポジトリは作業できず，直接データベースに接続しないことを示している

## トランザクションを単位作業に変換する

- リポジトリとトランザクションを導入することはデータ不整合が起こる可能性を回避するのに有効
- しかしこれよりも優れた方法がトランザクションクラスが使われている部分を単位作業と呼ばれるパターンに置き換えること
  - 単位作業とは 1 つのビジネスオペレーションの中でデータの変更が発生するオブジェクトをすべて保持してそのビジネスオペレーションが完了するときにそれらのオブジェクトに対して行われたデータの変更を 1 単位にまとめてデータベースに反映するパターン
- このパターンがトランザクションよりも優れている点は，データベースに対する更新を後回しにできる点
- トランザクションとは異なり，単位作業は対象のビジネスオペレーションが終わる時に変更のあったすべてのデータをデータベースに対して更新するようになっている
- そのためデータベースに対してトランザクションが制御する時間を最小限に抑えられるようになり，更新データの輻輳を減少できる
- さらにデータベースへの呼び出し回数を減らせるようにもなる
- こういうケースでは SQL を制作するよりも OR マッパーを使う

## 統合テストにおけるデータベーストランザクションの管理

- 統合テストでデータベーストランザクションを扱う場合，遵守しなくてはならない指針に，テストケースの異なるフェーズで同じトランザクションや単位作業を使いまわさないようにするということがある
- このような動きは本番環境にないため，正しいテスト結果が得られない
  - 本番環境ではビジネスオペレーションごとに個別のデータベーストランザクションが開始されることになるから

## テストでーたのライフサイクル

- 統合テストではテストケース自体がデータベースを想定の状態となるように準備しなくてはいけない

### 統合テストにおけるテストケース実行：同時に複数実行すべきか，もしくは 1 つずつ実行すべきか

- テストーケースを同時に実行することはすべてのテストデータがテストケースごとに一位となるようにしなくてはいけず，そのことを実現するにはデータベースの制約を活用して他のテストケースのデータが間違って使われることがないことを保証しなくてはならないため相当難しい
- 1 つずつ実行するのが無難
- しかしながら現実的なことを考えると，コンテナを使った方法は保守コストをあまりにも高くしてしまう

  - DockerImage の保守
  - かくテストケースが個別のコンテナインスタンスを得られることの保証
  - 統合テスト用のバッチの作成
  - 使い終わった後のコンテナの破棄

- 各開発者がテストの際に好きなように扱える個別のデータベーすインスタンスを持てるようにすることが現実的で良い

### 統合テストでのデータの後始末

- データが残ると他のテストケースの実行に影響を与えてしまう可能性があるため，これを避ける方法として 4 つの方法がある
- 各テストケースを実行する前にバックアップからデータベースを復元させる

  - 簡単だが時間がかかる

- テストケースの実行後にデータを後始末する

  - 時間はかからないが，データの後始末に失敗した時に問題になる

- 各テストケースを 1 つのデータベーストランザクション内で行い，コミットせずにロールバックする

  - 本番の挙動と異なってしまう

- テストケースの実行前にデータの後始末を行う

  - これが一番優れている
  - この方法だとテストケースの実行に時間がかからず，本番環境との動きも同じで，データの後始末がきちんと実行されるのかを心配する必要もなくなる
  - データの後始末を行うために個別のフェーズを設ける必要なはく，準備フェーズのなかで不要なデータの後始末を行うようにする

- データの後始末を行うスクリプトでは，通常データはすべて取り除かれるが，参照データは取り除かないようにすること．
- なぜなら参照データの変更はスキーマと共に移行でしか行ってはならないから

### in-memory データベースの使用に関する問題

- 結局本番を模倣できないから非推奨

## テストコードの再利用

- 統合テストはすぐに肥大化してしまい，保守がしづらくなってしまう
- そのため，統合テストでは，テストケースのコード量ができるだけ少なくなるようにしながらも，他のテストケースに影響を与えたり，読みやすさを損なったりしないことが重要になる
- どれほどコード量の少ないテストケースを作成できたとしても，そのテストケースが他のテストケースに依存することがあってはならない
- 加えて，統合テストのテストケースは検証するシナリオの完全な文脈を捉えていなくてはならず，開発者がテストクラスの様々な部分を見ないと何を検証しているのかが理解できなくなるような実装にしてはいけない
- テストケースのコード量を減らす最も効果的な方法はビジネスロジックに関わらない技術的なコードをプライベートなヘルパーメソッドに抽出すること

## 準備フェーズ

- 同じようなことをするコードプライベートはファクトリなどに抽出してその抽出したコードを複数のテストケースで使えるようにすること

### オブジェクトマザー

- テストを実施するのに必要なオブジェクトであるテストフィクスチャの生成を助けるクラスやメソッドのこと
- 複数のテストケースの準備ケース間で共有できるようにすることを目標としている
- 同じような目的を持つ別のパターンとしてテストデータビルダーがある
  - 流れるようで見やすいがコード量が増えてしまう傾向があるので本書ではオブジェクトマザーを推奨している

## 実行フェーズ

- 呼び出される最小限のコードで済むようにする

## 確認フェーズ

- 同じ感じ
- とにかくどのフェーズでも重複をなくしていく感じかな

## テストの際にデータベーストランザクションが多くなることは問題にならないのか

- これは実行時間と保守性のトレードオフ
- 大体は保守性の方が勝つ

## データベースを使ったテストに関するよくある疑問

### 読み込みに対してテストすべきか

- 書き込みに対するテストは非常に重要
- しかし読み込みに関しては，その部分のみに影響がいくので大きな害はない
- そのため読み込みに対してテストを行うにはその読み込みが非常に複雑な場合，もしくは重要な役割を担う場合だけにすべき
- 一方そうでない読み込みであれば無視をしても良い
- 読み込みに対してドメインモデルは必要ない
- ドメインモデルで達成しようとしていることの 1 つはカプセル化で，カプセル化とはどのようなデータの変更が行われてもデータ整合性が保たれるようにするための手法
- そのためデータの変更がないのであればカプセル化をしなくても済む
- 間接そうも必要無く単体テストを行う意味がない

### リポジトリをテストすべきか？

- リポジトリはデータベースの操作を抽象化して使いやすくしたもの
- 一見，リポジトリがどのようにドメインオブジェクトとデータベースとを関連づけているのかを検証するため価値がありそうに見えるが，保守コストが高く，退行に対する保護もあまり備わらないため，そのようなテストケースをテストスイートに加えることはテストスイートの価値を下げることになってしまう

### 高い保守コスト

- リポジトリはコントローラに属するもの
- リポジトリはあまり複雑にならない一方，プロセス外依存を扱うことになるコード
- そしてこのプロセス外依存の存在がテストに対する保守コストを大きくする

### 退行に対する脆弱な保護

- リポジトリにはそれほど複雑なコードは含まれない，
- そしてリポジトリを検証することで得られる退行に対する保護は通常の統合テストをすることで得られる保護と多くの部分が重なる
- そのためリポジトリをテストしたとしても，それによって新たな価値がもたらされることはない
- OR マッパーを使うとオブジェクトの作成とデータベースへのフェッチが分離できないため，リポジトリを直接検証するのではなく，統合テストのシナリオの一部に含めて検証するようにする

## 結論

- データベースに対してきちんと考えられたテストはバグに対する強力な保護となる
- このようなテストなしでは開発しているソフトウェアに対して完全な自信を持つことができない
- このようなテストの存在はデータベースとのやりとりをリファクタリングする時，OR マッパーを使うように変更した時，データベースのベンダーを帰る時などに非常に大きな助けになる
- 統合テストにおいて，管理下にある依存を直接扱うようにすれば，大規模はリファクタリングを行ったとしても，その際に生じるかもしれないバグに対して最も効果的な保護を得られるようになる
