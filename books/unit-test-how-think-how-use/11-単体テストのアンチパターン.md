# 11 単体テストのアンチパターン

## プライベートなメソッドに対する単体テスト

-   このようなテストは一部例外を除いて一切すべきでない

### プライベートなメソッドとテストの不十分な網羅率

-   場合によってはプライベートなメソッドがあまりにも複雑でそのメソッドを観察可能な振る舞いの一部に含めて検証しても，きちんと網羅できていないことがある
-   仮に観察可能な振る舞いに対する検証は十分にされているとした場合，それにもかかわらずテストの網羅性がそこまで高くないのであれば，以下の問題がある
    -   デッドコード
        -   もしテストで実行されることのないコードがあり，そのコードが実際に使われていることがないのであれば，そのコードは何らかのリファクタリングをした後に残ってしまった不要なコードの可能性がある.そのようなコードは削除すべき
        -   抽象化の欠落
            -   もし，プライベートなメソッドがあまりにも複雑で，公開されている API からプライベートなメソッドを十分に検証することが難しいのであれば，テスト対象のコードに対する抽象化が欠落している可能性がある
            -   そのため，抽象化できる部分を別のクラスとして抽出した方が良い

### プライベートなメソッドを直接テストすることが受け入れられるのはどのような場合か？

-   プライベートなメソッドをテストしてはいけない理由は実装の詳細とテストが繋がり，テストが脆くなるから
-   ただし，ごく稀にプライベートでありながらも観察可能な振る舞いの一部となるメソッドが存在する
-   例えばファクトリメソッドを矯正したいがためにプライベートにしたコンストラクタ

## プライベートな状態の公開

-   テストのためにプライベートな API を公開してはいけない

## テストへのドメイン知識の漏洩

-   テストコードで行っていることとプロダクションコードでやっていることが一緒だとマジで意味ない
-   テストを作成する際，プロダクションコードに定義された特定のロジックやアルゴリズムをテストコードに持ってこないこと
    -   テストでは期待値をそのまま書くこと

## プロダクションコードへの汚染

-   テストでのみ必要とされるコードをプロダクションコードに加えること
-   真偽地などでテストかプロダクションかを判定しないようにすること
-   このような場合はインターフェイスを使うこと
    -   インターフェイスもプロダクションコードへの汚染になりうるが，真偽ちよりも影響が少なく，また，テスト時にしか使われないはずのコードが間違って本番環境で呼び出されることもなくなる j
    -   加えてインターフェイスにはバグを含めることができない
        -   なぜならインターフェイスは単なる契約であり，具体的なコードを持つわけではないから
        -   真偽地だと具体的な値なのでバグる可能性あり

## 具象クラスに対するテストダブル

-   具象クラスをテストダブルで置き換えると，置き換えたいメソッドとそうではないメソッドを選ぶことができる
-   しかしこのようなテストダブルの使い方が求められることは実はテスト対象コードの設計に大きな欠点があることを示唆している
-   その欠点とはテスト対象のコードが単一責任の原則を遵守していないということ
