# 8 なぜ統合テストを行うのか

## インターフェイスを使った依存の抽象化

- クラスが 1 つのみであってもインターフェイスを利用する理由でよくある間違い
  - プロセス外依存を抽象化できるようになり，その結果疎結合を実現できるようになる
  - 既存のコードを変更することなく，新しい機能を追加できるようになり，OpenClosed の原則を遵守しやすくなる
- 上記 2 つの認識は間違っている
- まず，クラスが 1 つしかないのであれば，そのインターフェイスは抽象ではない

  - そのようなインターフェイスを導入したとしても，具象クラスをそのまま使う場合と比べて疎結合になるわけではない
  - 本来抽象化とは発見することであり，作り出すことではない

  - そして，発見とは定義上，すでに抽象が存在しているのにもかかわらず，コード上にはまだ明確に定義されていない事実の存在がある場合に初めて行われること
  - そのため，インターフェイスが本当の抽象になるためには，2 つ以上の実装クラスがないといけない

- 既存のコードを変更することなく，新しい機能を追加できるという認識も YAGNI 原則に外れるため，よくない

- このような結論に至るには主に 2 つの理由がある

### 機械に対するコスト

- まだユーザーが必要としてない機能の開発に時間を費やすことは，現時点で必要とされる機能の開発から時間を奪うことになる
- さらに前もって開発した機能がユーザーの目に触れる時，ユーザはすでに備わっているものよりも多くのことを望むことが多く，結果として，前もって実装しておいた機能に対して修正を加えることになる
- そのため，現時点で必要とされていない機能に時間を費やすのは無駄なことであり，実装に必要となったタイミングで機能を最初から開発する方が効率的

### コード量は少ないほどよい

- 現時点では必要のない機能を念の為に導入することはコードベースの所有に対するコストを不必要に増やすことになる
- そのため，そのような新たな機能の追加はプロジェクトの終盤まで可能な限り後回しにした方が良い

## なぜプロセス外依存にインターフェイスを使うのか？

- クラスが 1 つであってもインターフェイスを用意する意味はモックを作れるようにするため
- 逆にプロセス外依存をモックにする必要がない限り，その依存のインターフェイスを作るべきではない
- そしてテストにおいてモックを使うのは管理下にない依存に対しての身にしなくてはいけない
- 結論としては，管理下のない依存に対してのみインターフェイスを用意するということになる
- ただし，インターフェイスに対して複数の実装クラスができるような本当の意味での抽象化ができるのであれば，モックにするのかどうかに関係なく，インターフェイスを使っても構わないということになる

## 統合テストのベストプラクティス

- 統合テストを最大限に活用するための基本となる指針に以下のようなことがある
- ドメインモデルの境界を明確にする
- アプリケーションを構成する層を減らす
- 循環依存を取り除く

## ログ出力に対するテスト

### そもそもログ出力のテストをすべきなのか？

- テスト対象とするログ出力がアプリケーションの観察可能な振る舞いの一部なのか，それとも実装の詳細なのかによって変わる
- ログという副作用が外部(ユーザー，アプリケーションのクライアント，非開発者)からもみられることを意図しているならば，このログ出力は観察可能な振る舞いであり，テストを行わなくてはならない
- 一方，出力されたログをみるのが開発者だけである場合，そのログ出力は実装の詳細であり，開発者は外部に気を使わなくてもそのログ出力を修正できる

  - この場合のログ出力はテストされるべきではない

- アプリケーションの重要なフローの中でログを出力することがユーザーの要望としてある場合，このログ出力は観察可能な振る舞いとなる

  - このログ出力はビジネス要求であるため，テスト対象にしなくてはいけない

- これらの 2 種類のログは以下のように分類できる

1. サポートログ

   - システムのサポートスタッフやシステム管理者によって見られることを意図した特定のイベントを記録するログ

1. 診断ログ
   - 開発者がアプリケーション内で何が起こっているのかを把握できるようにするためのログ

### どのようにログ出力をテストすべきか?

- ログ出力はプロセスが依存に対して副作用を発生させる機能であるため，テストの際はモックを使って検証することになる

### ビジネス要求に応じたログ出力オブジェクトの導入

- ログ出力のモックのために，ILogger のようなものを作ってはいけない
- サポートログの出力はビジネス要求による機能であるため，コードベース上にその機能がビジネス要求を反映したものであることを明確に伝えなくてはいけない
- そこで全てのサポートログが各メソッドとして定義された DomainLogger クラスを作成し，この DomainLogger クラスからサポートログを出力するようにする
- こうすることで，汎用的な ILogger インターフェイスではなく，サポートログが定義された DomainLogger クラスとのやりとりを検証することで，明確にサポートログの検証が行える

- サポートログを出力する各メソッドの名前にテスト対象のドメインで使われている用語が使われることで，どのようなサポートログを出力するのかが明確になり，それに伴い保守も行いやすくなる
- 本書ではログをドメインクラスにおくと，よくないので，ドメインクラスはドメインイベントを生成するようにして，ドメインクラスにイベントを格納させている
- コントローラー側でドメインイベントを取得して後でログしている

## どのくらいログを出力すれば十分なのか？

- 診断ログの場合，次のような課題が出るため重要なのは過度に出力しないこと

  - プロダクションコードが汚くなる
  - ノイズとなる情報が多くなってしまう

- 上記理由により，ドメインモデルでは診断ログを全く出力させないように努めるのが良い

### どのようにログ出力オブジェクト(logger)を受け渡すのか

- 静的に logger を宣言することもできるが，このような依存の取得のことを環境コンテキストというアンチパターン

  - 依存関係が隠れてしまい，変更が難しくなる
  - テストがより難しくなる

- もし，Logger を明示的に渡すことが難しく，環境コンテキストから取得する方法しかないのであれば，そこには何らかの問題があることを確実に示唆している
- 可能性として考えられるのは，あまりにも多くのログを出力しているのか，もしくは間接参照の層があまりにも多いのかのどちらか
- 環境コンテキスト以外であれば，メソッドの引数から明示的に受け渡す方法もある

## 結論

- 全てのプロセス外依存とのコミュニケーションに対して，そのコミュニケーションが観察可能な振る舞いの一部なのか，それとも実装の詳細なのかということを考えること
