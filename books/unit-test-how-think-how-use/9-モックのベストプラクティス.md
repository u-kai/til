# モックのベストプラクティス

- 管理下のない依存とのコミュニケーションの流れの中で，モックに置き換えられるコンポーネントをアプリケーションの境界に近いものにすれば，テストを実施する際に経由されるクラスの数が増え，より強力な退行に対する保護を得られるようになる
- モックに置き換えるコンポーネントの境界が限りなく近くなるにつれ，テストケースに備わるリファクタリングへの耐性もより強力になる
- 管理下にない依存への呼び出しがアプリケーションの境界を超えるまで，その呼び出しは様々なコンポーネントを経由することになる
- そのため外部との境界に最も近いコンポーネントをモックに置き換えるようにする
- そうすることで，外部システムとのやりとりにおいて，後方互換を保てるようになる
- まさにこの後方互換の保証がテストに対して求められていることであり，モックを導入する目的

- スパイは手書きのモックと呼ばれることもあり，手動で実装すること
- システムの境界にあるクラスをテストダブルに置き換えるのであれば，モックよりもスパイの方が適している
  - なぜならスパイであれば確認をする際のコードをそこに記述でき，複数のテストケースからそのコードを呼び出すようにすれば，各テストケースのコード量がへり，読みやすさが向上するから

### モックの利用は統合テストに限定する

- このベストプラクティスはビジネスロジックに関するコードと連携を指揮するコードとを分離するという基本原則からきている
- つまり，テスト対象とするコードはプロセス外依存とのやりとりを行うコードか，もしくは複雑さを持つコードかのどちらかにすべきであり，両方の性質を持つコードにすべきではない,ということ
- この原則に従うと，プロダクションコードはドメインモデルの層とコントローラーの層とに自然と別れることになる
- そうなると，ドメインモデルに対する検証は単体テストで行われ，コントローラに対する検証は統合テストで行われることになる
- モックに置き換えるのは管理下にない依存だけであり，そのような依存を扱うのはコントローラだけであるため，モックを使うのはコントローラのテスト，つまり，統合テストの時だけになる

### 1 つのテストケースには複数のモックを持たせてはならないという誤解

- 1 単位の振る舞いを検証することと，モックのかつとの間には何も関係がない

### モックの呼び出し回数を常に確認する

- 管理下にない依存とのコミュニケーションを検証する際に重要なことは以下の 2 つを両方とも保証すること

  - 想定する呼び出しが行われていること
  - 想定しない呼び出しは行われていないこと

- これらのことを保証する重要性もまた管理下にない依存との後方互換性を維持する必要性からきている
- 後方互換を維持するためには，アプリケーションは外部システムが想定するメッセージを省略してはならないこと，及び，外部システムが想定していないメッセージを送ってはならないことの両方を保証しなくてはいけない
- そのためテスト対象のアプリケーションが想定するメッセージを送信していることだけを確認しても十分な検証をしているとは言えない
- 想定した呼び方がされていることに加え，想定した回数しか呼ばれていないかを確認する必要がある

### モックの対象になる型は自身のプロジェクトが所有する型のみにする

- モックを作成する際はサードパーティ製のライブラリが提供するものを直接モックに置き換えるのではなく，そのライブラリに対するアダプタを独自に作成し，そのアダプタに対してモックを作成するというもの
- 理由

  - サードパーティ製ライブラリが実際にどのように機能しているのかを深く知ることは滅多にできないから
  - サードパーティ製のライブラリ自体が利用可能なインターフェイスを既に提供していた場合，そのインターフェイスをモックに置き換える対象にすると，モックの振る舞いとサードパーティ製のライブラリの実際の振る舞いが一致することを保証しなくてはならなくなり，リスクを伴うことになるから
  - アダプタを挟むことで，サードパーティ製のライブラリに含まれるビジネス的に本質ではない技術的な詳細を隠蔽できるようになり，さらに自身のアプリケーションの用語を用いてライブラリとの関係を定義できるようになるから

- 実際にこのようなアダプタは，テスト対象のコードと外部の世界との間に位置する腐敗防止層として機能し，次のメリットをもたらす

  - サードパーティのライブラリが持つ複雑さを抽象化できる
  - サードパーティのライブラリが提供する機能の中で，必要な機能のみを公開できる
  - 自身のプロジェクトで使っているドメイン用語を使えるようになる

- ただしここで注意することは，自身のプロジェクトが所有する型のみをモックに置き換えるという指針は同じプロセス内の依存に対しては該当しない
- 同じプロセス内の依存や管理下にある依存を抽象化する必要はない
