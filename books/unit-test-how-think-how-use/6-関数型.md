## 副作用

-   メソッドシグネチャ(戻り値の型，関数名，引数)に表記されていない出力のこと
    -   隠れた出力のこと
    -   オブジェクトの変更やファイルシステムへの作用など
    -   例外も該当する

## 内部もしくは外部の状態への参照

-   隠れた入力になる

### 数学的関数かどうかを確かめる方法

-   対象の関数を関数が出力する値に置き換えてその後の振る舞いが同じであるかを確認する
    -   もし隠れた入出力があればそれは数学的関数ではない
    -   このように振る舞いを変えることなくメソッド呼び出しを変えられることを参照透過という

## 関数型アーキテクチャの導入が難しい場合

-   関数的核を呼び出す前に全ての入力値を集めることができるとうまく分離できる
-   しかし，実際のシステムでは決定を下す流れが単純じゃないことが多い
-   例えば決定を下している最中に途中で得た結果を使って新たにプロセス外依存からデータを取得しなければならないような場合

    -   これはよくありそう

-   上記のようなことをなくすために，全てのデータを条件関係なしにとってきて，関数的核に渡すこともできるが，それはパフォーマンスを明らかに犠牲にする
-   情報を呼び出すか呼び出さないかを関数的確が判定して，副作用があるサービスがそれをその判定ロジックを呼び出してから関数的確を呼び出すようにすると，パフォーマンスの悪化は防ぐことができるが，ロジック判定が外に漏れて，責務の分離がうまくいかなくなる
-   もう一つの解決方法として，ドメインモデルにデータベースへのアクセスをさせるということもできるが，これは絶対にしてはいけない

## コードベースが大きくなる欠点

-   可変部分と関数部分で分離するためコードベースは大きくなりがち
-   関数型のいいところは複雑なロジックと入出力を分離できることや，複雑なロジックが参照透過になるので，扱いやすくなること
-   逆に，あまり複雑ではないロジックに関数型の考えを持ち込む必要はないかもしれないらしい

-   所感
-   同じクラスの中に参照透過の関数と副作用のある関数を持っているのは良くないかも
-   ここを徹底的に分離することがいいコードの第一歩かも
-   今回の例だと，ファイル操作だったが，ファイル操作に関する構造体を作ってその構造体を返すようにすれば参照透過は守られる
-   そして最後の最後にその構造体を使って間接な副作用があるコードを記述することができそう
