# 単体テストの価値を高めるリファクタリング

-   単体テストを行う価値がある最も高いプロダクションコードは複雑なコード，もしくはドメインにおける重要性が高いコード

    -   そのようなコードをテストすることで対抗に対する保護が備わるようになる
    -   ただしドメインのコードが複雑ではなくとも，ドメインのコードは核となるもののためテストする価値は高い

-   テスト対象のコードがより重要に，もしくはより複雑になるにつレ，協力者オブジェクトの数を減らさなくてはならない
-   過度に複雑なコードを取り除き(アルゴリズムやドメイン知識と副作用を持つもの)単体テストで検証するコードをドメインモデルやアルゴリズムに属するコードだけにすることは，テストスイートの価値を高くし，保守を行いやすくすることにつながる

## HumbleObject

-   ロジックを持たない質素なオブジェクトを生成することで，過度に複雑なコードからロジックを抽出できるようにする
-   この時質素なオブジェクトにはロジックを含ませないようにすることでテストを不要にする
-   その結果抽出されたロジックはテストを難しくする依存から切り離されるようにする
-   ヘキサゴナルアーキテクチャと関数型アーキテクチャはこのパターンを適用したもの
-   コントローラーがいかに多くのオブジェクトを指揮していても，そのコントローラは複雑さを持ってはならない
    -   コントローラが質素なオブジェクトに相当する？
    -   テストが難しい部分は質素にしましょうやって感じっぽわ
-   一方ドメインクラスは少ないオブジェクト，不変なオブジェクトを使って，複雑なことを行うべき

-   アプリケーションサービスや，コントローラーなどの質素なオブジェクトがドメインロジックを呼び出すようにすることで，ドメインロジック側には副作用のある依存関係を全く持ち込まなくても済むようになる

## 暗黙的な依存を明示された依存にすることに関して

-   外部依存性のあるものを Interface にして明示された依存にし，テスト時には Fake などを利用するケースがあるが，テストはしやすくなるが十分ではない
-   プロダクションコードの分類の観点で見ると，ドメインモデルがプロセス外依存を直接扱うのか，それともインターフェイスを介して操作するのかは重要ではないから
-   仮にインターフェイスを介して操作するようにリファクタリングを行ったとしても，それらの依存はメモリ上にはまだないデータを橋渡しするプロセス外依存であることに変わりはない
-   そのためこのようなクラスをテストするためにはモックを用いた複雑な構造をテストコード上で維持しなくてはならなくなる

    -   テストに対する保守コストは増える
    -   またデータベースの依存をモックに置き換えることはテストを壊れやすくすることにつながる

-   結局のところ，ドメインモデルにプロセス外の依存となる協力者オブジェクトを直接扱わせるようにするのか，それともインターフェイスを経由して間接的に扱わせるようにするのかに関係なく，そのような協力者オブジェクトを 1 つも持たせないことがコードを簡潔にすることにつながる
-   碧サゴナルアーキテクチャではドメインモデルに外部システムとのコミュニケーションの責務を決して担わせないようにしている

-   副作用の発生が最後の瞬間まで全てメモリ上でしか起こらないようにすることでテストのしやすさは格段に向上する

-   ビジネスロジックのコードと連携を指揮するコードとを完全に分離することで，コードベースのどの部分を単体テストで検証すべきなのかが明確になる

## 事前条件をテストすべきか？

-   事前条件がドメインにおいて重要であればテストするべき
-   もし事前条件にドメインにおける重要性がないのであればテストする価値はない

## コントローラーにおける条件付きロジックの扱い

-   条件によって振る舞いが異なるロジックを扱う場合，通常，ドメイン層からプロセス外依存を取り除いた状態を維持することは簡単にはできない
-   そのため様々なトレードオフについて考えることが求められるようになる
-   ビジネスロジックのコードと連携を指揮するコードの分離を最も行いやすいのは，1 つのビジネスオペレーションがストレージからのデータ取得，ビジネスロジックの実行，変更されたデータの保存の順番になっている時
-   しかし，決定を下す家庭の中で，途中で得た結果を使ってプロセス外依存から新たにデータ取得しなければならないような場合，上記手順を完璧に守ることは難しい
-   加えてプロセス外依存への書き込みがその途中で得た結果によって変わることもよくある
-   この問題に対する解決策の選択として大事なのは，以下の 3 通り

    1. ドメインモデルのテストのしやすさ
    1. コントローラーの間接さ
    1. パフォーマンスの高さ

-   しかし，これらの 3 つの性質を全て備えることはできず，2 つまでしか備えることができない

### 外部の依存に対する全ての読み込みをビジネスオペレーションのはじめや終わりに持っていく

-   この選択をした場合，コントローラーの簡潔さを他モテるようになり，ドメインモデルをプロセス外依存から隔離した状態を保てるようになる
-   しかしながらパフォーマンスは劣化する

### ドメインモデルにプロセス外依存を注入する

-   この選択をした場合，パフォーマンスの高さと，コントローラの簡潔さは維持される
-   しかしながらドメインモデルに対するテストのしやすさは失われることになる

### 決定を下す過程をさらに細かく分割する

-   この選択をした場合，パフォーマンスを高め，テストを行いやすくすることができる
-   しかし，コントローラに対して分割した家庭を管理するための決定を下す箇所を新たに加える必要が出てくるため，コントローラの簡潔さを保てなくなる

-   ほとんどのソフトウェアプロジェクトにおいてパフォーマンスの高さは重要な性質であるため，1 つ目の選択肢が選ばれることはない
-   2 つ目の選択肢はほとんどのコー度を過度に複雑なコードに属するようにしてしまう
    -   本書ではドメインモデルにプロセス外依存を注入することは避けるべき
    -   そのような実装にしてしまうと，ビジネスロジックをプロセス外依存とのコミュニケーションから分離することができなくなってしまい，その結果テストをすることも，保守をすることも難しくなってしまう
-   3 つ目の方法しかなくなるので，コントローラーが複雑になってしまうことへの対処が必要

### 確認後実行パタ-ン(CanExecute/Execute)パターンの適用

-   コントローラーがより複雑になることへの対策として最初にできること
-   このようにすることでコントローラでは何も決定せずに済むようになる

### ドメインモデルの状態を追従するドメインイベントの利用

-   ドメインモデルで起こった重要な状態の変更を把握できるようにし，その変更を発生させたビジネスオペレーションが終わった後にプロセス外依存に対して変更があったことを伝えるようにする
-   このような場合に使えるのがドメインイベント
-   ドメインイベントとは，ドメインエキスパートにとって意味のあるあぷいケーションのイベントを表現するもの
    -   このドメインエキスパートにとって意味のあるということがドメインイベントを通常のイベントから区別する要素となる
    -   ドメインイベントは自身のシステム内で起こった重要な状態の変更を外部アプリケーションに伝える際によく使われる
-   ドメインイベントを利用すればドメインモデルが過度に複雑なコードになってしまうことを避けられるようになる
-   実装の観点から見ると，ドメインイベントとは，外部システムに伝えなくてはならないデータを含んだクラスのことになる
-   ドメインイベントが表現していることはすでに起こったことであるため，ドメインイベントの名前は常に過去形でつけるべし
-   またドメインイベントは値であるため，不変オブジェクトとして定義し，同じ値であれば同じものとして扱われるようにする

## まとめ

-   ドメインイベントや確認後実行パターンの助けを借りることで決定を下すための全ての過程をドメインモデル内に収めることができる
-   しかしながら，実際のプロジェクトでは必ずしもビジネスロジックを凝集させることはできない
-   例えばメールアドレスが一意であることを確認しなくてはならない場合，プロセス外依存をドメインモデルに持ち込むことなく，コントローラの外でその確認を行うことはできない
-   他にもプロセス外依存の中でビジネスオペレーションの流れを変えるようなエラーが発生した場合，その後に何をするのかを決定することをドメイン層で行うことはできない
-   なぜならプロセスがいいぞんへの呼び出しはドメイン層で行ってはならないから
-   そのためエラーが起きた時に何をするのかを決定するロジックはコントローラに持たせなくてはならず，統合テストでそのことを検証しなくてはならない
-   とは言え，このようなビジネスロジックの散存が起こる可能性はあるものの，ビジネスロジックに関するコードと連携の指揮に関するコードを分離することは単体テストを劇的に単純化できるため多大な価値をテストスイートもたらすことになる
-   またビジネスロジックをコントローラに持ち込んでしまうことを避けられないのと同じようにドメインクラスから全ての協力者オブジェクトを完全に取り除けることも滅多にない
-   しかしこのことについて神経質にならなくても良い
-   協力オブジェクトがプロセス外依存でない限り，ドメインクラスが過度に複雑になることはないから
-   またこの協力オブジェクトをモック化するのはよくない
-   なぜならこのような場合，協力オブジェクト殿やろとりはドメインモデルの観察可能な振る舞いとは関係のないことだから
-   メソッドが観察可能な振る舞いの一部となるには，次の 2 つの条件のうちのどちらかを満たしていなくてはならない

1. 対象のメソッドがクライアントの目標の 1 つに直接結び付いている
1. 外部アプリケーションから確認できる副作用がプロセス外依存で起こる

-   各層のテストは 1 つ上の層の視点で行い，テスト対象となる僧がその下にある層と何をしているのかについては意識しないようにする
-   そしてそのそうが 1 つ下がる度に視点も同じように変えていく，
-   そうすると，先ほどまでは実装の詳細だったものが視点が変わることで観察可能な振る舞いとなり，その視点でのテストを新たに実装することになる
