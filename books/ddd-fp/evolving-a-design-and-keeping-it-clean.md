# Evolving a Design and Keeping It Clean

- DDD は静的なものではない
- 継続的な開発者とドメインエキスパートとのコラボレーションを意味している
- 要件が変わったら常に実装の前にドメインモデルを再度評価する必要がある
- 4 つの変更に対してみていく
  - workflow の追加
  - workflow の input を変更
  - キードメインの種類の定義を変更し、それがシステム全体にどのように波及するのか
  - ワークフロー全体をビジネスルールに適合させる

## Change 1 Adding Shipping Charges

- カテゴライズされたデータの処理に対してはパターンマッチではなく，Active Patter が良い
- ビジネスロジックとカテゴライズを分けると、コードがクリアになる
- また、ドキュメント性が上がる

- 確かにこうしておかないと、ドキュメント性は低く、今度値段を変えようとしても意味合いがわからずに苦労しそう
- カテゴライズと、料金を別々に更新することもできる
  - カテゴライズだけ変更や料金だけ変更も簡単にある
- GPT 曰く、Active pattern は F#特有のもので、(|pattern|)というバナナクリップ構文によってパターンマッチよりもパワフルな表現力に富んだものらしい

```fs
// pattern match
let calculateShippingCost validatedOrder =
    let shippingAddress = validatedOrder.ShippingAddress
    if shippingAddress.Country = "US" then
        match shippingAddress.State with
        |"CA"|"OR"|"AZ"|"NV"|->
        5.0
        |_ ->
        10.0
    else
        20.0

// active pattern
// ここでUsLocalStateなどを定義している？よくわからん
// この定義によって、addressの型をパターンマッチさせると、UsLocalStateかUsRemoteStateかInternationalが出てくる感じだと思う
// つまり、enumではない型をパターンマッチに使えるようにしている
// 普通だったら、ある型を引数としてenumを返す関数になりそうだが、それをF#ではactive patternを使える感じか
// 何がいいのか？
// "アクティブ パターン" を使用すると、入力データを分割する名前付きパーティションを定義できます。これにより、判別共用体の場合と同様に、パターン マッチング式でこれらの名前を使用できるようになります。 アクティブ パターンを使用すると、パーティションごとにカスタマイズした方法でデータを分解できます。by MS docs
// 関数のシンタックスシュガー？
// と思ったけど、おそらく結構使える
// enumであれば生成に対してのルールはいつくでも作成できる
// しかしactive patternはある型をある列挙子に変換する関数のようなものであるため、その列挙子はおそらくその一つの作成方法しか存在しないはず
// そして、その列挙子の元となる型はその列挙子のことを知らずに済むので依存関係も少なそう
// ある型を何かのパターンに紐づける時は良いものな気がしてきた
let (UsLocalState|UsRemoteState|International|) address =
    if address.Country = "US" then
        match address.State with
        |"CA"|"OR"|"AZ"|"NV" ->
        UsLocalState
        |_->
        UsRemoteState
    else
        International

let calculateShippingCost validatedOrder
    match validateOrder.ShippingAddress with
    | UsLocalState -> 5.0
    | UsRemoteState -> 10.0
    | International -> 20.0
```

## Creating a New Stage in the Workflow

- 要件が変わったことで、その要件専用に新しく型を作る(元の型にフィールドを増やすのではなく)ことはやりすぎのように思えるが、型を作らないと

  - もし、他の step で新しい型を予想していたらうまくいかない->これは意味わからん。想定すな
  - もし、新しいフィールドに対する値が型の生成後に埋め込まれるような値だと、ミュータブルにするか、初期化時には DefaultValue を使って、後から生成する必要があるのでよくない

- 他のステージから隔離されており、要求に型が一致していると、安全に新しい要求に対いする stage やコンポーネントを追加、削除できる

- 要件以外で pipeline に追加するものとしては
  - logging,performance metrics auditing などは簡単に追加できる
  - 認可チェック、やその失敗や、失敗を下に伝えることや、他のパイプラインをスキップする機能
  - 動的に集約 Root に設定値や context を入力として入れることができる
    - おそらくこれらは型を要件ごとに分けていれば、あるところを変更することや、その変更による変更はとても簡単だよねってことかな？

## Adding Support for VIP Customers

- Customer に VIP という概念を追加する話
- IsVip とかでは持たせたくない
- CustomerStatus という choice 型を使って、そのフィールドを CustomerInfo としたいが、これは VIP や普通の顧客以外に直行する状態がある可能性があるのでよくない？

  - これは直行するであろう状態がこのドメインにある、もしくは未来に概念として生まれる可能性を言及している？
  - そしてそれらと VIP やそれ以外は直行するはずなのに choice 型で表現できていないから、よくないって感じ？

- ベストな解は妥協策で、VIPStatus を choice 型で作成する

  - 確かにこれは CustomerInfo を持っていないので、直行性はないが、bool のよりドキュメント性が良いバージョンとしか思えない
  - それでもいいし、そういうのが必要な時もあるってことか
  - やはりいくら、flag がダメだとしても、概念として、flag のようなものは持っている感じか
  - それとも、今回は全て新しい型にするよりは、ある status だけを追加する方法の方がメンテナンス性が良いというケースだったのか
    - これはこれで真な気がする

- 今後新たなステータスができても簡単に追加できる

  - 今までの話であればカスタマーごと新しい型を作ってそうだが、こういう判断も必要なのは面白い
  - 確かに Customers としてあらたな VIPCustomerInfo とか NormalCustomerInfo とか作るよりもよいのか？
    - ここに直行性のある概念がある可能性があるので今回はやめたが、それは観察が足りていないだけな気もするが。
    - それとも、ほとんどの処理が CustmerInfo に依存するのに、ひとつの VIP かどうかのフィールドだけで型を作るよりは CustoerInfo を変えずに新しい型を追加した方が良いってこと？

- この本のように型定義をしまくって、副作用のない関数を使いまくれば、要件が変更してもその箇所だけ変えれば良くなり、他には影響が及ばなそう
- 逆にこれによって、要件を一つの workflow で達成しがちになり、workflow の肥大化はしそうな気もするので DDD のような設計は必要

## Adding Support for Promotion Codes

- None にするぐらいなら型を作った方が良い
- コンパイルエラーは友達

  - まあそうだと思う

- 何かしらビジネス上重要な部分はそれが独立して進化し、他の領域から切り離された状態を維持できることも同様に重要
- コンテキスト間のコントラクトを要件によって破壊するのではなく、コンシューマ駆動を使用すると良い
  - わざわざ他コンテキストの変更をそれを必要とするものへも変更する必要はないよね

## Adding Business Hours Constraint

- ワークフローの使用方法に新しい制約を追加する方法
- アダプター関数を使い、任意の関数を入力として受け入れ、全く同じ動作をするが、特定条件の時にエラーを発生させるラッパーまたはプロキシ関数を出力する関数を作成する

  - 簡単に関数を強化できる

- 関数の最上位で、プロキシを関数を挟んで、挿入してやる

## Dealing with Additional Requirements Changes

- 場合に応じて新いコンテキストを作ること

## Wrapping Up the book

- 低レベルの設計を開始する前にドメインについて深く共有された理解を深めることを目指す必要がある

  - これに役立つソリューションとしてイベントストーミングとコミュニケーションテクニック(ユビキタス言語)が取り上げられた

- 各ワークフローが明示的な入力と出力を持つスタンドアロンパイプラインとして表されるようにする必要がある
- コードを記述する前にタイプベースの表記を使用して要件をキャプチャし、ドメインの名刺と同志の両方をキャプチャする必要がある

  - 名詞は代数型システム
  - 動詞は関数

- 可能な限り、重要な制約とビジネスルールを型システムに取り組むように努める必要がある
- 関数を純粋かつ全体的に設計し、考えられる全ての入力が明示的に文書化された出力をもち、全ての動作が完全に予測可能となる必要がある
