Consistency Between Different Contexts What if we need to coordinate between different contexts? Let’s look at the second example on the list above: When an order is placed, a corresponding invoice must be created. If the order exists but the invoice doesn’t, the data is inconsistent. Invoicing is part of the billing domain, not the order-taking domain. Does that mean we need to reach into the other domain and manipulate its objects? No, of course not. We must keep each bounded context isolated and decoupled. What about using the billing context’s public API, like this: ​ Ask billing context to create invoice ​ If successfully created: ​ create order in order-taking context This approach is much trickier than it might seem, because you need to handle either update failing. There are ways to synchronize updates across separate systems properly (such as a two-phase commit), but in practice it’s rare to need this. In his article “Starbucks Does Not Use Two-Phase Commit,”[25] Gregor Hohpe points out that in the real world businesses generally do not require that every process move in lockstep, waiting for all subsystems to finish one stage before moving to the next stage. Instead, coordination is done asynchronously using messages. Occasionally, things will go wrong, but the cost of dealing with rare errors is often much less than the cost of keeping everything in sync. For example, let’s say that instead of requiring an invoice be created immediately, we just send a message (or an event) to the billing domain and then continue with the rest of the order processing. So now what happens if that message gets lost and no invoice is created? One option is to do nothing. Then the customer gets free stuff and the business has to write off the cost. That might be a perfectly adequate solution if errors are rare and the costs are small (as in a coffee shop). Another option is to detect that the message was lost and resend it. This is basically what a reconciliation process does: compare the two sets of data, and if they don’t match up, fix the error.

A third option is to create a compensating action that “undoes” the previous action or fixes the error. In an order-taking scenario, this would be equivalent to cancelling the order and asking the customer to send the items back! More realistically, a compensating action might be used to do things such as correct mistakes in an order or issue refunds. In all three cases, there’s no need for rigid coordination between the bounded contexts. If we have a requirement for consistency, then we need to implement the second or third option. But this kind of consistency won’t take effect immediately. Instead, the system will become consistent only after some time has passed— “eventual consistency.” Eventual consistency is not “optional consistency”: it’s still very important that the system be consistent at some point in the future. Here’s an example. Let’s say that if a product price has changed, we want to update the price for all orders that haven’t shipped yet. If we need immediate consistency, then when we update the price in the product record, we also have to update all affected orders and do all this within the same transaction. This could take some time. But if we don’t require instant consistency when a product price has changed, we might instead create a PriceChanged event that in turn triggers a series of UpdateOrderWithChangedPrice commands to update the outstanding orders. These commands will be processed some time after the price in the product record has changed, perhaps seconds later, perhaps hours later. Eventually the orders will be updated and the system will be consistent. Consistency Between Aggregates in the Same Context What about ensuring consistency between aggregates in the same bounded context? Let’s say that two aggregates need to be consistent with each other. Should we update them together in the same transaction or update them separately using eventual consistency? Which approach should we take? As always, the answer is that it depends. In general, a useful guideline is “only update one aggregate per transaction.” If more than one aggregate is involved, we should use messages and eventual consistency as described above, even though both aggregates are within the same bounded context. But sometimes—and especially if the workflow is considered by the business to be a single transaction—it might be worth including all affected entities in the transaction. A classic example is transferring money between two accounts, where one account increases and the other decreases. ​ Start transaction ​ Add X amount to accountA ​ Remove X amount from accountB ​ Commit transaction If the accounts are represented by an Account aggregate, then we would be updating two different aggregates in the same transaction. That’s not necessarily a problem, but it might be a clue that you can refactor to get deeper insights into the domain. In cases like this, for example, the transaction often has its own identifier, which implies that it’s a DDD Entity in its own right. In that case, why not model it as such?
After this change, the Account entities would still exist, but they would no longer be directly responsible for adding or removing money. Instead the current balance for an Account would now be calculated by iterating over the MoneyTransfer records that reference it. We’ve not only refactored the design, but we’ve also learned something about the domain. This also shows that you shouldn’t feel obligated to reuse aggregates if it doesn’t make sense to do so. If you need to define a new aggregate just for one use case, go ahead.


さまざまなコンテキストの間で一貫性を保つにはどうすればよいでしょうか？上記のリストの2つ目の例を見てみましょう：注文が行われた場合、対応する請求書を作成する必要があります。注文が存在するが請求書が存在しない場合、データは一貫していません。請求書作成は注文取り扱いのドメインには属しておらず、請求ドメインに属しています。それはつまり、他のドメインにアクセスしてそのオブジェクトを操作する必要があるということでしょうか？いいえ、もちろんそうではありません。各バウンデッドコンテキストを分離し、疎結合に保つ必要があります。では、請求コンテキストのパブリックAPIを使用して、次のようにしますか：請求コンテキストに請求書の作成を依頼する――成功した場合：注文取り扱いコンテキストで注文を作成する。このアプローチは、見かけ以上にトリッキーです。なぜなら、更新に失敗する可能性も考慮する必要があるからです。別のシステム間で更新を同期させる方法はあります（たとえば、2フェーズ・コミットなど）、しかし実際にはこれが必要な場合は稀です。グレゴール・ホパの記事「スターバックスは2フェーズ・コミットを使用していない」[25]で、現実のビジネスでは通常、すべてのプロセスが1つのステージが完了するのを待って一斉に動くことを求める必要はないと指摘しています。代わりに、コーディネーションはメッセージを使って非同期に行われます。時々、問題が発生することもありますが、まれなエラーを処理するコストは、すべてを同期させるコストよりもはるかに少ないことがしばしばです。たとえば、請求書を即座に作成する必要がある代わりに、請求ドメインにメッセージ（またはイベント）を送信してその後の注文処理を続行することにしましょう。では、そのメッセージが失われて請求書が作成されなかった場合はどうなるでしょうか？1つのオプションは何もしないことです。その場合、顧客は無料で商品を手に入れることになり、事業者はコストを減価償却しなければなりません。エラーがまれでコストが小さい場合（コーヒーショップなど）、これは完全に十分な解決策かもしれません。別のオプションは、メッセージが失われたことを検出して再送信することです。これが基本的に和解プロセスが行うことです：2つのデータセットを比較し、一致しない場合はエラーを修正します。

三番目のオプションは、「前のアクションを元に戻す」またはエラーを修正する補償アクションを作成することです。注文取り扱いシナリオでは、これは注文をキャンセルし、顧客に商品を送り返すことに相当します！現実的には、補償アクションは、注文の間違いを修正したり、払い戻しを行ったりするために使用される場合があります。いずれの場合も、バウンデッドコンテキスト間で厳格な調整は必要ありません。一貫性の要件がある場合は、2番目または3番目のオプションを実装する必要があります。ただし、この種の一貫性は即座には実現されません。代わりに、システムは一定の時間が経過した後にのみ一貫性を持つようになります。「最終的な一貫性」と呼ばれます。最終的な一貫性は「選択的な一貫性」ではありません：システムが将来的なある時点で一貫性を持つことは非常に重要です。次に例を示します。もし製品の価格が変更された場合、まだ出荷されていないすべての注文の価格を更新したいとします。即時の一貫性が必要な場合、製品のレコード内の価格を更新する際に、影響を受けるすべての注文も更新し、それを同じトランザクション内で行う必要があります。これには時間がかかるかもしれません。しかし、製品の価格が変更された場合でも即時の一貫性を要求しない場合、代わりにPriceChangedイベントを作成し、これによってOutstanding Ordersの更新コマンドの一連のトリガーを起動することができます。これらのコマンドは、製品のレコード内の価格が変更された後のいずれかの時点で処理されます。数秒後か、数時間後かもしれません。最終的には、注文は更新され、システムは一貫性を持つようになります。

同じバウンデッドコンテキスト内のアグリゲート間の一貫性を保証するにはどうすればよいでしょうか？2つのアグリゲートを相互に一貫性を持たせる必要がある場合、それらを同じトランザクションで共に更新するか、イベント駆動と最終的な一貫性を使用して別々に更新するか、どちらのアプローチを取るべきでしょうか？いつものように、それは状況によります。一般的には、「1つのアグリゲートごとに1つの更新」を使うという有用なガイドラインがあります。複数のアグリゲートが関与する場合は、前述のようにメッセージと最終的な一貫性を使用する必要がありますが、それらのアグリゲートは同じバウンデッドコンテキスト内にあります。しかし、場合によっては、特にビジネス上のワークフローが単一のトランザクションと見なされる場合、関連するエンティティをすべてトランザクションに含める価値があるかもしれません。一般的な例は、2つのアカウント間で資金を移動することです。1つのアカウントが増え、もう1つが減るという場合です。

トランザクションを開始する
accountAにX金額を追加
accountBからX金額を差し引く
トランザクションをコミットする

アカウントをAccountアグリゲートで表現する場合、同じトランザクションで2つの異なるアグリゲートを更新します。それは必ずしも問題ではありませんが、ドメインについてより深い洞察を得るためのリファクタリングのヒントになるかもしれません。このような場合、トランザクションには独自の識別子があることがよくあり、それは独自のDDDEntityであることを意味します。その場合、それをそのようにモデル化するのはどうでしょうか？

この変更後も、Accountエンティティは存在し続けますが、お金の追加や差し引きを直接担当するわけではありません。代わりに、Accountの現在の残高は、それを参照するMoneyTransferレコードを反復処理して計算されるようになります。設計をリファクタリングするだけでなく、ドメインについても何かを学んだことになります。これは、もし意味がない場合は、必ずしもアグリゲートを再利用する必要はないということも示しています。1つのユースケースのために新たなアグリゲートを定義する必要がある場合は、どうぞやってください。