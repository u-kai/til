## フィーチャーの実装を受け入れテストから始める

- まずはフィーチャーの失敗する受け入れテストを書く
- 受け入れテストを書く際にはそのアプリケーションのドメインに由来する用語しか使わない
- これによって，システムが何をすべきかの理解が進み，さらに技術的実装に縛られることもない
- 技術的詳細が変わっても自分たちの受け入れテストスイートに影響が及ばないようにすることができる
- また，テストから始めることで，システムをユーザーの視点から見ることができるようになる
- つまり実装の観点からフィーチャーについて思案を重ねるのではなく，ユーザーが何をするためにこのシステムが必要なのかを理解できる
- 受け入れテストはユニットテスト済みのオブジェクトがうまく統合できることのテストとプロジェクトを前に進めていくことの両方をこなす

## 入力からはじめ，出力に向けて開発する

- フィーチャの開発を始める際にはまずシステムに入ってくるイベントについて考察する
  - そのイベントが新しい振る舞いのトリガになる
  - まずは外部のイベント受信するオブジェクトからはじめ，媒介となる例やを経由して中心的なドメインモデルへと至る
  - そこでまた目に見える外部のレスポンスを生成する別の境界オブジェクトに行き当たる
- 内部のドメインロジックからユニットテストを行うのが良いように見えるが，このやり方では後になって統合の問題に苦しめられることがある
- また，不要であったり，間違っていたりする機能を構築してしまって，時間を無駄にすることになるかもしれない
  - なぜなら作業時に適切なフィードバックを受け取ることができないから

## 振る舞いのユニットテストを行え，メソッドをテストするのではない

- 最初に書いたテストを後になって読み返すと理解しにくいのはあるある
- メソッドをテストしていることが多く，何をしているのかが明確でない時が多い
- テスト対象のオブジェクトが提供すべきフィーチャに集中した方がいい

  - それぞれのフィーチャでオブジェクトは複数の隣接オブジェクトとコラボレーションする必要があり，メソッドも複数呼び出されるから
  - 知りたいのは目的を達成するためにクラスをどう使えば良いかということ

- テストの名前を決める際に，テストされるシナリオないでオブジェクトがどう振る舞うかを記述するのは役にたつ

## テストの声を聴く

- コードのテストが難しいときはどうテストするのかを自問するのではなく，なぜテストをするのが難しいのかを問わないといけない
- 大体が設計を改善する必要があることが多い

## コンポジットは構成要素の早退よりもシンプルにせよ

- コンポジットオブジェクトの API はその構成要素よりも複雑になってはならない

## コンテキストからの独立

- コンポジットは構成要素の早退よりもシンプルにせよというルールはあるオブジェクトが十分に情報を隠蔽しているかどうかを判断するのに役にたつ
- それに対して，コンテキストからの独立ルールはオブジェクトが情報を隠蔽しすぎていないか，あるいは間違った情報を隠蔽していないかを判断するのに役にたつ
- オブジェクトがコンテキストから独立しているほど，システムを変更するのが容易になる
  - つまり各オブジェクトにそれを実行するシステムに関する知識が組み込まれていなければ良い
  - こうしておけば，振る舞いの単位を取り出して，新しい状況に適用することができるようになる
  - コンテキストから独立しているためには自分の実行環境についてオブジェクトが知りたいと思うものをそれがなんであっても外から渡さなければいけない
  - 各オブジェクトは仕事をする上でちょうど十分な指示を受け，その語彙にあった抽象の中にまとめられる
  - 複数のオブジェクトから構成されるシステムに，コンテキストからの独立ルールを適用することで，得られる効果に，関係性が明確になることがある
    - 関係性がオブジェクト自体とは区別して定義されているから
