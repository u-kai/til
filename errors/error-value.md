# エラー表現について

## 例外

```typescript
let maybe = "";
try {
  maybe = readFileSync("not-exist.txt");
} catch (e) {
  console.log(e.toString());
}
```

### メリット

- 例外が発生したところよりも親の関数であれば誰でも例外をキャッチすることができ，main や Web フレームワークなどの最上位概念にキャッチしてもらうように設計すれば，他の関数などはエラーが発生しないものとみなして関数を利用できる
- 例外が発生しうる処理を try 句でまとめて記述することができる

### デメリット

- 例外の有無は関数やメソッドのシグネチャからは確認することができず，シグネチャが嘘をつくことになる
- 上記理由から catch を行い忘れる可能性がある
- try,catch で処理行うためネストが少し深くなる
- 関数が成功した時に返す型と失敗した時にキャッチする型が異なるためそれぞれの値を同じように操作できない

## 返り値の型として表現

```rust
let maybe:Result<String,std::io::Error> = read_to_string("not-exist.txt");
let maybe = maybe.unwrap_or_default();
```

### メリット

- 関数のシグネチャが常に成り立つ

  - 要は成功しても失敗しても同じ型を返すということ

- error 型として必要なメソッドや関数が用意されていることが多く，簡単かつ可読性高くエラーケースを処理することができる
- 型として表現されているので，他の型との処理はエラーではないことを確認してから，またはエラーケースから復帰するような記述を書いてからでないと処理できずコンパイルエラーになる

### デメリット

- 失敗し得る関数を使う全ての関数で error を処理するか，返り値として同じような型をたらい回すかのどちらかになる
- 大域脱出といったことができない

## 多値返却で error を返す

```go
val,err := ReadFile("not-exist.txt")
if err != nil {
    return nil,err
}
```

### メリット

- 関数のシグネチャが常に成り立つ

### デメリット

- 正常値の型と error 型は異なるので，同じように扱えず，err 単独の定型処理が増える
  - ただし，脳死で err だったら親に返せば良い，というプラクティスで 8 割ぐらい救えるのでこれはこれで統一性や考えることが少なくなって悪くはないかも
